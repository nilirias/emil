Grammar:

Rule 0     S' -> program
Rule 1     program -> PROGRAM prog1 ID prog2 SEMICLN varsdecl funcdecl main lastquad
Rule 2     lastquad -> <empty>
Rule 3     prog1 -> <empty>
Rule 4     prog2 -> <empty>
Rule 5     varsdecl -> empty
Rule 6     varsdecl -> VARS prog3 multivd multid
Rule 7     prog3 -> <empty>
Rule 8     multivd -> empty
Rule 9     multivd -> tipo prog4 COLON ID prog5 arr multid SEMICLN multivd
Rule 10    prog4 -> <empty>
Rule 11    prog5 -> <empty>
Rule 12    multid -> empty
Rule 13    multid -> COMMA ID prog5 arr multid
Rule 14    tipo -> BOOL
Rule 15    tipo -> CHAR
Rule 16    tipo -> FLOAT
Rule 17    tipo -> INT
Rule 18    arr -> empty
Rule 19    arr -> LSQUARE exp RSQUARE
Rule 20    funcdecl -> empty
Rule 21    funcdecl -> FUNC tipofunc func1 ID func2 LPAREN param RPAREN func3 LCURLY varsdecl func4 stmnt RCURLY resetvarcont funcdecl
Rule 22    func1 -> <empty>
Rule 23    func2 -> <empty>
Rule 24    func3 -> <empty>
Rule 25    func4 -> <empty>
Rule 26    resetvarcont -> <empty>
Rule 27    tipofunc -> tipo
Rule 28    tipofunc -> VOID
Rule 29    param -> empty
Rule 30    param -> tipo param1 COLON ID param2 multiparam
Rule 31    param1 -> <empty>
Rule 32    param2 -> <empty>
Rule 33    multiparam -> empty
Rule 34    multiparam -> COMMA param
Rule 35    main -> MAIN scopemain LPAREN RPAREN stmnt maintemp
Rule 36    scopemain -> <empty>
Rule 37    maintemp -> <empty>
Rule 38    stmnt -> empty
Rule 39    stmnt -> while_stmnt stmnt
Rule 40    stmnt -> if_stmnt stmnt
Rule 41    stmnt -> write_stmnt stmnt
Rule 42    stmnt -> read_stmnt stmnt
Rule 43    stmnt -> ret_stmnt stmnt
Rule 44    stmnt -> func_stmnt stmnt
Rule 45    stmnt -> ass_stmnt stmnt
Rule 46    ass_stmnt -> ID arr ASS func_stmnt SEMICLN
Rule 47    ass_stmnt -> ID ass1 arr ASS ass2 paren ass3 SEMICLN
Rule 48    ass1 -> <empty>
Rule 49    ass2 -> <empty>
Rule 50    ass3 -> <empty>
Rule 51    func_stmnt -> ID fc1 LPAREN fc2 arg fc4 RPAREN fc5 SEMICLN
Rule 52    func_exp -> ID fc1 LPAREN fc2 arg fc4 RPAREN fc5 fexp
Rule 53    fc1 -> <empty>
Rule 54    fc2 -> <empty>
Rule 55    arg -> empty
Rule 56    arg -> paren fc3 multiarg
Rule 57    fc3 -> <empty>
Rule 58    fc4 -> <empty>
Rule 59    fc5 -> <empty>
Rule 60    multiarg -> empty
Rule 61    multiarg -> COMMA arg multiarg
Rule 62    ret_stmnt -> RETURN LPAREN paren retval RPAREN rettrue SEMICLN
Rule 63    rettrue -> <empty>
Rule 64    retval -> <empty>
Rule 65    read_stmnt -> READ io1 LPAREN paren multio io2 RPAREN io3 SEMICLN
Rule 66    write_stmnt -> WRITE io1 LPAREN paren io2 multio RPAREN io3 SEMICLN
Rule 67    multio -> <empty>
Rule 68    multio -> COMMA paren io2 multio
Rule 69    io1 -> <empty>
Rule 70    io2 -> <empty>
Rule 71    io3 -> <empty>
Rule 72    paren -> logic
Rule 73    paren -> LPAREN paren1 logic paren2 RPAREN paren3 logic
Rule 74    paren1 -> <empty>
Rule 75    paren2 -> <empty>
Rule 76    paren3 -> <empty>
Rule 77    logic -> rel log2 OR log1 logic
Rule 78    logic -> rel log2 AND log1 logic
Rule 79    logic -> rel log2
Rule 80    log1 -> <empty>
Rule 81    log2 -> <empty>
Rule 82    relop -> EQUAL_TO
Rule 83    relop -> DIFFERENT_TO
Rule 84    relop -> LESS_OR_EQ_THAN
Rule 85    relop -> MORE_OR_EQ_THAN
Rule 86    relop -> LESS_THAN
Rule 87    relop -> MORE_THAN
Rule 88    rel -> exp rel2 relop rel1 rel
Rule 89    rel -> exp rel2
Rule 90    rel1 -> <empty>
Rule 91    rel2 -> <empty>
Rule 92    exp -> term exp2 SUB exp1 exp
Rule 93    exp -> term exp2 SUM exp1 exp
Rule 94    exp -> term exp2
Rule 95    exp2 -> <empty>
Rule 96    exp1 -> <empty>
Rule 97    term -> factor term2 DIV term1 term
Rule 98    term -> factor term2 MULT term1 term
Rule 99    term -> factor term2
Rule 100   term1 -> <empty>
Rule 101   term2 -> <empty>
Rule 102   fexp -> <empty>
Rule 103   factor -> func_exp
Rule 104   factor -> FALSE ctes4
Rule 105   factor -> TRUE ctes4
Rule 106   factor -> CTE_STR ctes3
Rule 107   factor -> CTE_FLT ctes2
Rule 108   factor -> CTE_NUM ctes1
Rule 109   factor -> ID fact1 LPAREN logic multiexp RPAREN
Rule 110   factor -> ID fact1 arr
Rule 111   ctes1 -> <empty>
Rule 112   ctes2 -> <empty>
Rule 113   ctes3 -> <empty>
Rule 114   ctes4 -> <empty>
Rule 115   fact1 -> <empty>
Rule 116   multiexp -> empty
Rule 117   multiexp -> COMMA paren multiexp
Rule 118   if_stmnt -> IF LPAREN paren if1 RPAREN stmnt else_stmnt END if2
Rule 119   if1 -> <empty>
Rule 120   if2 -> <empty>
Rule 121   else_stmnt -> empty
Rule 122   else_stmnt -> ELSE else1 stmnt
Rule 123   else1 -> <empty>
Rule 124   while_stmnt -> WHILE while1 LPAREN paren while2 RPAREN stmnt while3 END
Rule 125   while1 -> <empty>
Rule 126   while2 -> <empty>
Rule 127   while3 -> <empty>
Rule 128   empty -> <empty>

Terminals, with rules where they appear:

AND                  : 78
ASS                  : 46 47
BOOL                 : 14
CHAR                 : 15
COLON                : 9 30
COMMA                : 13 34 61 68 117
CTE_FLT              : 107
CTE_NUM              : 108
CTE_STR              : 106
DIFFERENT_TO         : 83
DIV                  : 97
ELSE                 : 122
END                  : 118 124
EQUAL_TO             : 82
FALSE                : 104
FLOAT                : 16
FUNC                 : 21
ID                   : 1 9 13 21 30 46 47 51 52 109 110
IF                   : 118
INT                  : 17
LCURLY               : 21
LESS_OR_EQ_THAN      : 84
LESS_THAN            : 86
LPAREN               : 21 35 51 52 62 65 66 73 109 118 124
LSQUARE              : 19
MAIN                 : 35
MORE_OR_EQ_THAN      : 85
MORE_THAN            : 87
MULT                 : 98
OR                   : 77
PROGRAM              : 1
RCURLY               : 21
READ                 : 65
RETURN               : 62
RPAREN               : 21 35 51 52 62 65 66 73 109 118 124
RSQUARE              : 19
SEMICLN              : 1 9 46 47 51 62 65 66
SUB                  : 92
SUM                  : 93
TRUE                 : 105
VARS                 : 6
VOID                 : 28
WHILE                : 124
WRITE                : 66
error                : 

Nonterminals, with rules where they appear:

arg                  : 51 52 61
arr                  : 9 13 46 47 110
ass1                 : 47
ass2                 : 47
ass3                 : 47
ass_stmnt            : 45
ctes1                : 108
ctes2                : 107
ctes3                : 106
ctes4                : 104 105
else1                : 122
else_stmnt           : 118
empty                : 5 8 12 18 20 29 33 38 55 60 116 121
exp                  : 19 88 89 92 93
exp1                 : 92 93
exp2                 : 92 93 94
fact1                : 109 110
factor               : 97 98 99
fc1                  : 51 52
fc2                  : 51 52
fc3                  : 56
fc4                  : 51 52
fc5                  : 51 52
fexp                 : 52
func1                : 21
func2                : 21
func3                : 21
func4                : 21
func_exp             : 103
func_stmnt           : 44 46
funcdecl             : 1 21
if1                  : 118
if2                  : 118
if_stmnt             : 40
io1                  : 65 66
io2                  : 65 66 68
io3                  : 65 66
lastquad             : 1
log1                 : 77 78
log2                 : 77 78 79
logic                : 72 73 73 77 78 109
main                 : 1
maintemp             : 35
multiarg             : 56 61
multid               : 6 9 13
multiexp             : 109 117
multio               : 65 66 68
multiparam           : 30
multivd              : 6 9
param                : 21 34
param1               : 30
param2               : 30
paren                : 47 56 62 65 66 68 117 118 124
paren1               : 73
paren2               : 73
paren3               : 73
prog1                : 1
prog2                : 1
prog3                : 6
prog4                : 9
prog5                : 9 13
program              : 0
read_stmnt           : 42
rel                  : 77 78 79 88
rel1                 : 88
rel2                 : 88 89
relop                : 88
resetvarcont         : 21
ret_stmnt            : 43
rettrue              : 62
retval               : 62
scopemain            : 35
stmnt                : 21 35 39 40 41 42 43 44 45 118 122 124
term                 : 92 93 94 97 98
term1                : 97 98
term2                : 97 98 99
tipo                 : 9 27 30
tipofunc             : 21
varsdecl             : 1 21
while1               : 124
while2               : 124
while3               : 124
while_stmnt          : 39
write_stmnt          : 41


state 0

    (0) S' -> . program
    (1) program -> . PROGRAM prog1 ID prog2 SEMICLN varsdecl funcdecl main lastquad
    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .


state 2

    (1) program -> PROGRAM . prog1 ID prog2 SEMICLN varsdecl funcdecl main lastquad
    (3) prog1 -> .
    ID              reduce using rule 3 (prog1 -> .)

    prog1                          shift and go to state 3

state 3

    (1) program -> PROGRAM prog1 . ID prog2 SEMICLN varsdecl funcdecl main lastquad
    ID              shift and go to state 4


state 4

    (1) program -> PROGRAM prog1 ID . prog2 SEMICLN varsdecl funcdecl main lastquad
    (4) prog2 -> .
    SEMICLN         reduce using rule 4 (prog2 -> .)

    prog2                          shift and go to state 5

state 5

    (1) program -> PROGRAM prog1 ID prog2 . SEMICLN varsdecl funcdecl main lastquad
    SEMICLN         shift and go to state 6


state 6

    (1) program -> PROGRAM prog1 ID prog2 SEMICLN . varsdecl funcdecl main lastquad
    (5) varsdecl -> . empty
    (6) varsdecl -> . VARS prog3 multivd multid
    (128) empty -> .
    VARS            shift and go to state 9
    FUNC            reduce using rule 128 (empty -> .)
    MAIN            reduce using rule 128 (empty -> .)

    varsdecl                       shift and go to state 7
    empty                          shift and go to state 8

state 7

    (1) program -> PROGRAM prog1 ID prog2 SEMICLN varsdecl . funcdecl main lastquad
    (20) funcdecl -> . empty
    (21) funcdecl -> . FUNC tipofunc func1 ID func2 LPAREN param RPAREN func3 LCURLY varsdecl func4 stmnt RCURLY resetvarcont funcdecl
    (128) empty -> .
    FUNC            shift and go to state 12
    MAIN            reduce using rule 128 (empty -> .)

    funcdecl                       shift and go to state 10
    empty                          shift and go to state 11

state 8

    (5) varsdecl -> empty .
    FUNC            reduce using rule 5 (varsdecl -> empty .)
    MAIN            reduce using rule 5 (varsdecl -> empty .)
    WHILE           reduce using rule 5 (varsdecl -> empty .)
    IF              reduce using rule 5 (varsdecl -> empty .)
    WRITE           reduce using rule 5 (varsdecl -> empty .)
    READ            reduce using rule 5 (varsdecl -> empty .)
    RETURN          reduce using rule 5 (varsdecl -> empty .)
    ID              reduce using rule 5 (varsdecl -> empty .)
    RCURLY          reduce using rule 5 (varsdecl -> empty .)


state 9

    (6) varsdecl -> VARS . prog3 multivd multid
    (7) prog3 -> .
    BOOL            reduce using rule 7 (prog3 -> .)
    CHAR            reduce using rule 7 (prog3 -> .)
    FLOAT           reduce using rule 7 (prog3 -> .)
    INT             reduce using rule 7 (prog3 -> .)
    COMMA           reduce using rule 7 (prog3 -> .)
    FUNC            reduce using rule 7 (prog3 -> .)
    MAIN            reduce using rule 7 (prog3 -> .)
    WHILE           reduce using rule 7 (prog3 -> .)
    IF              reduce using rule 7 (prog3 -> .)
    WRITE           reduce using rule 7 (prog3 -> .)
    READ            reduce using rule 7 (prog3 -> .)
    RETURN          reduce using rule 7 (prog3 -> .)
    ID              reduce using rule 7 (prog3 -> .)
    RCURLY          reduce using rule 7 (prog3 -> .)

    prog3                          shift and go to state 13

state 10

    (1) program -> PROGRAM prog1 ID prog2 SEMICLN varsdecl funcdecl . main lastquad
    (35) main -> . MAIN scopemain LPAREN RPAREN stmnt maintemp
    MAIN            shift and go to state 15

    main                           shift and go to state 14

state 11

    (20) funcdecl -> empty .
    MAIN            reduce using rule 20 (funcdecl -> empty .)


state 12

    (21) funcdecl -> FUNC . tipofunc func1 ID func2 LPAREN param RPAREN func3 LCURLY varsdecl func4 stmnt RCURLY resetvarcont funcdecl
    (27) tipofunc -> . tipo
    (28) tipofunc -> . VOID
    (14) tipo -> . BOOL
    (15) tipo -> . CHAR
    (16) tipo -> . FLOAT
    (17) tipo -> . INT
    VOID            shift and go to state 18
    BOOL            shift and go to state 19
    CHAR            shift and go to state 20
    FLOAT           shift and go to state 21
    INT             shift and go to state 22

    tipofunc                       shift and go to state 16
    tipo                           shift and go to state 17

state 13

    (6) varsdecl -> VARS prog3 . multivd multid
    (8) multivd -> . empty
    (9) multivd -> . tipo prog4 COLON ID prog5 arr multid SEMICLN multivd
    (128) empty -> .
    (14) tipo -> . BOOL
    (15) tipo -> . CHAR
    (16) tipo -> . FLOAT
    (17) tipo -> . INT
    COMMA           reduce using rule 128 (empty -> .)
    FUNC            reduce using rule 128 (empty -> .)
    MAIN            reduce using rule 128 (empty -> .)
    WHILE           reduce using rule 128 (empty -> .)
    IF              reduce using rule 128 (empty -> .)
    WRITE           reduce using rule 128 (empty -> .)
    READ            reduce using rule 128 (empty -> .)
    RETURN          reduce using rule 128 (empty -> .)
    ID              reduce using rule 128 (empty -> .)
    RCURLY          reduce using rule 128 (empty -> .)
    BOOL            shift and go to state 19
    CHAR            shift and go to state 20
    FLOAT           shift and go to state 21
    INT             shift and go to state 22

    multivd                        shift and go to state 23
    empty                          shift and go to state 24
    tipo                           shift and go to state 25

state 14

    (1) program -> PROGRAM prog1 ID prog2 SEMICLN varsdecl funcdecl main . lastquad
    (2) lastquad -> .
    $end            reduce using rule 2 (lastquad -> .)

    lastquad                       shift and go to state 26

state 15

    (35) main -> MAIN . scopemain LPAREN RPAREN stmnt maintemp
    (36) scopemain -> .
    LPAREN          reduce using rule 36 (scopemain -> .)

    scopemain                      shift and go to state 27

state 16

    (21) funcdecl -> FUNC tipofunc . func1 ID func2 LPAREN param RPAREN func3 LCURLY varsdecl func4 stmnt RCURLY resetvarcont funcdecl
    (22) func1 -> .
    ID              reduce using rule 22 (func1 -> .)

    func1                          shift and go to state 28

state 17

    (27) tipofunc -> tipo .
    ID              reduce using rule 27 (tipofunc -> tipo .)


state 18

    (28) tipofunc -> VOID .
    ID              reduce using rule 28 (tipofunc -> VOID .)


state 19

    (14) tipo -> BOOL .
    ID              reduce using rule 14 (tipo -> BOOL .)
    COLON           reduce using rule 14 (tipo -> BOOL .)


state 20

    (15) tipo -> CHAR .
    ID              reduce using rule 15 (tipo -> CHAR .)
    COLON           reduce using rule 15 (tipo -> CHAR .)


state 21

    (16) tipo -> FLOAT .
    ID              reduce using rule 16 (tipo -> FLOAT .)
    COLON           reduce using rule 16 (tipo -> FLOAT .)


state 22

    (17) tipo -> INT .
    ID              reduce using rule 17 (tipo -> INT .)
    COLON           reduce using rule 17 (tipo -> INT .)


state 23

    (6) varsdecl -> VARS prog3 multivd . multid
    (12) multid -> . empty
    (13) multid -> . COMMA ID prog5 arr multid
    (128) empty -> .
    COMMA           shift and go to state 31
    FUNC            reduce using rule 128 (empty -> .)
    MAIN            reduce using rule 128 (empty -> .)
    WHILE           reduce using rule 128 (empty -> .)
    IF              reduce using rule 128 (empty -> .)
    WRITE           reduce using rule 128 (empty -> .)
    READ            reduce using rule 128 (empty -> .)
    RETURN          reduce using rule 128 (empty -> .)
    ID              reduce using rule 128 (empty -> .)
    RCURLY          reduce using rule 128 (empty -> .)

    multid                         shift and go to state 29
    empty                          shift and go to state 30

state 24

    (8) multivd -> empty .
    COMMA           reduce using rule 8 (multivd -> empty .)
    FUNC            reduce using rule 8 (multivd -> empty .)
    MAIN            reduce using rule 8 (multivd -> empty .)
    WHILE           reduce using rule 8 (multivd -> empty .)
    IF              reduce using rule 8 (multivd -> empty .)
    WRITE           reduce using rule 8 (multivd -> empty .)
    READ            reduce using rule 8 (multivd -> empty .)
    RETURN          reduce using rule 8 (multivd -> empty .)
    ID              reduce using rule 8 (multivd -> empty .)
    RCURLY          reduce using rule 8 (multivd -> empty .)


state 25

    (9) multivd -> tipo . prog4 COLON ID prog5 arr multid SEMICLN multivd
    (10) prog4 -> .
    COLON           reduce using rule 10 (prog4 -> .)

    prog4                          shift and go to state 32

state 26

    (1) program -> PROGRAM prog1 ID prog2 SEMICLN varsdecl funcdecl main lastquad .
    $end            reduce using rule 1 (program -> PROGRAM prog1 ID prog2 SEMICLN varsdecl funcdecl main lastquad .)


state 27

    (35) main -> MAIN scopemain . LPAREN RPAREN stmnt maintemp
    LPAREN          shift and go to state 33


state 28

    (21) funcdecl -> FUNC tipofunc func1 . ID func2 LPAREN param RPAREN func3 LCURLY varsdecl func4 stmnt RCURLY resetvarcont funcdecl
    ID              shift and go to state 34


state 29

    (6) varsdecl -> VARS prog3 multivd multid .
    FUNC            reduce using rule 6 (varsdecl -> VARS prog3 multivd multid .)
    MAIN            reduce using rule 6 (varsdecl -> VARS prog3 multivd multid .)
    WHILE           reduce using rule 6 (varsdecl -> VARS prog3 multivd multid .)
    IF              reduce using rule 6 (varsdecl -> VARS prog3 multivd multid .)
    WRITE           reduce using rule 6 (varsdecl -> VARS prog3 multivd multid .)
    READ            reduce using rule 6 (varsdecl -> VARS prog3 multivd multid .)
    RETURN          reduce using rule 6 (varsdecl -> VARS prog3 multivd multid .)
    ID              reduce using rule 6 (varsdecl -> VARS prog3 multivd multid .)
    RCURLY          reduce using rule 6 (varsdecl -> VARS prog3 multivd multid .)


state 30

    (12) multid -> empty .
    FUNC            reduce using rule 12 (multid -> empty .)
    MAIN            reduce using rule 12 (multid -> empty .)
    WHILE           reduce using rule 12 (multid -> empty .)
    IF              reduce using rule 12 (multid -> empty .)
    WRITE           reduce using rule 12 (multid -> empty .)
    READ            reduce using rule 12 (multid -> empty .)
    RETURN          reduce using rule 12 (multid -> empty .)
    ID              reduce using rule 12 (multid -> empty .)
    RCURLY          reduce using rule 12 (multid -> empty .)
    SEMICLN         reduce using rule 12 (multid -> empty .)


state 31

    (13) multid -> COMMA . ID prog5 arr multid
    ID              shift and go to state 35


state 32

    (9) multivd -> tipo prog4 . COLON ID prog5 arr multid SEMICLN multivd
    COLON           shift and go to state 36


state 33

    (35) main -> MAIN scopemain LPAREN . RPAREN stmnt maintemp
    RPAREN          shift and go to state 37


state 34

    (21) funcdecl -> FUNC tipofunc func1 ID . func2 LPAREN param RPAREN func3 LCURLY varsdecl func4 stmnt RCURLY resetvarcont funcdecl
    (23) func2 -> .
    LPAREN          reduce using rule 23 (func2 -> .)

    func2                          shift and go to state 38

state 35

    (13) multid -> COMMA ID . prog5 arr multid
    (11) prog5 -> .
    LSQUARE         reduce using rule 11 (prog5 -> .)
    COMMA           reduce using rule 11 (prog5 -> .)
    FUNC            reduce using rule 11 (prog5 -> .)
    MAIN            reduce using rule 11 (prog5 -> .)
    WHILE           reduce using rule 11 (prog5 -> .)
    IF              reduce using rule 11 (prog5 -> .)
    WRITE           reduce using rule 11 (prog5 -> .)
    READ            reduce using rule 11 (prog5 -> .)
    RETURN          reduce using rule 11 (prog5 -> .)
    ID              reduce using rule 11 (prog5 -> .)
    RCURLY          reduce using rule 11 (prog5 -> .)
    SEMICLN         reduce using rule 11 (prog5 -> .)

    prog5                          shift and go to state 39

state 36

    (9) multivd -> tipo prog4 COLON . ID prog5 arr multid SEMICLN multivd
    ID              shift and go to state 40


state 37

    (35) main -> MAIN scopemain LPAREN RPAREN . stmnt maintemp
    (38) stmnt -> . empty
    (39) stmnt -> . while_stmnt stmnt
    (40) stmnt -> . if_stmnt stmnt
    (41) stmnt -> . write_stmnt stmnt
    (42) stmnt -> . read_stmnt stmnt
    (43) stmnt -> . ret_stmnt stmnt
    (44) stmnt -> . func_stmnt stmnt
    (45) stmnt -> . ass_stmnt stmnt
    (128) empty -> .
    (124) while_stmnt -> . WHILE while1 LPAREN paren while2 RPAREN stmnt while3 END
    (118) if_stmnt -> . IF LPAREN paren if1 RPAREN stmnt else_stmnt END if2
    (66) write_stmnt -> . WRITE io1 LPAREN paren io2 multio RPAREN io3 SEMICLN
    (65) read_stmnt -> . READ io1 LPAREN paren multio io2 RPAREN io3 SEMICLN
    (62) ret_stmnt -> . RETURN LPAREN paren retval RPAREN rettrue SEMICLN
    (51) func_stmnt -> . ID fc1 LPAREN fc2 arg fc4 RPAREN fc5 SEMICLN
    (46) ass_stmnt -> . ID arr ASS func_stmnt SEMICLN
    (47) ass_stmnt -> . ID ass1 arr ASS ass2 paren ass3 SEMICLN
    $end            reduce using rule 128 (empty -> .)
    WHILE           shift and go to state 50
    IF              shift and go to state 51
    WRITE           shift and go to state 52
    READ            shift and go to state 53
    RETURN          shift and go to state 54
    ID              shift and go to state 55

    stmnt                          shift and go to state 41
    empty                          shift and go to state 42
    while_stmnt                    shift and go to state 43
    if_stmnt                       shift and go to state 44
    write_stmnt                    shift and go to state 45
    read_stmnt                     shift and go to state 46
    ret_stmnt                      shift and go to state 47
    func_stmnt                     shift and go to state 48
    ass_stmnt                      shift and go to state 49

state 38

    (21) funcdecl -> FUNC tipofunc func1 ID func2 . LPAREN param RPAREN func3 LCURLY varsdecl func4 stmnt RCURLY resetvarcont funcdecl
    LPAREN          shift and go to state 56


state 39

    (13) multid -> COMMA ID prog5 . arr multid
    (18) arr -> . empty
    (19) arr -> . LSQUARE exp RSQUARE
    (128) empty -> .
    LSQUARE         shift and go to state 59
    COMMA           reduce using rule 128 (empty -> .)
    FUNC            reduce using rule 128 (empty -> .)
    MAIN            reduce using rule 128 (empty -> .)
    WHILE           reduce using rule 128 (empty -> .)
    IF              reduce using rule 128 (empty -> .)
    WRITE           reduce using rule 128 (empty -> .)
    READ            reduce using rule 128 (empty -> .)
    RETURN          reduce using rule 128 (empty -> .)
    ID              reduce using rule 128 (empty -> .)
    RCURLY          reduce using rule 128 (empty -> .)
    SEMICLN         reduce using rule 128 (empty -> .)

    arr                            shift and go to state 57
    empty                          shift and go to state 58

state 40

    (9) multivd -> tipo prog4 COLON ID . prog5 arr multid SEMICLN multivd
    (11) prog5 -> .
    LSQUARE         reduce using rule 11 (prog5 -> .)
    COMMA           reduce using rule 11 (prog5 -> .)
    SEMICLN         reduce using rule 11 (prog5 -> .)

    prog5                          shift and go to state 60

state 41

    (35) main -> MAIN scopemain LPAREN RPAREN stmnt . maintemp
    (37) maintemp -> .
    $end            reduce using rule 37 (maintemp -> .)

    maintemp                       shift and go to state 61

state 42

    (38) stmnt -> empty .
    $end            reduce using rule 38 (stmnt -> empty .)
    ELSE            reduce using rule 38 (stmnt -> empty .)
    END             reduce using rule 38 (stmnt -> empty .)
    RCURLY          reduce using rule 38 (stmnt -> empty .)


state 43

    (39) stmnt -> while_stmnt . stmnt
    (38) stmnt -> . empty
    (39) stmnt -> . while_stmnt stmnt
    (40) stmnt -> . if_stmnt stmnt
    (41) stmnt -> . write_stmnt stmnt
    (42) stmnt -> . read_stmnt stmnt
    (43) stmnt -> . ret_stmnt stmnt
    (44) stmnt -> . func_stmnt stmnt
    (45) stmnt -> . ass_stmnt stmnt
    (128) empty -> .
    (124) while_stmnt -> . WHILE while1 LPAREN paren while2 RPAREN stmnt while3 END
    (118) if_stmnt -> . IF LPAREN paren if1 RPAREN stmnt else_stmnt END if2
    (66) write_stmnt -> . WRITE io1 LPAREN paren io2 multio RPAREN io3 SEMICLN
    (65) read_stmnt -> . READ io1 LPAREN paren multio io2 RPAREN io3 SEMICLN
    (62) ret_stmnt -> . RETURN LPAREN paren retval RPAREN rettrue SEMICLN
    (51) func_stmnt -> . ID fc1 LPAREN fc2 arg fc4 RPAREN fc5 SEMICLN
    (46) ass_stmnt -> . ID arr ASS func_stmnt SEMICLN
    (47) ass_stmnt -> . ID ass1 arr ASS ass2 paren ass3 SEMICLN
    $end            reduce using rule 128 (empty -> .)
    ELSE            reduce using rule 128 (empty -> .)
    END             reduce using rule 128 (empty -> .)
    RCURLY          reduce using rule 128 (empty -> .)
    WHILE           shift and go to state 50
    IF              shift and go to state 51
    WRITE           shift and go to state 52
    READ            shift and go to state 53
    RETURN          shift and go to state 54
    ID              shift and go to state 55

    while_stmnt                    shift and go to state 43
    stmnt                          shift and go to state 62
    empty                          shift and go to state 42
    if_stmnt                       shift and go to state 44
    write_stmnt                    shift and go to state 45
    read_stmnt                     shift and go to state 46
    ret_stmnt                      shift and go to state 47
    func_stmnt                     shift and go to state 48
    ass_stmnt                      shift and go to state 49

state 44

    (40) stmnt -> if_stmnt . stmnt
    (38) stmnt -> . empty
    (39) stmnt -> . while_stmnt stmnt
    (40) stmnt -> . if_stmnt stmnt
    (41) stmnt -> . write_stmnt stmnt
    (42) stmnt -> . read_stmnt stmnt
    (43) stmnt -> . ret_stmnt stmnt
    (44) stmnt -> . func_stmnt stmnt
    (45) stmnt -> . ass_stmnt stmnt
    (128) empty -> .
    (124) while_stmnt -> . WHILE while1 LPAREN paren while2 RPAREN stmnt while3 END
    (118) if_stmnt -> . IF LPAREN paren if1 RPAREN stmnt else_stmnt END if2
    (66) write_stmnt -> . WRITE io1 LPAREN paren io2 multio RPAREN io3 SEMICLN
    (65) read_stmnt -> . READ io1 LPAREN paren multio io2 RPAREN io3 SEMICLN
    (62) ret_stmnt -> . RETURN LPAREN paren retval RPAREN rettrue SEMICLN
    (51) func_stmnt -> . ID fc1 LPAREN fc2 arg fc4 RPAREN fc5 SEMICLN
    (46) ass_stmnt -> . ID arr ASS func_stmnt SEMICLN
    (47) ass_stmnt -> . ID ass1 arr ASS ass2 paren ass3 SEMICLN
    $end            reduce using rule 128 (empty -> .)
    ELSE            reduce using rule 128 (empty -> .)
    END             reduce using rule 128 (empty -> .)
    RCURLY          reduce using rule 128 (empty -> .)
    WHILE           shift and go to state 50
    IF              shift and go to state 51
    WRITE           shift and go to state 52
    READ            shift and go to state 53
    RETURN          shift and go to state 54
    ID              shift and go to state 55

    if_stmnt                       shift and go to state 44
    stmnt                          shift and go to state 63
    empty                          shift and go to state 42
    while_stmnt                    shift and go to state 43
    write_stmnt                    shift and go to state 45
    read_stmnt                     shift and go to state 46
    ret_stmnt                      shift and go to state 47
    func_stmnt                     shift and go to state 48
    ass_stmnt                      shift and go to state 49

state 45

    (41) stmnt -> write_stmnt . stmnt
    (38) stmnt -> . empty
    (39) stmnt -> . while_stmnt stmnt
    (40) stmnt -> . if_stmnt stmnt
    (41) stmnt -> . write_stmnt stmnt
    (42) stmnt -> . read_stmnt stmnt
    (43) stmnt -> . ret_stmnt stmnt
    (44) stmnt -> . func_stmnt stmnt
    (45) stmnt -> . ass_stmnt stmnt
    (128) empty -> .
    (124) while_stmnt -> . WHILE while1 LPAREN paren while2 RPAREN stmnt while3 END
    (118) if_stmnt -> . IF LPAREN paren if1 RPAREN stmnt else_stmnt END if2
    (66) write_stmnt -> . WRITE io1 LPAREN paren io2 multio RPAREN io3 SEMICLN
    (65) read_stmnt -> . READ io1 LPAREN paren multio io2 RPAREN io3 SEMICLN
    (62) ret_stmnt -> . RETURN LPAREN paren retval RPAREN rettrue SEMICLN
    (51) func_stmnt -> . ID fc1 LPAREN fc2 arg fc4 RPAREN fc5 SEMICLN
    (46) ass_stmnt -> . ID arr ASS func_stmnt SEMICLN
    (47) ass_stmnt -> . ID ass1 arr ASS ass2 paren ass3 SEMICLN
    $end            reduce using rule 128 (empty -> .)
    ELSE            reduce using rule 128 (empty -> .)
    END             reduce using rule 128 (empty -> .)
    RCURLY          reduce using rule 128 (empty -> .)
    WHILE           shift and go to state 50
    IF              shift and go to state 51
    WRITE           shift and go to state 52
    READ            shift and go to state 53
    RETURN          shift and go to state 54
    ID              shift and go to state 55

    write_stmnt                    shift and go to state 45
    stmnt                          shift and go to state 64
    empty                          shift and go to state 42
    while_stmnt                    shift and go to state 43
    if_stmnt                       shift and go to state 44
    read_stmnt                     shift and go to state 46
    ret_stmnt                      shift and go to state 47
    func_stmnt                     shift and go to state 48
    ass_stmnt                      shift and go to state 49

state 46

    (42) stmnt -> read_stmnt . stmnt
    (38) stmnt -> . empty
    (39) stmnt -> . while_stmnt stmnt
    (40) stmnt -> . if_stmnt stmnt
    (41) stmnt -> . write_stmnt stmnt
    (42) stmnt -> . read_stmnt stmnt
    (43) stmnt -> . ret_stmnt stmnt
    (44) stmnt -> . func_stmnt stmnt
    (45) stmnt -> . ass_stmnt stmnt
    (128) empty -> .
    (124) while_stmnt -> . WHILE while1 LPAREN paren while2 RPAREN stmnt while3 END
    (118) if_stmnt -> . IF LPAREN paren if1 RPAREN stmnt else_stmnt END if2
    (66) write_stmnt -> . WRITE io1 LPAREN paren io2 multio RPAREN io3 SEMICLN
    (65) read_stmnt -> . READ io1 LPAREN paren multio io2 RPAREN io3 SEMICLN
    (62) ret_stmnt -> . RETURN LPAREN paren retval RPAREN rettrue SEMICLN
    (51) func_stmnt -> . ID fc1 LPAREN fc2 arg fc4 RPAREN fc5 SEMICLN
    (46) ass_stmnt -> . ID arr ASS func_stmnt SEMICLN
    (47) ass_stmnt -> . ID ass1 arr ASS ass2 paren ass3 SEMICLN
    $end            reduce using rule 128 (empty -> .)
    ELSE            reduce using rule 128 (empty -> .)
    END             reduce using rule 128 (empty -> .)
    RCURLY          reduce using rule 128 (empty -> .)
    WHILE           shift and go to state 50
    IF              shift and go to state 51
    WRITE           shift and go to state 52
    READ            shift and go to state 53
    RETURN          shift and go to state 54
    ID              shift and go to state 55

    read_stmnt                     shift and go to state 46
    stmnt                          shift and go to state 65
    empty                          shift and go to state 42
    while_stmnt                    shift and go to state 43
    if_stmnt                       shift and go to state 44
    write_stmnt                    shift and go to state 45
    ret_stmnt                      shift and go to state 47
    func_stmnt                     shift and go to state 48
    ass_stmnt                      shift and go to state 49

state 47

    (43) stmnt -> ret_stmnt . stmnt
    (38) stmnt -> . empty
    (39) stmnt -> . while_stmnt stmnt
    (40) stmnt -> . if_stmnt stmnt
    (41) stmnt -> . write_stmnt stmnt
    (42) stmnt -> . read_stmnt stmnt
    (43) stmnt -> . ret_stmnt stmnt
    (44) stmnt -> . func_stmnt stmnt
    (45) stmnt -> . ass_stmnt stmnt
    (128) empty -> .
    (124) while_stmnt -> . WHILE while1 LPAREN paren while2 RPAREN stmnt while3 END
    (118) if_stmnt -> . IF LPAREN paren if1 RPAREN stmnt else_stmnt END if2
    (66) write_stmnt -> . WRITE io1 LPAREN paren io2 multio RPAREN io3 SEMICLN
    (65) read_stmnt -> . READ io1 LPAREN paren multio io2 RPAREN io3 SEMICLN
    (62) ret_stmnt -> . RETURN LPAREN paren retval RPAREN rettrue SEMICLN
    (51) func_stmnt -> . ID fc1 LPAREN fc2 arg fc4 RPAREN fc5 SEMICLN
    (46) ass_stmnt -> . ID arr ASS func_stmnt SEMICLN
    (47) ass_stmnt -> . ID ass1 arr ASS ass2 paren ass3 SEMICLN
    $end            reduce using rule 128 (empty -> .)
    ELSE            reduce using rule 128 (empty -> .)
    END             reduce using rule 128 (empty -> .)
    RCURLY          reduce using rule 128 (empty -> .)
    WHILE           shift and go to state 50
    IF              shift and go to state 51
    WRITE           shift and go to state 52
    READ            shift and go to state 53
    RETURN          shift and go to state 54
    ID              shift and go to state 55

    ret_stmnt                      shift and go to state 47
    stmnt                          shift and go to state 66
    empty                          shift and go to state 42
    while_stmnt                    shift and go to state 43
    if_stmnt                       shift and go to state 44
    write_stmnt                    shift and go to state 45
    read_stmnt                     shift and go to state 46
    func_stmnt                     shift and go to state 48
    ass_stmnt                      shift and go to state 49

state 48

    (44) stmnt -> func_stmnt . stmnt
    (38) stmnt -> . empty
    (39) stmnt -> . while_stmnt stmnt
    (40) stmnt -> . if_stmnt stmnt
    (41) stmnt -> . write_stmnt stmnt
    (42) stmnt -> . read_stmnt stmnt
    (43) stmnt -> . ret_stmnt stmnt
    (44) stmnt -> . func_stmnt stmnt
    (45) stmnt -> . ass_stmnt stmnt
    (128) empty -> .
    (124) while_stmnt -> . WHILE while1 LPAREN paren while2 RPAREN stmnt while3 END
    (118) if_stmnt -> . IF LPAREN paren if1 RPAREN stmnt else_stmnt END if2
    (66) write_stmnt -> . WRITE io1 LPAREN paren io2 multio RPAREN io3 SEMICLN
    (65) read_stmnt -> . READ io1 LPAREN paren multio io2 RPAREN io3 SEMICLN
    (62) ret_stmnt -> . RETURN LPAREN paren retval RPAREN rettrue SEMICLN
    (51) func_stmnt -> . ID fc1 LPAREN fc2 arg fc4 RPAREN fc5 SEMICLN
    (46) ass_stmnt -> . ID arr ASS func_stmnt SEMICLN
    (47) ass_stmnt -> . ID ass1 arr ASS ass2 paren ass3 SEMICLN
    $end            reduce using rule 128 (empty -> .)
    ELSE            reduce using rule 128 (empty -> .)
    END             reduce using rule 128 (empty -> .)
    RCURLY          reduce using rule 128 (empty -> .)
    WHILE           shift and go to state 50
    IF              shift and go to state 51
    WRITE           shift and go to state 52
    READ            shift and go to state 53
    RETURN          shift and go to state 54
    ID              shift and go to state 55

    func_stmnt                     shift and go to state 48
    stmnt                          shift and go to state 67
    empty                          shift and go to state 42
    while_stmnt                    shift and go to state 43
    if_stmnt                       shift and go to state 44
    write_stmnt                    shift and go to state 45
    read_stmnt                     shift and go to state 46
    ret_stmnt                      shift and go to state 47
    ass_stmnt                      shift and go to state 49

state 49

    (45) stmnt -> ass_stmnt . stmnt
    (38) stmnt -> . empty
    (39) stmnt -> . while_stmnt stmnt
    (40) stmnt -> . if_stmnt stmnt
    (41) stmnt -> . write_stmnt stmnt
    (42) stmnt -> . read_stmnt stmnt
    (43) stmnt -> . ret_stmnt stmnt
    (44) stmnt -> . func_stmnt stmnt
    (45) stmnt -> . ass_stmnt stmnt
    (128) empty -> .
    (124) while_stmnt -> . WHILE while1 LPAREN paren while2 RPAREN stmnt while3 END
    (118) if_stmnt -> . IF LPAREN paren if1 RPAREN stmnt else_stmnt END if2
    (66) write_stmnt -> . WRITE io1 LPAREN paren io2 multio RPAREN io3 SEMICLN
    (65) read_stmnt -> . READ io1 LPAREN paren multio io2 RPAREN io3 SEMICLN
    (62) ret_stmnt -> . RETURN LPAREN paren retval RPAREN rettrue SEMICLN
    (51) func_stmnt -> . ID fc1 LPAREN fc2 arg fc4 RPAREN fc5 SEMICLN
    (46) ass_stmnt -> . ID arr ASS func_stmnt SEMICLN
    (47) ass_stmnt -> . ID ass1 arr ASS ass2 paren ass3 SEMICLN
    $end            reduce using rule 128 (empty -> .)
    ELSE            reduce using rule 128 (empty -> .)
    END             reduce using rule 128 (empty -> .)
    RCURLY          reduce using rule 128 (empty -> .)
    WHILE           shift and go to state 50
    IF              shift and go to state 51
    WRITE           shift and go to state 52
    READ            shift and go to state 53
    RETURN          shift and go to state 54
    ID              shift and go to state 55

    ass_stmnt                      shift and go to state 49
    stmnt                          shift and go to state 68
    empty                          shift and go to state 42
    while_stmnt                    shift and go to state 43
    if_stmnt                       shift and go to state 44
    write_stmnt                    shift and go to state 45
    read_stmnt                     shift and go to state 46
    ret_stmnt                      shift and go to state 47
    func_stmnt                     shift and go to state 48

state 50

    (124) while_stmnt -> WHILE . while1 LPAREN paren while2 RPAREN stmnt while3 END
    (125) while1 -> .
    LPAREN          reduce using rule 125 (while1 -> .)

    while1                         shift and go to state 69

state 51

    (118) if_stmnt -> IF . LPAREN paren if1 RPAREN stmnt else_stmnt END if2
    LPAREN          shift and go to state 70


state 52

    (66) write_stmnt -> WRITE . io1 LPAREN paren io2 multio RPAREN io3 SEMICLN
    (69) io1 -> .
    LPAREN          reduce using rule 69 (io1 -> .)

    io1                            shift and go to state 71

state 53

    (65) read_stmnt -> READ . io1 LPAREN paren multio io2 RPAREN io3 SEMICLN
    (69) io1 -> .
    LPAREN          reduce using rule 69 (io1 -> .)

    io1                            shift and go to state 72

state 54

    (62) ret_stmnt -> RETURN . LPAREN paren retval RPAREN rettrue SEMICLN
    LPAREN          shift and go to state 73


state 55

    (51) func_stmnt -> ID . fc1 LPAREN fc2 arg fc4 RPAREN fc5 SEMICLN
    (46) ass_stmnt -> ID . arr ASS func_stmnt SEMICLN
    (47) ass_stmnt -> ID . ass1 arr ASS ass2 paren ass3 SEMICLN
    (53) fc1 -> .
    (18) arr -> . empty
    (19) arr -> . LSQUARE exp RSQUARE
    (48) ass1 -> .
    (128) empty -> .
  ! shift/reduce conflict for LSQUARE resolved as shift
  ! reduce/reduce conflict for ASS resolved using rule 48 (ass1 -> .)
    LPAREN          reduce using rule 53 (fc1 -> .)
    LSQUARE         shift and go to state 59
    ASS             reduce using rule 48 (ass1 -> .)

    fc1                            shift and go to state 74
    arr                            shift and go to state 75
    ass1                           shift and go to state 76
    empty                          shift and go to state 58

state 56

    (21) funcdecl -> FUNC tipofunc func1 ID func2 LPAREN . param RPAREN func3 LCURLY varsdecl func4 stmnt RCURLY resetvarcont funcdecl
    (29) param -> . empty
    (30) param -> . tipo param1 COLON ID param2 multiparam
    (128) empty -> .
    (14) tipo -> . BOOL
    (15) tipo -> . CHAR
    (16) tipo -> . FLOAT
    (17) tipo -> . INT
    RPAREN          reduce using rule 128 (empty -> .)
    BOOL            shift and go to state 19
    CHAR            shift and go to state 20
    FLOAT           shift and go to state 21
    INT             shift and go to state 22

    param                          shift and go to state 77
    empty                          shift and go to state 78
    tipo                           shift and go to state 79

state 57

    (13) multid -> COMMA ID prog5 arr . multid
    (12) multid -> . empty
    (13) multid -> . COMMA ID prog5 arr multid
    (128) empty -> .
    COMMA           shift and go to state 31
    FUNC            reduce using rule 128 (empty -> .)
    MAIN            reduce using rule 128 (empty -> .)
    WHILE           reduce using rule 128 (empty -> .)
    IF              reduce using rule 128 (empty -> .)
    WRITE           reduce using rule 128 (empty -> .)
    READ            reduce using rule 128 (empty -> .)
    RETURN          reduce using rule 128 (empty -> .)
    ID              reduce using rule 128 (empty -> .)
    RCURLY          reduce using rule 128 (empty -> .)
    SEMICLN         reduce using rule 128 (empty -> .)

    multid                         shift and go to state 80
    empty                          shift and go to state 30

state 58

    (18) arr -> empty .
    COMMA           reduce using rule 18 (arr -> empty .)
    FUNC            reduce using rule 18 (arr -> empty .)
    MAIN            reduce using rule 18 (arr -> empty .)
    WHILE           reduce using rule 18 (arr -> empty .)
    IF              reduce using rule 18 (arr -> empty .)
    WRITE           reduce using rule 18 (arr -> empty .)
    READ            reduce using rule 18 (arr -> empty .)
    RETURN          reduce using rule 18 (arr -> empty .)
    ID              reduce using rule 18 (arr -> empty .)
    RCURLY          reduce using rule 18 (arr -> empty .)
    SEMICLN         reduce using rule 18 (arr -> empty .)
    ASS             reduce using rule 18 (arr -> empty .)
    DIV             reduce using rule 18 (arr -> empty .)
    MULT            reduce using rule 18 (arr -> empty .)
    SUB             reduce using rule 18 (arr -> empty .)
    SUM             reduce using rule 18 (arr -> empty .)
    RSQUARE         reduce using rule 18 (arr -> empty .)
    EQUAL_TO        reduce using rule 18 (arr -> empty .)
    DIFFERENT_TO    reduce using rule 18 (arr -> empty .)
    LESS_OR_EQ_THAN reduce using rule 18 (arr -> empty .)
    MORE_OR_EQ_THAN reduce using rule 18 (arr -> empty .)
    LESS_THAN       reduce using rule 18 (arr -> empty .)
    MORE_THAN       reduce using rule 18 (arr -> empty .)
    OR              reduce using rule 18 (arr -> empty .)
    AND             reduce using rule 18 (arr -> empty .)
    RPAREN          reduce using rule 18 (arr -> empty .)


state 59

    (19) arr -> LSQUARE . exp RSQUARE
    (92) exp -> . term exp2 SUB exp1 exp
    (93) exp -> . term exp2 SUM exp1 exp
    (94) exp -> . term exp2
    (97) term -> . factor term2 DIV term1 term
    (98) term -> . factor term2 MULT term1 term
    (99) term -> . factor term2
    (103) factor -> . func_exp
    (104) factor -> . FALSE ctes4
    (105) factor -> . TRUE ctes4
    (106) factor -> . CTE_STR ctes3
    (107) factor -> . CTE_FLT ctes2
    (108) factor -> . CTE_NUM ctes1
    (109) factor -> . ID fact1 LPAREN logic multiexp RPAREN
    (110) factor -> . ID fact1 arr
    (52) func_exp -> . ID fc1 LPAREN fc2 arg fc4 RPAREN fc5 fexp
    FALSE           shift and go to state 85
    TRUE            shift and go to state 86
    CTE_STR         shift and go to state 87
    CTE_FLT         shift and go to state 88
    CTE_NUM         shift and go to state 89
    ID              shift and go to state 90

    exp                            shift and go to state 81
    term                           shift and go to state 82
    factor                         shift and go to state 83
    func_exp                       shift and go to state 84

state 60

    (9) multivd -> tipo prog4 COLON ID prog5 . arr multid SEMICLN multivd
    (18) arr -> . empty
    (19) arr -> . LSQUARE exp RSQUARE
    (128) empty -> .
    LSQUARE         shift and go to state 59
    COMMA           reduce using rule 128 (empty -> .)
    SEMICLN         reduce using rule 128 (empty -> .)

    arr                            shift and go to state 91
    empty                          shift and go to state 58

state 61

    (35) main -> MAIN scopemain LPAREN RPAREN stmnt maintemp .
    $end            reduce using rule 35 (main -> MAIN scopemain LPAREN RPAREN stmnt maintemp .)


state 62

    (39) stmnt -> while_stmnt stmnt .
    $end            reduce using rule 39 (stmnt -> while_stmnt stmnt .)
    ELSE            reduce using rule 39 (stmnt -> while_stmnt stmnt .)
    END             reduce using rule 39 (stmnt -> while_stmnt stmnt .)
    RCURLY          reduce using rule 39 (stmnt -> while_stmnt stmnt .)


state 63

    (40) stmnt -> if_stmnt stmnt .
    $end            reduce using rule 40 (stmnt -> if_stmnt stmnt .)
    ELSE            reduce using rule 40 (stmnt -> if_stmnt stmnt .)
    END             reduce using rule 40 (stmnt -> if_stmnt stmnt .)
    RCURLY          reduce using rule 40 (stmnt -> if_stmnt stmnt .)


state 64

    (41) stmnt -> write_stmnt stmnt .
    $end            reduce using rule 41 (stmnt -> write_stmnt stmnt .)
    ELSE            reduce using rule 41 (stmnt -> write_stmnt stmnt .)
    END             reduce using rule 41 (stmnt -> write_stmnt stmnt .)
    RCURLY          reduce using rule 41 (stmnt -> write_stmnt stmnt .)


state 65

    (42) stmnt -> read_stmnt stmnt .
    $end            reduce using rule 42 (stmnt -> read_stmnt stmnt .)
    ELSE            reduce using rule 42 (stmnt -> read_stmnt stmnt .)
    END             reduce using rule 42 (stmnt -> read_stmnt stmnt .)
    RCURLY          reduce using rule 42 (stmnt -> read_stmnt stmnt .)


state 66

    (43) stmnt -> ret_stmnt stmnt .
    $end            reduce using rule 43 (stmnt -> ret_stmnt stmnt .)
    ELSE            reduce using rule 43 (stmnt -> ret_stmnt stmnt .)
    END             reduce using rule 43 (stmnt -> ret_stmnt stmnt .)
    RCURLY          reduce using rule 43 (stmnt -> ret_stmnt stmnt .)


state 67

    (44) stmnt -> func_stmnt stmnt .
    $end            reduce using rule 44 (stmnt -> func_stmnt stmnt .)
    ELSE            reduce using rule 44 (stmnt -> func_stmnt stmnt .)
    END             reduce using rule 44 (stmnt -> func_stmnt stmnt .)
    RCURLY          reduce using rule 44 (stmnt -> func_stmnt stmnt .)


state 68

    (45) stmnt -> ass_stmnt stmnt .
    $end            reduce using rule 45 (stmnt -> ass_stmnt stmnt .)
    ELSE            reduce using rule 45 (stmnt -> ass_stmnt stmnt .)
    END             reduce using rule 45 (stmnt -> ass_stmnt stmnt .)
    RCURLY          reduce using rule 45 (stmnt -> ass_stmnt stmnt .)


state 69

    (124) while_stmnt -> WHILE while1 . LPAREN paren while2 RPAREN stmnt while3 END
    LPAREN          shift and go to state 92


state 70

    (118) if_stmnt -> IF LPAREN . paren if1 RPAREN stmnt else_stmnt END if2
    (72) paren -> . logic
    (73) paren -> . LPAREN paren1 logic paren2 RPAREN paren3 logic
    (77) logic -> . rel log2 OR log1 logic
    (78) logic -> . rel log2 AND log1 logic
    (79) logic -> . rel log2
    (88) rel -> . exp rel2 relop rel1 rel
    (89) rel -> . exp rel2
    (92) exp -> . term exp2 SUB exp1 exp
    (93) exp -> . term exp2 SUM exp1 exp
    (94) exp -> . term exp2
    (97) term -> . factor term2 DIV term1 term
    (98) term -> . factor term2 MULT term1 term
    (99) term -> . factor term2
    (103) factor -> . func_exp
    (104) factor -> . FALSE ctes4
    (105) factor -> . TRUE ctes4
    (106) factor -> . CTE_STR ctes3
    (107) factor -> . CTE_FLT ctes2
    (108) factor -> . CTE_NUM ctes1
    (109) factor -> . ID fact1 LPAREN logic multiexp RPAREN
    (110) factor -> . ID fact1 arr
    (52) func_exp -> . ID fc1 LPAREN fc2 arg fc4 RPAREN fc5 fexp
    LPAREN          shift and go to state 93
    FALSE           shift and go to state 85
    TRUE            shift and go to state 86
    CTE_STR         shift and go to state 87
    CTE_FLT         shift and go to state 88
    CTE_NUM         shift and go to state 89
    ID              shift and go to state 90

    paren                          shift and go to state 94
    logic                          shift and go to state 95
    rel                            shift and go to state 96
    exp                            shift and go to state 97
    term                           shift and go to state 82
    factor                         shift and go to state 83
    func_exp                       shift and go to state 84

state 71

    (66) write_stmnt -> WRITE io1 . LPAREN paren io2 multio RPAREN io3 SEMICLN
    LPAREN          shift and go to state 98


state 72

    (65) read_stmnt -> READ io1 . LPAREN paren multio io2 RPAREN io3 SEMICLN
    LPAREN          shift and go to state 99


state 73

    (62) ret_stmnt -> RETURN LPAREN . paren retval RPAREN rettrue SEMICLN
    (72) paren -> . logic
    (73) paren -> . LPAREN paren1 logic paren2 RPAREN paren3 logic
    (77) logic -> . rel log2 OR log1 logic
    (78) logic -> . rel log2 AND log1 logic
    (79) logic -> . rel log2
    (88) rel -> . exp rel2 relop rel1 rel
    (89) rel -> . exp rel2
    (92) exp -> . term exp2 SUB exp1 exp
    (93) exp -> . term exp2 SUM exp1 exp
    (94) exp -> . term exp2
    (97) term -> . factor term2 DIV term1 term
    (98) term -> . factor term2 MULT term1 term
    (99) term -> . factor term2
    (103) factor -> . func_exp
    (104) factor -> . FALSE ctes4
    (105) factor -> . TRUE ctes4
    (106) factor -> . CTE_STR ctes3
    (107) factor -> . CTE_FLT ctes2
    (108) factor -> . CTE_NUM ctes1
    (109) factor -> . ID fact1 LPAREN logic multiexp RPAREN
    (110) factor -> . ID fact1 arr
    (52) func_exp -> . ID fc1 LPAREN fc2 arg fc4 RPAREN fc5 fexp
    LPAREN          shift and go to state 93
    FALSE           shift and go to state 85
    TRUE            shift and go to state 86
    CTE_STR         shift and go to state 87
    CTE_FLT         shift and go to state 88
    CTE_NUM         shift and go to state 89
    ID              shift and go to state 90

    paren                          shift and go to state 100
    logic                          shift and go to state 95
    rel                            shift and go to state 96
    exp                            shift and go to state 97
    term                           shift and go to state 82
    factor                         shift and go to state 83
    func_exp                       shift and go to state 84

state 74

    (51) func_stmnt -> ID fc1 . LPAREN fc2 arg fc4 RPAREN fc5 SEMICLN
    LPAREN          shift and go to state 101


state 75

    (46) ass_stmnt -> ID arr . ASS func_stmnt SEMICLN
    ASS             shift and go to state 102


state 76

    (47) ass_stmnt -> ID ass1 . arr ASS ass2 paren ass3 SEMICLN
    (18) arr -> . empty
    (19) arr -> . LSQUARE exp RSQUARE
    (128) empty -> .
    LSQUARE         shift and go to state 59
    ASS             reduce using rule 128 (empty -> .)

    arr                            shift and go to state 103
    empty                          shift and go to state 58

state 77

    (21) funcdecl -> FUNC tipofunc func1 ID func2 LPAREN param . RPAREN func3 LCURLY varsdecl func4 stmnt RCURLY resetvarcont funcdecl
    RPAREN          shift and go to state 104


state 78

    (29) param -> empty .
    RPAREN          reduce using rule 29 (param -> empty .)


state 79

    (30) param -> tipo . param1 COLON ID param2 multiparam
    (31) param1 -> .
    COLON           reduce using rule 31 (param1 -> .)

    param1                         shift and go to state 105

state 80

    (13) multid -> COMMA ID prog5 arr multid .
    FUNC            reduce using rule 13 (multid -> COMMA ID prog5 arr multid .)
    MAIN            reduce using rule 13 (multid -> COMMA ID prog5 arr multid .)
    WHILE           reduce using rule 13 (multid -> COMMA ID prog5 arr multid .)
    IF              reduce using rule 13 (multid -> COMMA ID prog5 arr multid .)
    WRITE           reduce using rule 13 (multid -> COMMA ID prog5 arr multid .)
    READ            reduce using rule 13 (multid -> COMMA ID prog5 arr multid .)
    RETURN          reduce using rule 13 (multid -> COMMA ID prog5 arr multid .)
    ID              reduce using rule 13 (multid -> COMMA ID prog5 arr multid .)
    RCURLY          reduce using rule 13 (multid -> COMMA ID prog5 arr multid .)
    SEMICLN         reduce using rule 13 (multid -> COMMA ID prog5 arr multid .)


state 81

    (19) arr -> LSQUARE exp . RSQUARE
    RSQUARE         shift and go to state 106


state 82

    (92) exp -> term . exp2 SUB exp1 exp
    (93) exp -> term . exp2 SUM exp1 exp
    (94) exp -> term . exp2
    (95) exp2 -> .
    SUB             reduce using rule 95 (exp2 -> .)
    SUM             reduce using rule 95 (exp2 -> .)
    RSQUARE         reduce using rule 95 (exp2 -> .)
    EQUAL_TO        reduce using rule 95 (exp2 -> .)
    DIFFERENT_TO    reduce using rule 95 (exp2 -> .)
    LESS_OR_EQ_THAN reduce using rule 95 (exp2 -> .)
    MORE_OR_EQ_THAN reduce using rule 95 (exp2 -> .)
    LESS_THAN       reduce using rule 95 (exp2 -> .)
    MORE_THAN       reduce using rule 95 (exp2 -> .)
    OR              reduce using rule 95 (exp2 -> .)
    AND             reduce using rule 95 (exp2 -> .)
    RPAREN          reduce using rule 95 (exp2 -> .)
    COMMA           reduce using rule 95 (exp2 -> .)
    SEMICLN         reduce using rule 95 (exp2 -> .)

    exp2                           shift and go to state 107

state 83

    (97) term -> factor . term2 DIV term1 term
    (98) term -> factor . term2 MULT term1 term
    (99) term -> factor . term2
    (101) term2 -> .
    DIV             reduce using rule 101 (term2 -> .)
    MULT            reduce using rule 101 (term2 -> .)
    SUB             reduce using rule 101 (term2 -> .)
    SUM             reduce using rule 101 (term2 -> .)
    RSQUARE         reduce using rule 101 (term2 -> .)
    EQUAL_TO        reduce using rule 101 (term2 -> .)
    DIFFERENT_TO    reduce using rule 101 (term2 -> .)
    LESS_OR_EQ_THAN reduce using rule 101 (term2 -> .)
    MORE_OR_EQ_THAN reduce using rule 101 (term2 -> .)
    LESS_THAN       reduce using rule 101 (term2 -> .)
    MORE_THAN       reduce using rule 101 (term2 -> .)
    OR              reduce using rule 101 (term2 -> .)
    AND             reduce using rule 101 (term2 -> .)
    RPAREN          reduce using rule 101 (term2 -> .)
    COMMA           reduce using rule 101 (term2 -> .)
    SEMICLN         reduce using rule 101 (term2 -> .)

    term2                          shift and go to state 108

state 84

    (103) factor -> func_exp .
    DIV             reduce using rule 103 (factor -> func_exp .)
    MULT            reduce using rule 103 (factor -> func_exp .)
    SUB             reduce using rule 103 (factor -> func_exp .)
    SUM             reduce using rule 103 (factor -> func_exp .)
    RSQUARE         reduce using rule 103 (factor -> func_exp .)
    EQUAL_TO        reduce using rule 103 (factor -> func_exp .)
    DIFFERENT_TO    reduce using rule 103 (factor -> func_exp .)
    LESS_OR_EQ_THAN reduce using rule 103 (factor -> func_exp .)
    MORE_OR_EQ_THAN reduce using rule 103 (factor -> func_exp .)
    LESS_THAN       reduce using rule 103 (factor -> func_exp .)
    MORE_THAN       reduce using rule 103 (factor -> func_exp .)
    OR              reduce using rule 103 (factor -> func_exp .)
    AND             reduce using rule 103 (factor -> func_exp .)
    RPAREN          reduce using rule 103 (factor -> func_exp .)
    COMMA           reduce using rule 103 (factor -> func_exp .)
    SEMICLN         reduce using rule 103 (factor -> func_exp .)


state 85

    (104) factor -> FALSE . ctes4
    (114) ctes4 -> .
    DIV             reduce using rule 114 (ctes4 -> .)
    MULT            reduce using rule 114 (ctes4 -> .)
    SUB             reduce using rule 114 (ctes4 -> .)
    SUM             reduce using rule 114 (ctes4 -> .)
    RSQUARE         reduce using rule 114 (ctes4 -> .)
    EQUAL_TO        reduce using rule 114 (ctes4 -> .)
    DIFFERENT_TO    reduce using rule 114 (ctes4 -> .)
    LESS_OR_EQ_THAN reduce using rule 114 (ctes4 -> .)
    MORE_OR_EQ_THAN reduce using rule 114 (ctes4 -> .)
    LESS_THAN       reduce using rule 114 (ctes4 -> .)
    MORE_THAN       reduce using rule 114 (ctes4 -> .)
    OR              reduce using rule 114 (ctes4 -> .)
    AND             reduce using rule 114 (ctes4 -> .)
    RPAREN          reduce using rule 114 (ctes4 -> .)
    COMMA           reduce using rule 114 (ctes4 -> .)
    SEMICLN         reduce using rule 114 (ctes4 -> .)

    ctes4                          shift and go to state 109

state 86

    (105) factor -> TRUE . ctes4
    (114) ctes4 -> .
    DIV             reduce using rule 114 (ctes4 -> .)
    MULT            reduce using rule 114 (ctes4 -> .)
    SUB             reduce using rule 114 (ctes4 -> .)
    SUM             reduce using rule 114 (ctes4 -> .)
    RSQUARE         reduce using rule 114 (ctes4 -> .)
    EQUAL_TO        reduce using rule 114 (ctes4 -> .)
    DIFFERENT_TO    reduce using rule 114 (ctes4 -> .)
    LESS_OR_EQ_THAN reduce using rule 114 (ctes4 -> .)
    MORE_OR_EQ_THAN reduce using rule 114 (ctes4 -> .)
    LESS_THAN       reduce using rule 114 (ctes4 -> .)
    MORE_THAN       reduce using rule 114 (ctes4 -> .)
    OR              reduce using rule 114 (ctes4 -> .)
    AND             reduce using rule 114 (ctes4 -> .)
    RPAREN          reduce using rule 114 (ctes4 -> .)
    COMMA           reduce using rule 114 (ctes4 -> .)
    SEMICLN         reduce using rule 114 (ctes4 -> .)

    ctes4                          shift and go to state 110

state 87

    (106) factor -> CTE_STR . ctes3
    (113) ctes3 -> .
    DIV             reduce using rule 113 (ctes3 -> .)
    MULT            reduce using rule 113 (ctes3 -> .)
    SUB             reduce using rule 113 (ctes3 -> .)
    SUM             reduce using rule 113 (ctes3 -> .)
    RSQUARE         reduce using rule 113 (ctes3 -> .)
    EQUAL_TO        reduce using rule 113 (ctes3 -> .)
    DIFFERENT_TO    reduce using rule 113 (ctes3 -> .)
    LESS_OR_EQ_THAN reduce using rule 113 (ctes3 -> .)
    MORE_OR_EQ_THAN reduce using rule 113 (ctes3 -> .)
    LESS_THAN       reduce using rule 113 (ctes3 -> .)
    MORE_THAN       reduce using rule 113 (ctes3 -> .)
    OR              reduce using rule 113 (ctes3 -> .)
    AND             reduce using rule 113 (ctes3 -> .)
    RPAREN          reduce using rule 113 (ctes3 -> .)
    COMMA           reduce using rule 113 (ctes3 -> .)
    SEMICLN         reduce using rule 113 (ctes3 -> .)

    ctes3                          shift and go to state 111

state 88

    (107) factor -> CTE_FLT . ctes2
    (112) ctes2 -> .
    DIV             reduce using rule 112 (ctes2 -> .)
    MULT            reduce using rule 112 (ctes2 -> .)
    SUB             reduce using rule 112 (ctes2 -> .)
    SUM             reduce using rule 112 (ctes2 -> .)
    RSQUARE         reduce using rule 112 (ctes2 -> .)
    EQUAL_TO        reduce using rule 112 (ctes2 -> .)
    DIFFERENT_TO    reduce using rule 112 (ctes2 -> .)
    LESS_OR_EQ_THAN reduce using rule 112 (ctes2 -> .)
    MORE_OR_EQ_THAN reduce using rule 112 (ctes2 -> .)
    LESS_THAN       reduce using rule 112 (ctes2 -> .)
    MORE_THAN       reduce using rule 112 (ctes2 -> .)
    OR              reduce using rule 112 (ctes2 -> .)
    AND             reduce using rule 112 (ctes2 -> .)
    RPAREN          reduce using rule 112 (ctes2 -> .)
    COMMA           reduce using rule 112 (ctes2 -> .)
    SEMICLN         reduce using rule 112 (ctes2 -> .)

    ctes2                          shift and go to state 112

state 89

    (108) factor -> CTE_NUM . ctes1
    (111) ctes1 -> .
    DIV             reduce using rule 111 (ctes1 -> .)
    MULT            reduce using rule 111 (ctes1 -> .)
    SUB             reduce using rule 111 (ctes1 -> .)
    SUM             reduce using rule 111 (ctes1 -> .)
    RSQUARE         reduce using rule 111 (ctes1 -> .)
    EQUAL_TO        reduce using rule 111 (ctes1 -> .)
    DIFFERENT_TO    reduce using rule 111 (ctes1 -> .)
    LESS_OR_EQ_THAN reduce using rule 111 (ctes1 -> .)
    MORE_OR_EQ_THAN reduce using rule 111 (ctes1 -> .)
    LESS_THAN       reduce using rule 111 (ctes1 -> .)
    MORE_THAN       reduce using rule 111 (ctes1 -> .)
    OR              reduce using rule 111 (ctes1 -> .)
    AND             reduce using rule 111 (ctes1 -> .)
    RPAREN          reduce using rule 111 (ctes1 -> .)
    COMMA           reduce using rule 111 (ctes1 -> .)
    SEMICLN         reduce using rule 111 (ctes1 -> .)

    ctes1                          shift and go to state 113

state 90

    (109) factor -> ID . fact1 LPAREN logic multiexp RPAREN
    (110) factor -> ID . fact1 arr
    (52) func_exp -> ID . fc1 LPAREN fc2 arg fc4 RPAREN fc5 fexp
    (115) fact1 -> .
    (53) fc1 -> .
  ! reduce/reduce conflict for LPAREN resolved using rule 53 (fc1 -> .)
    LSQUARE         reduce using rule 115 (fact1 -> .)
    DIV             reduce using rule 115 (fact1 -> .)
    MULT            reduce using rule 115 (fact1 -> .)
    SUB             reduce using rule 115 (fact1 -> .)
    SUM             reduce using rule 115 (fact1 -> .)
    RSQUARE         reduce using rule 115 (fact1 -> .)
    EQUAL_TO        reduce using rule 115 (fact1 -> .)
    DIFFERENT_TO    reduce using rule 115 (fact1 -> .)
    LESS_OR_EQ_THAN reduce using rule 115 (fact1 -> .)
    MORE_OR_EQ_THAN reduce using rule 115 (fact1 -> .)
    LESS_THAN       reduce using rule 115 (fact1 -> .)
    MORE_THAN       reduce using rule 115 (fact1 -> .)
    OR              reduce using rule 115 (fact1 -> .)
    AND             reduce using rule 115 (fact1 -> .)
    RPAREN          reduce using rule 115 (fact1 -> .)
    COMMA           reduce using rule 115 (fact1 -> .)
    SEMICLN         reduce using rule 115 (fact1 -> .)
    LPAREN          reduce using rule 53 (fc1 -> .)

    fact1                          shift and go to state 114
    fc1                            shift and go to state 115

state 91

    (9) multivd -> tipo prog4 COLON ID prog5 arr . multid SEMICLN multivd
    (12) multid -> . empty
    (13) multid -> . COMMA ID prog5 arr multid
    (128) empty -> .
    COMMA           shift and go to state 31
    SEMICLN         reduce using rule 128 (empty -> .)

    multid                         shift and go to state 116
    empty                          shift and go to state 30

state 92

    (124) while_stmnt -> WHILE while1 LPAREN . paren while2 RPAREN stmnt while3 END
    (72) paren -> . logic
    (73) paren -> . LPAREN paren1 logic paren2 RPAREN paren3 logic
    (77) logic -> . rel log2 OR log1 logic
    (78) logic -> . rel log2 AND log1 logic
    (79) logic -> . rel log2
    (88) rel -> . exp rel2 relop rel1 rel
    (89) rel -> . exp rel2
    (92) exp -> . term exp2 SUB exp1 exp
    (93) exp -> . term exp2 SUM exp1 exp
    (94) exp -> . term exp2
    (97) term -> . factor term2 DIV term1 term
    (98) term -> . factor term2 MULT term1 term
    (99) term -> . factor term2
    (103) factor -> . func_exp
    (104) factor -> . FALSE ctes4
    (105) factor -> . TRUE ctes4
    (106) factor -> . CTE_STR ctes3
    (107) factor -> . CTE_FLT ctes2
    (108) factor -> . CTE_NUM ctes1
    (109) factor -> . ID fact1 LPAREN logic multiexp RPAREN
    (110) factor -> . ID fact1 arr
    (52) func_exp -> . ID fc1 LPAREN fc2 arg fc4 RPAREN fc5 fexp
    LPAREN          shift and go to state 93
    FALSE           shift and go to state 85
    TRUE            shift and go to state 86
    CTE_STR         shift and go to state 87
    CTE_FLT         shift and go to state 88
    CTE_NUM         shift and go to state 89
    ID              shift and go to state 90

    paren                          shift and go to state 117
    logic                          shift and go to state 95
    rel                            shift and go to state 96
    exp                            shift and go to state 97
    term                           shift and go to state 82
    factor                         shift and go to state 83
    func_exp                       shift and go to state 84

state 93

    (73) paren -> LPAREN . paren1 logic paren2 RPAREN paren3 logic
    (74) paren1 -> .
    FALSE           reduce using rule 74 (paren1 -> .)
    TRUE            reduce using rule 74 (paren1 -> .)
    CTE_STR         reduce using rule 74 (paren1 -> .)
    CTE_FLT         reduce using rule 74 (paren1 -> .)
    CTE_NUM         reduce using rule 74 (paren1 -> .)
    ID              reduce using rule 74 (paren1 -> .)

    paren1                         shift and go to state 118

state 94

    (118) if_stmnt -> IF LPAREN paren . if1 RPAREN stmnt else_stmnt END if2
    (119) if1 -> .
    RPAREN          reduce using rule 119 (if1 -> .)

    if1                            shift and go to state 119

state 95

    (72) paren -> logic .
    RPAREN          reduce using rule 72 (paren -> logic .)
    COMMA           reduce using rule 72 (paren -> logic .)
    SEMICLN         reduce using rule 72 (paren -> logic .)


state 96

    (77) logic -> rel . log2 OR log1 logic
    (78) logic -> rel . log2 AND log1 logic
    (79) logic -> rel . log2
    (81) log2 -> .
    OR              reduce using rule 81 (log2 -> .)
    AND             reduce using rule 81 (log2 -> .)
    RPAREN          reduce using rule 81 (log2 -> .)
    COMMA           reduce using rule 81 (log2 -> .)
    SEMICLN         reduce using rule 81 (log2 -> .)

    log2                           shift and go to state 120

state 97

    (88) rel -> exp . rel2 relop rel1 rel
    (89) rel -> exp . rel2
    (91) rel2 -> .
    EQUAL_TO        reduce using rule 91 (rel2 -> .)
    DIFFERENT_TO    reduce using rule 91 (rel2 -> .)
    LESS_OR_EQ_THAN reduce using rule 91 (rel2 -> .)
    MORE_OR_EQ_THAN reduce using rule 91 (rel2 -> .)
    LESS_THAN       reduce using rule 91 (rel2 -> .)
    MORE_THAN       reduce using rule 91 (rel2 -> .)
    OR              reduce using rule 91 (rel2 -> .)
    AND             reduce using rule 91 (rel2 -> .)
    RPAREN          reduce using rule 91 (rel2 -> .)
    COMMA           reduce using rule 91 (rel2 -> .)
    SEMICLN         reduce using rule 91 (rel2 -> .)

    rel2                           shift and go to state 121

state 98

    (66) write_stmnt -> WRITE io1 LPAREN . paren io2 multio RPAREN io3 SEMICLN
    (72) paren -> . logic
    (73) paren -> . LPAREN paren1 logic paren2 RPAREN paren3 logic
    (77) logic -> . rel log2 OR log1 logic
    (78) logic -> . rel log2 AND log1 logic
    (79) logic -> . rel log2
    (88) rel -> . exp rel2 relop rel1 rel
    (89) rel -> . exp rel2
    (92) exp -> . term exp2 SUB exp1 exp
    (93) exp -> . term exp2 SUM exp1 exp
    (94) exp -> . term exp2
    (97) term -> . factor term2 DIV term1 term
    (98) term -> . factor term2 MULT term1 term
    (99) term -> . factor term2
    (103) factor -> . func_exp
    (104) factor -> . FALSE ctes4
    (105) factor -> . TRUE ctes4
    (106) factor -> . CTE_STR ctes3
    (107) factor -> . CTE_FLT ctes2
    (108) factor -> . CTE_NUM ctes1
    (109) factor -> . ID fact1 LPAREN logic multiexp RPAREN
    (110) factor -> . ID fact1 arr
    (52) func_exp -> . ID fc1 LPAREN fc2 arg fc4 RPAREN fc5 fexp
    LPAREN          shift and go to state 93
    FALSE           shift and go to state 85
    TRUE            shift and go to state 86
    CTE_STR         shift and go to state 87
    CTE_FLT         shift and go to state 88
    CTE_NUM         shift and go to state 89
    ID              shift and go to state 90

    paren                          shift and go to state 122
    logic                          shift and go to state 95
    rel                            shift and go to state 96
    exp                            shift and go to state 97
    term                           shift and go to state 82
    factor                         shift and go to state 83
    func_exp                       shift and go to state 84

state 99

    (65) read_stmnt -> READ io1 LPAREN . paren multio io2 RPAREN io3 SEMICLN
    (72) paren -> . logic
    (73) paren -> . LPAREN paren1 logic paren2 RPAREN paren3 logic
    (77) logic -> . rel log2 OR log1 logic
    (78) logic -> . rel log2 AND log1 logic
    (79) logic -> . rel log2
    (88) rel -> . exp rel2 relop rel1 rel
    (89) rel -> . exp rel2
    (92) exp -> . term exp2 SUB exp1 exp
    (93) exp -> . term exp2 SUM exp1 exp
    (94) exp -> . term exp2
    (97) term -> . factor term2 DIV term1 term
    (98) term -> . factor term2 MULT term1 term
    (99) term -> . factor term2
    (103) factor -> . func_exp
    (104) factor -> . FALSE ctes4
    (105) factor -> . TRUE ctes4
    (106) factor -> . CTE_STR ctes3
    (107) factor -> . CTE_FLT ctes2
    (108) factor -> . CTE_NUM ctes1
    (109) factor -> . ID fact1 LPAREN logic multiexp RPAREN
    (110) factor -> . ID fact1 arr
    (52) func_exp -> . ID fc1 LPAREN fc2 arg fc4 RPAREN fc5 fexp
    LPAREN          shift and go to state 93
    FALSE           shift and go to state 85
    TRUE            shift and go to state 86
    CTE_STR         shift and go to state 87
    CTE_FLT         shift and go to state 88
    CTE_NUM         shift and go to state 89
    ID              shift and go to state 90

    paren                          shift and go to state 123
    logic                          shift and go to state 95
    rel                            shift and go to state 96
    exp                            shift and go to state 97
    term                           shift and go to state 82
    factor                         shift and go to state 83
    func_exp                       shift and go to state 84

state 100

    (62) ret_stmnt -> RETURN LPAREN paren . retval RPAREN rettrue SEMICLN
    (64) retval -> .
    RPAREN          reduce using rule 64 (retval -> .)

    retval                         shift and go to state 124

state 101

    (51) func_stmnt -> ID fc1 LPAREN . fc2 arg fc4 RPAREN fc5 SEMICLN
    (54) fc2 -> .
    LPAREN          reduce using rule 54 (fc2 -> .)
    FALSE           reduce using rule 54 (fc2 -> .)
    TRUE            reduce using rule 54 (fc2 -> .)
    CTE_STR         reduce using rule 54 (fc2 -> .)
    CTE_FLT         reduce using rule 54 (fc2 -> .)
    CTE_NUM         reduce using rule 54 (fc2 -> .)
    ID              reduce using rule 54 (fc2 -> .)
    RPAREN          reduce using rule 54 (fc2 -> .)

    fc2                            shift and go to state 125

state 102

    (46) ass_stmnt -> ID arr ASS . func_stmnt SEMICLN
    (51) func_stmnt -> . ID fc1 LPAREN fc2 arg fc4 RPAREN fc5 SEMICLN
    ID              shift and go to state 126

    func_stmnt                     shift and go to state 127

state 103

    (47) ass_stmnt -> ID ass1 arr . ASS ass2 paren ass3 SEMICLN
    ASS             shift and go to state 128


state 104

    (21) funcdecl -> FUNC tipofunc func1 ID func2 LPAREN param RPAREN . func3 LCURLY varsdecl func4 stmnt RCURLY resetvarcont funcdecl
    (24) func3 -> .
    LCURLY          reduce using rule 24 (func3 -> .)

    func3                          shift and go to state 129

state 105

    (30) param -> tipo param1 . COLON ID param2 multiparam
    COLON           shift and go to state 130


state 106

    (19) arr -> LSQUARE exp RSQUARE .
    COMMA           reduce using rule 19 (arr -> LSQUARE exp RSQUARE .)
    FUNC            reduce using rule 19 (arr -> LSQUARE exp RSQUARE .)
    MAIN            reduce using rule 19 (arr -> LSQUARE exp RSQUARE .)
    WHILE           reduce using rule 19 (arr -> LSQUARE exp RSQUARE .)
    IF              reduce using rule 19 (arr -> LSQUARE exp RSQUARE .)
    WRITE           reduce using rule 19 (arr -> LSQUARE exp RSQUARE .)
    READ            reduce using rule 19 (arr -> LSQUARE exp RSQUARE .)
    RETURN          reduce using rule 19 (arr -> LSQUARE exp RSQUARE .)
    ID              reduce using rule 19 (arr -> LSQUARE exp RSQUARE .)
    RCURLY          reduce using rule 19 (arr -> LSQUARE exp RSQUARE .)
    SEMICLN         reduce using rule 19 (arr -> LSQUARE exp RSQUARE .)
    ASS             reduce using rule 19 (arr -> LSQUARE exp RSQUARE .)
    DIV             reduce using rule 19 (arr -> LSQUARE exp RSQUARE .)
    MULT            reduce using rule 19 (arr -> LSQUARE exp RSQUARE .)
    SUB             reduce using rule 19 (arr -> LSQUARE exp RSQUARE .)
    SUM             reduce using rule 19 (arr -> LSQUARE exp RSQUARE .)
    RSQUARE         reduce using rule 19 (arr -> LSQUARE exp RSQUARE .)
    EQUAL_TO        reduce using rule 19 (arr -> LSQUARE exp RSQUARE .)
    DIFFERENT_TO    reduce using rule 19 (arr -> LSQUARE exp RSQUARE .)
    LESS_OR_EQ_THAN reduce using rule 19 (arr -> LSQUARE exp RSQUARE .)
    MORE_OR_EQ_THAN reduce using rule 19 (arr -> LSQUARE exp RSQUARE .)
    LESS_THAN       reduce using rule 19 (arr -> LSQUARE exp RSQUARE .)
    MORE_THAN       reduce using rule 19 (arr -> LSQUARE exp RSQUARE .)
    OR              reduce using rule 19 (arr -> LSQUARE exp RSQUARE .)
    AND             reduce using rule 19 (arr -> LSQUARE exp RSQUARE .)
    RPAREN          reduce using rule 19 (arr -> LSQUARE exp RSQUARE .)


state 107

    (92) exp -> term exp2 . SUB exp1 exp
    (93) exp -> term exp2 . SUM exp1 exp
    (94) exp -> term exp2 .
    SUB             shift and go to state 131
    SUM             shift and go to state 132
    RSQUARE         reduce using rule 94 (exp -> term exp2 .)
    EQUAL_TO        reduce using rule 94 (exp -> term exp2 .)
    DIFFERENT_TO    reduce using rule 94 (exp -> term exp2 .)
    LESS_OR_EQ_THAN reduce using rule 94 (exp -> term exp2 .)
    MORE_OR_EQ_THAN reduce using rule 94 (exp -> term exp2 .)
    LESS_THAN       reduce using rule 94 (exp -> term exp2 .)
    MORE_THAN       reduce using rule 94 (exp -> term exp2 .)
    OR              reduce using rule 94 (exp -> term exp2 .)
    AND             reduce using rule 94 (exp -> term exp2 .)
    RPAREN          reduce using rule 94 (exp -> term exp2 .)
    COMMA           reduce using rule 94 (exp -> term exp2 .)
    SEMICLN         reduce using rule 94 (exp -> term exp2 .)


state 108

    (97) term -> factor term2 . DIV term1 term
    (98) term -> factor term2 . MULT term1 term
    (99) term -> factor term2 .
    DIV             shift and go to state 133
    MULT            shift and go to state 134
    SUB             reduce using rule 99 (term -> factor term2 .)
    SUM             reduce using rule 99 (term -> factor term2 .)
    RSQUARE         reduce using rule 99 (term -> factor term2 .)
    EQUAL_TO        reduce using rule 99 (term -> factor term2 .)
    DIFFERENT_TO    reduce using rule 99 (term -> factor term2 .)
    LESS_OR_EQ_THAN reduce using rule 99 (term -> factor term2 .)
    MORE_OR_EQ_THAN reduce using rule 99 (term -> factor term2 .)
    LESS_THAN       reduce using rule 99 (term -> factor term2 .)
    MORE_THAN       reduce using rule 99 (term -> factor term2 .)
    OR              reduce using rule 99 (term -> factor term2 .)
    AND             reduce using rule 99 (term -> factor term2 .)
    RPAREN          reduce using rule 99 (term -> factor term2 .)
    COMMA           reduce using rule 99 (term -> factor term2 .)
    SEMICLN         reduce using rule 99 (term -> factor term2 .)


state 109

    (104) factor -> FALSE ctes4 .
    DIV             reduce using rule 104 (factor -> FALSE ctes4 .)
    MULT            reduce using rule 104 (factor -> FALSE ctes4 .)
    SUB             reduce using rule 104 (factor -> FALSE ctes4 .)
    SUM             reduce using rule 104 (factor -> FALSE ctes4 .)
    RSQUARE         reduce using rule 104 (factor -> FALSE ctes4 .)
    EQUAL_TO        reduce using rule 104 (factor -> FALSE ctes4 .)
    DIFFERENT_TO    reduce using rule 104 (factor -> FALSE ctes4 .)
    LESS_OR_EQ_THAN reduce using rule 104 (factor -> FALSE ctes4 .)
    MORE_OR_EQ_THAN reduce using rule 104 (factor -> FALSE ctes4 .)
    LESS_THAN       reduce using rule 104 (factor -> FALSE ctes4 .)
    MORE_THAN       reduce using rule 104 (factor -> FALSE ctes4 .)
    OR              reduce using rule 104 (factor -> FALSE ctes4 .)
    AND             reduce using rule 104 (factor -> FALSE ctes4 .)
    RPAREN          reduce using rule 104 (factor -> FALSE ctes4 .)
    COMMA           reduce using rule 104 (factor -> FALSE ctes4 .)
    SEMICLN         reduce using rule 104 (factor -> FALSE ctes4 .)


state 110

    (105) factor -> TRUE ctes4 .
    DIV             reduce using rule 105 (factor -> TRUE ctes4 .)
    MULT            reduce using rule 105 (factor -> TRUE ctes4 .)
    SUB             reduce using rule 105 (factor -> TRUE ctes4 .)
    SUM             reduce using rule 105 (factor -> TRUE ctes4 .)
    RSQUARE         reduce using rule 105 (factor -> TRUE ctes4 .)
    EQUAL_TO        reduce using rule 105 (factor -> TRUE ctes4 .)
    DIFFERENT_TO    reduce using rule 105 (factor -> TRUE ctes4 .)
    LESS_OR_EQ_THAN reduce using rule 105 (factor -> TRUE ctes4 .)
    MORE_OR_EQ_THAN reduce using rule 105 (factor -> TRUE ctes4 .)
    LESS_THAN       reduce using rule 105 (factor -> TRUE ctes4 .)
    MORE_THAN       reduce using rule 105 (factor -> TRUE ctes4 .)
    OR              reduce using rule 105 (factor -> TRUE ctes4 .)
    AND             reduce using rule 105 (factor -> TRUE ctes4 .)
    RPAREN          reduce using rule 105 (factor -> TRUE ctes4 .)
    COMMA           reduce using rule 105 (factor -> TRUE ctes4 .)
    SEMICLN         reduce using rule 105 (factor -> TRUE ctes4 .)


state 111

    (106) factor -> CTE_STR ctes3 .
    DIV             reduce using rule 106 (factor -> CTE_STR ctes3 .)
    MULT            reduce using rule 106 (factor -> CTE_STR ctes3 .)
    SUB             reduce using rule 106 (factor -> CTE_STR ctes3 .)
    SUM             reduce using rule 106 (factor -> CTE_STR ctes3 .)
    RSQUARE         reduce using rule 106 (factor -> CTE_STR ctes3 .)
    EQUAL_TO        reduce using rule 106 (factor -> CTE_STR ctes3 .)
    DIFFERENT_TO    reduce using rule 106 (factor -> CTE_STR ctes3 .)
    LESS_OR_EQ_THAN reduce using rule 106 (factor -> CTE_STR ctes3 .)
    MORE_OR_EQ_THAN reduce using rule 106 (factor -> CTE_STR ctes3 .)
    LESS_THAN       reduce using rule 106 (factor -> CTE_STR ctes3 .)
    MORE_THAN       reduce using rule 106 (factor -> CTE_STR ctes3 .)
    OR              reduce using rule 106 (factor -> CTE_STR ctes3 .)
    AND             reduce using rule 106 (factor -> CTE_STR ctes3 .)
    RPAREN          reduce using rule 106 (factor -> CTE_STR ctes3 .)
    COMMA           reduce using rule 106 (factor -> CTE_STR ctes3 .)
    SEMICLN         reduce using rule 106 (factor -> CTE_STR ctes3 .)


state 112

    (107) factor -> CTE_FLT ctes2 .
    DIV             reduce using rule 107 (factor -> CTE_FLT ctes2 .)
    MULT            reduce using rule 107 (factor -> CTE_FLT ctes2 .)
    SUB             reduce using rule 107 (factor -> CTE_FLT ctes2 .)
    SUM             reduce using rule 107 (factor -> CTE_FLT ctes2 .)
    RSQUARE         reduce using rule 107 (factor -> CTE_FLT ctes2 .)
    EQUAL_TO        reduce using rule 107 (factor -> CTE_FLT ctes2 .)
    DIFFERENT_TO    reduce using rule 107 (factor -> CTE_FLT ctes2 .)
    LESS_OR_EQ_THAN reduce using rule 107 (factor -> CTE_FLT ctes2 .)
    MORE_OR_EQ_THAN reduce using rule 107 (factor -> CTE_FLT ctes2 .)
    LESS_THAN       reduce using rule 107 (factor -> CTE_FLT ctes2 .)
    MORE_THAN       reduce using rule 107 (factor -> CTE_FLT ctes2 .)
    OR              reduce using rule 107 (factor -> CTE_FLT ctes2 .)
    AND             reduce using rule 107 (factor -> CTE_FLT ctes2 .)
    RPAREN          reduce using rule 107 (factor -> CTE_FLT ctes2 .)
    COMMA           reduce using rule 107 (factor -> CTE_FLT ctes2 .)
    SEMICLN         reduce using rule 107 (factor -> CTE_FLT ctes2 .)


state 113

    (108) factor -> CTE_NUM ctes1 .
    DIV             reduce using rule 108 (factor -> CTE_NUM ctes1 .)
    MULT            reduce using rule 108 (factor -> CTE_NUM ctes1 .)
    SUB             reduce using rule 108 (factor -> CTE_NUM ctes1 .)
    SUM             reduce using rule 108 (factor -> CTE_NUM ctes1 .)
    RSQUARE         reduce using rule 108 (factor -> CTE_NUM ctes1 .)
    EQUAL_TO        reduce using rule 108 (factor -> CTE_NUM ctes1 .)
    DIFFERENT_TO    reduce using rule 108 (factor -> CTE_NUM ctes1 .)
    LESS_OR_EQ_THAN reduce using rule 108 (factor -> CTE_NUM ctes1 .)
    MORE_OR_EQ_THAN reduce using rule 108 (factor -> CTE_NUM ctes1 .)
    LESS_THAN       reduce using rule 108 (factor -> CTE_NUM ctes1 .)
    MORE_THAN       reduce using rule 108 (factor -> CTE_NUM ctes1 .)
    OR              reduce using rule 108 (factor -> CTE_NUM ctes1 .)
    AND             reduce using rule 108 (factor -> CTE_NUM ctes1 .)
    RPAREN          reduce using rule 108 (factor -> CTE_NUM ctes1 .)
    COMMA           reduce using rule 108 (factor -> CTE_NUM ctes1 .)
    SEMICLN         reduce using rule 108 (factor -> CTE_NUM ctes1 .)


state 114

    (109) factor -> ID fact1 . LPAREN logic multiexp RPAREN
    (110) factor -> ID fact1 . arr
    (18) arr -> . empty
    (19) arr -> . LSQUARE exp RSQUARE
    (128) empty -> .
    LPAREN          shift and go to state 135
    LSQUARE         shift and go to state 59
    DIV             reduce using rule 128 (empty -> .)
    MULT            reduce using rule 128 (empty -> .)
    SUB             reduce using rule 128 (empty -> .)
    SUM             reduce using rule 128 (empty -> .)
    RSQUARE         reduce using rule 128 (empty -> .)
    EQUAL_TO        reduce using rule 128 (empty -> .)
    DIFFERENT_TO    reduce using rule 128 (empty -> .)
    LESS_OR_EQ_THAN reduce using rule 128 (empty -> .)
    MORE_OR_EQ_THAN reduce using rule 128 (empty -> .)
    LESS_THAN       reduce using rule 128 (empty -> .)
    MORE_THAN       reduce using rule 128 (empty -> .)
    OR              reduce using rule 128 (empty -> .)
    AND             reduce using rule 128 (empty -> .)
    RPAREN          reduce using rule 128 (empty -> .)
    COMMA           reduce using rule 128 (empty -> .)
    SEMICLN         reduce using rule 128 (empty -> .)

    arr                            shift and go to state 136
    empty                          shift and go to state 58

state 115

    (52) func_exp -> ID fc1 . LPAREN fc2 arg fc4 RPAREN fc5 fexp
    LPAREN          shift and go to state 137


state 116

    (9) multivd -> tipo prog4 COLON ID prog5 arr multid . SEMICLN multivd
    SEMICLN         shift and go to state 138


state 117

    (124) while_stmnt -> WHILE while1 LPAREN paren . while2 RPAREN stmnt while3 END
    (126) while2 -> .
    RPAREN          reduce using rule 126 (while2 -> .)

    while2                         shift and go to state 139

state 118

    (73) paren -> LPAREN paren1 . logic paren2 RPAREN paren3 logic
    (77) logic -> . rel log2 OR log1 logic
    (78) logic -> . rel log2 AND log1 logic
    (79) logic -> . rel log2
    (88) rel -> . exp rel2 relop rel1 rel
    (89) rel -> . exp rel2
    (92) exp -> . term exp2 SUB exp1 exp
    (93) exp -> . term exp2 SUM exp1 exp
    (94) exp -> . term exp2
    (97) term -> . factor term2 DIV term1 term
    (98) term -> . factor term2 MULT term1 term
    (99) term -> . factor term2
    (103) factor -> . func_exp
    (104) factor -> . FALSE ctes4
    (105) factor -> . TRUE ctes4
    (106) factor -> . CTE_STR ctes3
    (107) factor -> . CTE_FLT ctes2
    (108) factor -> . CTE_NUM ctes1
    (109) factor -> . ID fact1 LPAREN logic multiexp RPAREN
    (110) factor -> . ID fact1 arr
    (52) func_exp -> . ID fc1 LPAREN fc2 arg fc4 RPAREN fc5 fexp
    FALSE           shift and go to state 85
    TRUE            shift and go to state 86
    CTE_STR         shift and go to state 87
    CTE_FLT         shift and go to state 88
    CTE_NUM         shift and go to state 89
    ID              shift and go to state 90

    logic                          shift and go to state 140
    rel                            shift and go to state 96
    exp                            shift and go to state 97
    term                           shift and go to state 82
    factor                         shift and go to state 83
    func_exp                       shift and go to state 84

state 119

    (118) if_stmnt -> IF LPAREN paren if1 . RPAREN stmnt else_stmnt END if2
    RPAREN          shift and go to state 141


state 120

    (77) logic -> rel log2 . OR log1 logic
    (78) logic -> rel log2 . AND log1 logic
    (79) logic -> rel log2 .
    OR              shift and go to state 142
    AND             shift and go to state 143
    RPAREN          reduce using rule 79 (logic -> rel log2 .)
    COMMA           reduce using rule 79 (logic -> rel log2 .)
    SEMICLN         reduce using rule 79 (logic -> rel log2 .)


state 121

    (88) rel -> exp rel2 . relop rel1 rel
    (89) rel -> exp rel2 .
    (82) relop -> . EQUAL_TO
    (83) relop -> . DIFFERENT_TO
    (84) relop -> . LESS_OR_EQ_THAN
    (85) relop -> . MORE_OR_EQ_THAN
    (86) relop -> . LESS_THAN
    (87) relop -> . MORE_THAN
    OR              reduce using rule 89 (rel -> exp rel2 .)
    AND             reduce using rule 89 (rel -> exp rel2 .)
    RPAREN          reduce using rule 89 (rel -> exp rel2 .)
    COMMA           reduce using rule 89 (rel -> exp rel2 .)
    SEMICLN         reduce using rule 89 (rel -> exp rel2 .)
    EQUAL_TO        shift and go to state 145
    DIFFERENT_TO    shift and go to state 146
    LESS_OR_EQ_THAN shift and go to state 147
    MORE_OR_EQ_THAN shift and go to state 148
    LESS_THAN       shift and go to state 149
    MORE_THAN       shift and go to state 150

    relop                          shift and go to state 144

state 122

    (66) write_stmnt -> WRITE io1 LPAREN paren . io2 multio RPAREN io3 SEMICLN
    (70) io2 -> .
    COMMA           reduce using rule 70 (io2 -> .)
    RPAREN          reduce using rule 70 (io2 -> .)

    io2                            shift and go to state 151

state 123

    (65) read_stmnt -> READ io1 LPAREN paren . multio io2 RPAREN io3 SEMICLN
    (67) multio -> .
    (68) multio -> . COMMA paren io2 multio
    RPAREN          reduce using rule 67 (multio -> .)
    COMMA           shift and go to state 153

    multio                         shift and go to state 152

state 124

    (62) ret_stmnt -> RETURN LPAREN paren retval . RPAREN rettrue SEMICLN
    RPAREN          shift and go to state 154


state 125

    (51) func_stmnt -> ID fc1 LPAREN fc2 . arg fc4 RPAREN fc5 SEMICLN
    (55) arg -> . empty
    (56) arg -> . paren fc3 multiarg
    (128) empty -> .
    (72) paren -> . logic
    (73) paren -> . LPAREN paren1 logic paren2 RPAREN paren3 logic
    (77) logic -> . rel log2 OR log1 logic
    (78) logic -> . rel log2 AND log1 logic
    (79) logic -> . rel log2
    (88) rel -> . exp rel2 relop rel1 rel
    (89) rel -> . exp rel2
    (92) exp -> . term exp2 SUB exp1 exp
    (93) exp -> . term exp2 SUM exp1 exp
    (94) exp -> . term exp2
    (97) term -> . factor term2 DIV term1 term
    (98) term -> . factor term2 MULT term1 term
    (99) term -> . factor term2
    (103) factor -> . func_exp
    (104) factor -> . FALSE ctes4
    (105) factor -> . TRUE ctes4
    (106) factor -> . CTE_STR ctes3
    (107) factor -> . CTE_FLT ctes2
    (108) factor -> . CTE_NUM ctes1
    (109) factor -> . ID fact1 LPAREN logic multiexp RPAREN
    (110) factor -> . ID fact1 arr
    (52) func_exp -> . ID fc1 LPAREN fc2 arg fc4 RPAREN fc5 fexp
    RPAREN          reduce using rule 128 (empty -> .)
    LPAREN          shift and go to state 93
    FALSE           shift and go to state 85
    TRUE            shift and go to state 86
    CTE_STR         shift and go to state 87
    CTE_FLT         shift and go to state 88
    CTE_NUM         shift and go to state 89
    ID              shift and go to state 90

    arg                            shift and go to state 155
    empty                          shift and go to state 156
    paren                          shift and go to state 157
    logic                          shift and go to state 95
    rel                            shift and go to state 96
    exp                            shift and go to state 97
    term                           shift and go to state 82
    factor                         shift and go to state 83
    func_exp                       shift and go to state 84

state 126

    (51) func_stmnt -> ID . fc1 LPAREN fc2 arg fc4 RPAREN fc5 SEMICLN
    (53) fc1 -> .
    LPAREN          reduce using rule 53 (fc1 -> .)

    fc1                            shift and go to state 74

state 127

    (46) ass_stmnt -> ID arr ASS func_stmnt . SEMICLN
    SEMICLN         shift and go to state 158


state 128

    (47) ass_stmnt -> ID ass1 arr ASS . ass2 paren ass3 SEMICLN
    (49) ass2 -> .
    LPAREN          reduce using rule 49 (ass2 -> .)
    FALSE           reduce using rule 49 (ass2 -> .)
    TRUE            reduce using rule 49 (ass2 -> .)
    CTE_STR         reduce using rule 49 (ass2 -> .)
    CTE_FLT         reduce using rule 49 (ass2 -> .)
    CTE_NUM         reduce using rule 49 (ass2 -> .)
    ID              reduce using rule 49 (ass2 -> .)

    ass2                           shift and go to state 159

state 129

    (21) funcdecl -> FUNC tipofunc func1 ID func2 LPAREN param RPAREN func3 . LCURLY varsdecl func4 stmnt RCURLY resetvarcont funcdecl
    LCURLY          shift and go to state 160


state 130

    (30) param -> tipo param1 COLON . ID param2 multiparam
    ID              shift and go to state 161


state 131

    (92) exp -> term exp2 SUB . exp1 exp
    (96) exp1 -> .
    FALSE           reduce using rule 96 (exp1 -> .)
    TRUE            reduce using rule 96 (exp1 -> .)
    CTE_STR         reduce using rule 96 (exp1 -> .)
    CTE_FLT         reduce using rule 96 (exp1 -> .)
    CTE_NUM         reduce using rule 96 (exp1 -> .)
    ID              reduce using rule 96 (exp1 -> .)

    exp1                           shift and go to state 162

state 132

    (93) exp -> term exp2 SUM . exp1 exp
    (96) exp1 -> .
    FALSE           reduce using rule 96 (exp1 -> .)
    TRUE            reduce using rule 96 (exp1 -> .)
    CTE_STR         reduce using rule 96 (exp1 -> .)
    CTE_FLT         reduce using rule 96 (exp1 -> .)
    CTE_NUM         reduce using rule 96 (exp1 -> .)
    ID              reduce using rule 96 (exp1 -> .)

    exp1                           shift and go to state 163

state 133

    (97) term -> factor term2 DIV . term1 term
    (100) term1 -> .
    FALSE           reduce using rule 100 (term1 -> .)
    TRUE            reduce using rule 100 (term1 -> .)
    CTE_STR         reduce using rule 100 (term1 -> .)
    CTE_FLT         reduce using rule 100 (term1 -> .)
    CTE_NUM         reduce using rule 100 (term1 -> .)
    ID              reduce using rule 100 (term1 -> .)

    term1                          shift and go to state 164

state 134

    (98) term -> factor term2 MULT . term1 term
    (100) term1 -> .
    FALSE           reduce using rule 100 (term1 -> .)
    TRUE            reduce using rule 100 (term1 -> .)
    CTE_STR         reduce using rule 100 (term1 -> .)
    CTE_FLT         reduce using rule 100 (term1 -> .)
    CTE_NUM         reduce using rule 100 (term1 -> .)
    ID              reduce using rule 100 (term1 -> .)

    term1                          shift and go to state 165

state 135

    (109) factor -> ID fact1 LPAREN . logic multiexp RPAREN
    (77) logic -> . rel log2 OR log1 logic
    (78) logic -> . rel log2 AND log1 logic
    (79) logic -> . rel log2
    (88) rel -> . exp rel2 relop rel1 rel
    (89) rel -> . exp rel2
    (92) exp -> . term exp2 SUB exp1 exp
    (93) exp -> . term exp2 SUM exp1 exp
    (94) exp -> . term exp2
    (97) term -> . factor term2 DIV term1 term
    (98) term -> . factor term2 MULT term1 term
    (99) term -> . factor term2
    (103) factor -> . func_exp
    (104) factor -> . FALSE ctes4
    (105) factor -> . TRUE ctes4
    (106) factor -> . CTE_STR ctes3
    (107) factor -> . CTE_FLT ctes2
    (108) factor -> . CTE_NUM ctes1
    (109) factor -> . ID fact1 LPAREN logic multiexp RPAREN
    (110) factor -> . ID fact1 arr
    (52) func_exp -> . ID fc1 LPAREN fc2 arg fc4 RPAREN fc5 fexp
    FALSE           shift and go to state 85
    TRUE            shift and go to state 86
    CTE_STR         shift and go to state 87
    CTE_FLT         shift and go to state 88
    CTE_NUM         shift and go to state 89
    ID              shift and go to state 90

    logic                          shift and go to state 166
    rel                            shift and go to state 96
    exp                            shift and go to state 97
    term                           shift and go to state 82
    factor                         shift and go to state 83
    func_exp                       shift and go to state 84

state 136

    (110) factor -> ID fact1 arr .
    DIV             reduce using rule 110 (factor -> ID fact1 arr .)
    MULT            reduce using rule 110 (factor -> ID fact1 arr .)
    SUB             reduce using rule 110 (factor -> ID fact1 arr .)
    SUM             reduce using rule 110 (factor -> ID fact1 arr .)
    RSQUARE         reduce using rule 110 (factor -> ID fact1 arr .)
    EQUAL_TO        reduce using rule 110 (factor -> ID fact1 arr .)
    DIFFERENT_TO    reduce using rule 110 (factor -> ID fact1 arr .)
    LESS_OR_EQ_THAN reduce using rule 110 (factor -> ID fact1 arr .)
    MORE_OR_EQ_THAN reduce using rule 110 (factor -> ID fact1 arr .)
    LESS_THAN       reduce using rule 110 (factor -> ID fact1 arr .)
    MORE_THAN       reduce using rule 110 (factor -> ID fact1 arr .)
    OR              reduce using rule 110 (factor -> ID fact1 arr .)
    AND             reduce using rule 110 (factor -> ID fact1 arr .)
    RPAREN          reduce using rule 110 (factor -> ID fact1 arr .)
    COMMA           reduce using rule 110 (factor -> ID fact1 arr .)
    SEMICLN         reduce using rule 110 (factor -> ID fact1 arr .)


state 137

    (52) func_exp -> ID fc1 LPAREN . fc2 arg fc4 RPAREN fc5 fexp
    (54) fc2 -> .
    LPAREN          reduce using rule 54 (fc2 -> .)
    FALSE           reduce using rule 54 (fc2 -> .)
    TRUE            reduce using rule 54 (fc2 -> .)
    CTE_STR         reduce using rule 54 (fc2 -> .)
    CTE_FLT         reduce using rule 54 (fc2 -> .)
    CTE_NUM         reduce using rule 54 (fc2 -> .)
    ID              reduce using rule 54 (fc2 -> .)
    RPAREN          reduce using rule 54 (fc2 -> .)

    fc2                            shift and go to state 167

state 138

    (9) multivd -> tipo prog4 COLON ID prog5 arr multid SEMICLN . multivd
    (8) multivd -> . empty
    (9) multivd -> . tipo prog4 COLON ID prog5 arr multid SEMICLN multivd
    (128) empty -> .
    (14) tipo -> . BOOL
    (15) tipo -> . CHAR
    (16) tipo -> . FLOAT
    (17) tipo -> . INT
    COMMA           reduce using rule 128 (empty -> .)
    FUNC            reduce using rule 128 (empty -> .)
    MAIN            reduce using rule 128 (empty -> .)
    WHILE           reduce using rule 128 (empty -> .)
    IF              reduce using rule 128 (empty -> .)
    WRITE           reduce using rule 128 (empty -> .)
    READ            reduce using rule 128 (empty -> .)
    RETURN          reduce using rule 128 (empty -> .)
    ID              reduce using rule 128 (empty -> .)
    RCURLY          reduce using rule 128 (empty -> .)
    BOOL            shift and go to state 19
    CHAR            shift and go to state 20
    FLOAT           shift and go to state 21
    INT             shift and go to state 22

    tipo                           shift and go to state 25
    multivd                        shift and go to state 168
    empty                          shift and go to state 24

state 139

    (124) while_stmnt -> WHILE while1 LPAREN paren while2 . RPAREN stmnt while3 END
    RPAREN          shift and go to state 169


state 140

    (73) paren -> LPAREN paren1 logic . paren2 RPAREN paren3 logic
    (75) paren2 -> .
    RPAREN          reduce using rule 75 (paren2 -> .)

    paren2                         shift and go to state 170

state 141

    (118) if_stmnt -> IF LPAREN paren if1 RPAREN . stmnt else_stmnt END if2
    (38) stmnt -> . empty
    (39) stmnt -> . while_stmnt stmnt
    (40) stmnt -> . if_stmnt stmnt
    (41) stmnt -> . write_stmnt stmnt
    (42) stmnt -> . read_stmnt stmnt
    (43) stmnt -> . ret_stmnt stmnt
    (44) stmnt -> . func_stmnt stmnt
    (45) stmnt -> . ass_stmnt stmnt
    (128) empty -> .
    (124) while_stmnt -> . WHILE while1 LPAREN paren while2 RPAREN stmnt while3 END
    (118) if_stmnt -> . IF LPAREN paren if1 RPAREN stmnt else_stmnt END if2
    (66) write_stmnt -> . WRITE io1 LPAREN paren io2 multio RPAREN io3 SEMICLN
    (65) read_stmnt -> . READ io1 LPAREN paren multio io2 RPAREN io3 SEMICLN
    (62) ret_stmnt -> . RETURN LPAREN paren retval RPAREN rettrue SEMICLN
    (51) func_stmnt -> . ID fc1 LPAREN fc2 arg fc4 RPAREN fc5 SEMICLN
    (46) ass_stmnt -> . ID arr ASS func_stmnt SEMICLN
    (47) ass_stmnt -> . ID ass1 arr ASS ass2 paren ass3 SEMICLN
    ELSE            reduce using rule 128 (empty -> .)
    END             reduce using rule 128 (empty -> .)
    WHILE           shift and go to state 50
    IF              shift and go to state 51
    WRITE           shift and go to state 52
    READ            shift and go to state 53
    RETURN          shift and go to state 54
    ID              shift and go to state 55

    stmnt                          shift and go to state 171
    empty                          shift and go to state 42
    while_stmnt                    shift and go to state 43
    if_stmnt                       shift and go to state 44
    write_stmnt                    shift and go to state 45
    read_stmnt                     shift and go to state 46
    ret_stmnt                      shift and go to state 47
    func_stmnt                     shift and go to state 48
    ass_stmnt                      shift and go to state 49

state 142

    (77) logic -> rel log2 OR . log1 logic
    (80) log1 -> .
    FALSE           reduce using rule 80 (log1 -> .)
    TRUE            reduce using rule 80 (log1 -> .)
    CTE_STR         reduce using rule 80 (log1 -> .)
    CTE_FLT         reduce using rule 80 (log1 -> .)
    CTE_NUM         reduce using rule 80 (log1 -> .)
    ID              reduce using rule 80 (log1 -> .)

    log1                           shift and go to state 172

state 143

    (78) logic -> rel log2 AND . log1 logic
    (80) log1 -> .
    FALSE           reduce using rule 80 (log1 -> .)
    TRUE            reduce using rule 80 (log1 -> .)
    CTE_STR         reduce using rule 80 (log1 -> .)
    CTE_FLT         reduce using rule 80 (log1 -> .)
    CTE_NUM         reduce using rule 80 (log1 -> .)
    ID              reduce using rule 80 (log1 -> .)

    log1                           shift and go to state 173

state 144

    (88) rel -> exp rel2 relop . rel1 rel
    (90) rel1 -> .
    FALSE           reduce using rule 90 (rel1 -> .)
    TRUE            reduce using rule 90 (rel1 -> .)
    CTE_STR         reduce using rule 90 (rel1 -> .)
    CTE_FLT         reduce using rule 90 (rel1 -> .)
    CTE_NUM         reduce using rule 90 (rel1 -> .)
    ID              reduce using rule 90 (rel1 -> .)

    rel1                           shift and go to state 174

state 145

    (82) relop -> EQUAL_TO .
    FALSE           reduce using rule 82 (relop -> EQUAL_TO .)
    TRUE            reduce using rule 82 (relop -> EQUAL_TO .)
    CTE_STR         reduce using rule 82 (relop -> EQUAL_TO .)
    CTE_FLT         reduce using rule 82 (relop -> EQUAL_TO .)
    CTE_NUM         reduce using rule 82 (relop -> EQUAL_TO .)
    ID              reduce using rule 82 (relop -> EQUAL_TO .)


state 146

    (83) relop -> DIFFERENT_TO .
    FALSE           reduce using rule 83 (relop -> DIFFERENT_TO .)
    TRUE            reduce using rule 83 (relop -> DIFFERENT_TO .)
    CTE_STR         reduce using rule 83 (relop -> DIFFERENT_TO .)
    CTE_FLT         reduce using rule 83 (relop -> DIFFERENT_TO .)
    CTE_NUM         reduce using rule 83 (relop -> DIFFERENT_TO .)
    ID              reduce using rule 83 (relop -> DIFFERENT_TO .)


state 147

    (84) relop -> LESS_OR_EQ_THAN .
    FALSE           reduce using rule 84 (relop -> LESS_OR_EQ_THAN .)
    TRUE            reduce using rule 84 (relop -> LESS_OR_EQ_THAN .)
    CTE_STR         reduce using rule 84 (relop -> LESS_OR_EQ_THAN .)
    CTE_FLT         reduce using rule 84 (relop -> LESS_OR_EQ_THAN .)
    CTE_NUM         reduce using rule 84 (relop -> LESS_OR_EQ_THAN .)
    ID              reduce using rule 84 (relop -> LESS_OR_EQ_THAN .)


state 148

    (85) relop -> MORE_OR_EQ_THAN .
    FALSE           reduce using rule 85 (relop -> MORE_OR_EQ_THAN .)
    TRUE            reduce using rule 85 (relop -> MORE_OR_EQ_THAN .)
    CTE_STR         reduce using rule 85 (relop -> MORE_OR_EQ_THAN .)
    CTE_FLT         reduce using rule 85 (relop -> MORE_OR_EQ_THAN .)
    CTE_NUM         reduce using rule 85 (relop -> MORE_OR_EQ_THAN .)
    ID              reduce using rule 85 (relop -> MORE_OR_EQ_THAN .)


state 149

    (86) relop -> LESS_THAN .
    FALSE           reduce using rule 86 (relop -> LESS_THAN .)
    TRUE            reduce using rule 86 (relop -> LESS_THAN .)
    CTE_STR         reduce using rule 86 (relop -> LESS_THAN .)
    CTE_FLT         reduce using rule 86 (relop -> LESS_THAN .)
    CTE_NUM         reduce using rule 86 (relop -> LESS_THAN .)
    ID              reduce using rule 86 (relop -> LESS_THAN .)


state 150

    (87) relop -> MORE_THAN .
    FALSE           reduce using rule 87 (relop -> MORE_THAN .)
    TRUE            reduce using rule 87 (relop -> MORE_THAN .)
    CTE_STR         reduce using rule 87 (relop -> MORE_THAN .)
    CTE_FLT         reduce using rule 87 (relop -> MORE_THAN .)
    CTE_NUM         reduce using rule 87 (relop -> MORE_THAN .)
    ID              reduce using rule 87 (relop -> MORE_THAN .)


state 151

    (66) write_stmnt -> WRITE io1 LPAREN paren io2 . multio RPAREN io3 SEMICLN
    (67) multio -> .
    (68) multio -> . COMMA paren io2 multio
    RPAREN          reduce using rule 67 (multio -> .)
    COMMA           shift and go to state 153

    multio                         shift and go to state 175

state 152

    (65) read_stmnt -> READ io1 LPAREN paren multio . io2 RPAREN io3 SEMICLN
    (70) io2 -> .
    RPAREN          reduce using rule 70 (io2 -> .)

    io2                            shift and go to state 176

state 153

    (68) multio -> COMMA . paren io2 multio
    (72) paren -> . logic
    (73) paren -> . LPAREN paren1 logic paren2 RPAREN paren3 logic
    (77) logic -> . rel log2 OR log1 logic
    (78) logic -> . rel log2 AND log1 logic
    (79) logic -> . rel log2
    (88) rel -> . exp rel2 relop rel1 rel
    (89) rel -> . exp rel2
    (92) exp -> . term exp2 SUB exp1 exp
    (93) exp -> . term exp2 SUM exp1 exp
    (94) exp -> . term exp2
    (97) term -> . factor term2 DIV term1 term
    (98) term -> . factor term2 MULT term1 term
    (99) term -> . factor term2
    (103) factor -> . func_exp
    (104) factor -> . FALSE ctes4
    (105) factor -> . TRUE ctes4
    (106) factor -> . CTE_STR ctes3
    (107) factor -> . CTE_FLT ctes2
    (108) factor -> . CTE_NUM ctes1
    (109) factor -> . ID fact1 LPAREN logic multiexp RPAREN
    (110) factor -> . ID fact1 arr
    (52) func_exp -> . ID fc1 LPAREN fc2 arg fc4 RPAREN fc5 fexp
    LPAREN          shift and go to state 93
    FALSE           shift and go to state 85
    TRUE            shift and go to state 86
    CTE_STR         shift and go to state 87
    CTE_FLT         shift and go to state 88
    CTE_NUM         shift and go to state 89
    ID              shift and go to state 90

    paren                          shift and go to state 177
    logic                          shift and go to state 95
    rel                            shift and go to state 96
    exp                            shift and go to state 97
    term                           shift and go to state 82
    factor                         shift and go to state 83
    func_exp                       shift and go to state 84

state 154

    (62) ret_stmnt -> RETURN LPAREN paren retval RPAREN . rettrue SEMICLN
    (63) rettrue -> .
    SEMICLN         reduce using rule 63 (rettrue -> .)

    rettrue                        shift and go to state 178

state 155

    (51) func_stmnt -> ID fc1 LPAREN fc2 arg . fc4 RPAREN fc5 SEMICLN
    (58) fc4 -> .
    RPAREN          reduce using rule 58 (fc4 -> .)

    fc4                            shift and go to state 179

state 156

    (55) arg -> empty .
    RPAREN          reduce using rule 55 (arg -> empty .)
    COMMA           reduce using rule 55 (arg -> empty .)


state 157

    (56) arg -> paren . fc3 multiarg
    (57) fc3 -> .
    COMMA           reduce using rule 57 (fc3 -> .)
    RPAREN          reduce using rule 57 (fc3 -> .)

    fc3                            shift and go to state 180

state 158

    (46) ass_stmnt -> ID arr ASS func_stmnt SEMICLN .
    WHILE           reduce using rule 46 (ass_stmnt -> ID arr ASS func_stmnt SEMICLN .)
    IF              reduce using rule 46 (ass_stmnt -> ID arr ASS func_stmnt SEMICLN .)
    WRITE           reduce using rule 46 (ass_stmnt -> ID arr ASS func_stmnt SEMICLN .)
    READ            reduce using rule 46 (ass_stmnt -> ID arr ASS func_stmnt SEMICLN .)
    RETURN          reduce using rule 46 (ass_stmnt -> ID arr ASS func_stmnt SEMICLN .)
    ID              reduce using rule 46 (ass_stmnt -> ID arr ASS func_stmnt SEMICLN .)
    $end            reduce using rule 46 (ass_stmnt -> ID arr ASS func_stmnt SEMICLN .)
    ELSE            reduce using rule 46 (ass_stmnt -> ID arr ASS func_stmnt SEMICLN .)
    END             reduce using rule 46 (ass_stmnt -> ID arr ASS func_stmnt SEMICLN .)
    RCURLY          reduce using rule 46 (ass_stmnt -> ID arr ASS func_stmnt SEMICLN .)


state 159

    (47) ass_stmnt -> ID ass1 arr ASS ass2 . paren ass3 SEMICLN
    (72) paren -> . logic
    (73) paren -> . LPAREN paren1 logic paren2 RPAREN paren3 logic
    (77) logic -> . rel log2 OR log1 logic
    (78) logic -> . rel log2 AND log1 logic
    (79) logic -> . rel log2
    (88) rel -> . exp rel2 relop rel1 rel
    (89) rel -> . exp rel2
    (92) exp -> . term exp2 SUB exp1 exp
    (93) exp -> . term exp2 SUM exp1 exp
    (94) exp -> . term exp2
    (97) term -> . factor term2 DIV term1 term
    (98) term -> . factor term2 MULT term1 term
    (99) term -> . factor term2
    (103) factor -> . func_exp
    (104) factor -> . FALSE ctes4
    (105) factor -> . TRUE ctes4
    (106) factor -> . CTE_STR ctes3
    (107) factor -> . CTE_FLT ctes2
    (108) factor -> . CTE_NUM ctes1
    (109) factor -> . ID fact1 LPAREN logic multiexp RPAREN
    (110) factor -> . ID fact1 arr
    (52) func_exp -> . ID fc1 LPAREN fc2 arg fc4 RPAREN fc5 fexp
    LPAREN          shift and go to state 93
    FALSE           shift and go to state 85
    TRUE            shift and go to state 86
    CTE_STR         shift and go to state 87
    CTE_FLT         shift and go to state 88
    CTE_NUM         shift and go to state 89
    ID              shift and go to state 90

    paren                          shift and go to state 181
    logic                          shift and go to state 95
    rel                            shift and go to state 96
    exp                            shift and go to state 97
    term                           shift and go to state 82
    factor                         shift and go to state 83
    func_exp                       shift and go to state 84

state 160

    (21) funcdecl -> FUNC tipofunc func1 ID func2 LPAREN param RPAREN func3 LCURLY . varsdecl func4 stmnt RCURLY resetvarcont funcdecl
    (5) varsdecl -> . empty
    (6) varsdecl -> . VARS prog3 multivd multid
    (128) empty -> .
    VARS            shift and go to state 9
    WHILE           reduce using rule 128 (empty -> .)
    IF              reduce using rule 128 (empty -> .)
    WRITE           reduce using rule 128 (empty -> .)
    READ            reduce using rule 128 (empty -> .)
    RETURN          reduce using rule 128 (empty -> .)
    ID              reduce using rule 128 (empty -> .)
    RCURLY          reduce using rule 128 (empty -> .)

    varsdecl                       shift and go to state 182
    empty                          shift and go to state 8

state 161

    (30) param -> tipo param1 COLON ID . param2 multiparam
    (32) param2 -> .
    COMMA           reduce using rule 32 (param2 -> .)
    RPAREN          reduce using rule 32 (param2 -> .)

    param2                         shift and go to state 183

state 162

    (92) exp -> term exp2 SUB exp1 . exp
    (92) exp -> . term exp2 SUB exp1 exp
    (93) exp -> . term exp2 SUM exp1 exp
    (94) exp -> . term exp2
    (97) term -> . factor term2 DIV term1 term
    (98) term -> . factor term2 MULT term1 term
    (99) term -> . factor term2
    (103) factor -> . func_exp
    (104) factor -> . FALSE ctes4
    (105) factor -> . TRUE ctes4
    (106) factor -> . CTE_STR ctes3
    (107) factor -> . CTE_FLT ctes2
    (108) factor -> . CTE_NUM ctes1
    (109) factor -> . ID fact1 LPAREN logic multiexp RPAREN
    (110) factor -> . ID fact1 arr
    (52) func_exp -> . ID fc1 LPAREN fc2 arg fc4 RPAREN fc5 fexp
    FALSE           shift and go to state 85
    TRUE            shift and go to state 86
    CTE_STR         shift and go to state 87
    CTE_FLT         shift and go to state 88
    CTE_NUM         shift and go to state 89
    ID              shift and go to state 90

    term                           shift and go to state 82
    exp                            shift and go to state 184
    factor                         shift and go to state 83
    func_exp                       shift and go to state 84

state 163

    (93) exp -> term exp2 SUM exp1 . exp
    (92) exp -> . term exp2 SUB exp1 exp
    (93) exp -> . term exp2 SUM exp1 exp
    (94) exp -> . term exp2
    (97) term -> . factor term2 DIV term1 term
    (98) term -> . factor term2 MULT term1 term
    (99) term -> . factor term2
    (103) factor -> . func_exp
    (104) factor -> . FALSE ctes4
    (105) factor -> . TRUE ctes4
    (106) factor -> . CTE_STR ctes3
    (107) factor -> . CTE_FLT ctes2
    (108) factor -> . CTE_NUM ctes1
    (109) factor -> . ID fact1 LPAREN logic multiexp RPAREN
    (110) factor -> . ID fact1 arr
    (52) func_exp -> . ID fc1 LPAREN fc2 arg fc4 RPAREN fc5 fexp
    FALSE           shift and go to state 85
    TRUE            shift and go to state 86
    CTE_STR         shift and go to state 87
    CTE_FLT         shift and go to state 88
    CTE_NUM         shift and go to state 89
    ID              shift and go to state 90

    term                           shift and go to state 82
    exp                            shift and go to state 185
    factor                         shift and go to state 83
    func_exp                       shift and go to state 84

state 164

    (97) term -> factor term2 DIV term1 . term
    (97) term -> . factor term2 DIV term1 term
    (98) term -> . factor term2 MULT term1 term
    (99) term -> . factor term2
    (103) factor -> . func_exp
    (104) factor -> . FALSE ctes4
    (105) factor -> . TRUE ctes4
    (106) factor -> . CTE_STR ctes3
    (107) factor -> . CTE_FLT ctes2
    (108) factor -> . CTE_NUM ctes1
    (109) factor -> . ID fact1 LPAREN logic multiexp RPAREN
    (110) factor -> . ID fact1 arr
    (52) func_exp -> . ID fc1 LPAREN fc2 arg fc4 RPAREN fc5 fexp
    FALSE           shift and go to state 85
    TRUE            shift and go to state 86
    CTE_STR         shift and go to state 87
    CTE_FLT         shift and go to state 88
    CTE_NUM         shift and go to state 89
    ID              shift and go to state 90

    factor                         shift and go to state 83
    term                           shift and go to state 186
    func_exp                       shift and go to state 84

state 165

    (98) term -> factor term2 MULT term1 . term
    (97) term -> . factor term2 DIV term1 term
    (98) term -> . factor term2 MULT term1 term
    (99) term -> . factor term2
    (103) factor -> . func_exp
    (104) factor -> . FALSE ctes4
    (105) factor -> . TRUE ctes4
    (106) factor -> . CTE_STR ctes3
    (107) factor -> . CTE_FLT ctes2
    (108) factor -> . CTE_NUM ctes1
    (109) factor -> . ID fact1 LPAREN logic multiexp RPAREN
    (110) factor -> . ID fact1 arr
    (52) func_exp -> . ID fc1 LPAREN fc2 arg fc4 RPAREN fc5 fexp
    FALSE           shift and go to state 85
    TRUE            shift and go to state 86
    CTE_STR         shift and go to state 87
    CTE_FLT         shift and go to state 88
    CTE_NUM         shift and go to state 89
    ID              shift and go to state 90

    factor                         shift and go to state 83
    term                           shift and go to state 187
    func_exp                       shift and go to state 84

state 166

    (109) factor -> ID fact1 LPAREN logic . multiexp RPAREN
    (116) multiexp -> . empty
    (117) multiexp -> . COMMA paren multiexp
    (128) empty -> .
    COMMA           shift and go to state 190
    RPAREN          reduce using rule 128 (empty -> .)

    multiexp                       shift and go to state 188
    empty                          shift and go to state 189

state 167

    (52) func_exp -> ID fc1 LPAREN fc2 . arg fc4 RPAREN fc5 fexp
    (55) arg -> . empty
    (56) arg -> . paren fc3 multiarg
    (128) empty -> .
    (72) paren -> . logic
    (73) paren -> . LPAREN paren1 logic paren2 RPAREN paren3 logic
    (77) logic -> . rel log2 OR log1 logic
    (78) logic -> . rel log2 AND log1 logic
    (79) logic -> . rel log2
    (88) rel -> . exp rel2 relop rel1 rel
    (89) rel -> . exp rel2
    (92) exp -> . term exp2 SUB exp1 exp
    (93) exp -> . term exp2 SUM exp1 exp
    (94) exp -> . term exp2
    (97) term -> . factor term2 DIV term1 term
    (98) term -> . factor term2 MULT term1 term
    (99) term -> . factor term2
    (103) factor -> . func_exp
    (104) factor -> . FALSE ctes4
    (105) factor -> . TRUE ctes4
    (106) factor -> . CTE_STR ctes3
    (107) factor -> . CTE_FLT ctes2
    (108) factor -> . CTE_NUM ctes1
    (109) factor -> . ID fact1 LPAREN logic multiexp RPAREN
    (110) factor -> . ID fact1 arr
    (52) func_exp -> . ID fc1 LPAREN fc2 arg fc4 RPAREN fc5 fexp
    RPAREN          reduce using rule 128 (empty -> .)
    LPAREN          shift and go to state 93
    FALSE           shift and go to state 85
    TRUE            shift and go to state 86
    CTE_STR         shift and go to state 87
    CTE_FLT         shift and go to state 88
    CTE_NUM         shift and go to state 89
    ID              shift and go to state 90

    arg                            shift and go to state 191
    empty                          shift and go to state 156
    paren                          shift and go to state 157
    logic                          shift and go to state 95
    rel                            shift and go to state 96
    exp                            shift and go to state 97
    term                           shift and go to state 82
    factor                         shift and go to state 83
    func_exp                       shift and go to state 84

state 168

    (9) multivd -> tipo prog4 COLON ID prog5 arr multid SEMICLN multivd .
    COMMA           reduce using rule 9 (multivd -> tipo prog4 COLON ID prog5 arr multid SEMICLN multivd .)
    FUNC            reduce using rule 9 (multivd -> tipo prog4 COLON ID prog5 arr multid SEMICLN multivd .)
    MAIN            reduce using rule 9 (multivd -> tipo prog4 COLON ID prog5 arr multid SEMICLN multivd .)
    WHILE           reduce using rule 9 (multivd -> tipo prog4 COLON ID prog5 arr multid SEMICLN multivd .)
    IF              reduce using rule 9 (multivd -> tipo prog4 COLON ID prog5 arr multid SEMICLN multivd .)
    WRITE           reduce using rule 9 (multivd -> tipo prog4 COLON ID prog5 arr multid SEMICLN multivd .)
    READ            reduce using rule 9 (multivd -> tipo prog4 COLON ID prog5 arr multid SEMICLN multivd .)
    RETURN          reduce using rule 9 (multivd -> tipo prog4 COLON ID prog5 arr multid SEMICLN multivd .)
    ID              reduce using rule 9 (multivd -> tipo prog4 COLON ID prog5 arr multid SEMICLN multivd .)
    RCURLY          reduce using rule 9 (multivd -> tipo prog4 COLON ID prog5 arr multid SEMICLN multivd .)


state 169

    (124) while_stmnt -> WHILE while1 LPAREN paren while2 RPAREN . stmnt while3 END
    (38) stmnt -> . empty
    (39) stmnt -> . while_stmnt stmnt
    (40) stmnt -> . if_stmnt stmnt
    (41) stmnt -> . write_stmnt stmnt
    (42) stmnt -> . read_stmnt stmnt
    (43) stmnt -> . ret_stmnt stmnt
    (44) stmnt -> . func_stmnt stmnt
    (45) stmnt -> . ass_stmnt stmnt
    (128) empty -> .
    (124) while_stmnt -> . WHILE while1 LPAREN paren while2 RPAREN stmnt while3 END
    (118) if_stmnt -> . IF LPAREN paren if1 RPAREN stmnt else_stmnt END if2
    (66) write_stmnt -> . WRITE io1 LPAREN paren io2 multio RPAREN io3 SEMICLN
    (65) read_stmnt -> . READ io1 LPAREN paren multio io2 RPAREN io3 SEMICLN
    (62) ret_stmnt -> . RETURN LPAREN paren retval RPAREN rettrue SEMICLN
    (51) func_stmnt -> . ID fc1 LPAREN fc2 arg fc4 RPAREN fc5 SEMICLN
    (46) ass_stmnt -> . ID arr ASS func_stmnt SEMICLN
    (47) ass_stmnt -> . ID ass1 arr ASS ass2 paren ass3 SEMICLN
    END             reduce using rule 128 (empty -> .)
    WHILE           shift and go to state 50
    IF              shift and go to state 51
    WRITE           shift and go to state 52
    READ            shift and go to state 53
    RETURN          shift and go to state 54
    ID              shift and go to state 55

    stmnt                          shift and go to state 192
    empty                          shift and go to state 42
    while_stmnt                    shift and go to state 43
    if_stmnt                       shift and go to state 44
    write_stmnt                    shift and go to state 45
    read_stmnt                     shift and go to state 46
    ret_stmnt                      shift and go to state 47
    func_stmnt                     shift and go to state 48
    ass_stmnt                      shift and go to state 49

state 170

    (73) paren -> LPAREN paren1 logic paren2 . RPAREN paren3 logic
    RPAREN          shift and go to state 193


state 171

    (118) if_stmnt -> IF LPAREN paren if1 RPAREN stmnt . else_stmnt END if2
    (121) else_stmnt -> . empty
    (122) else_stmnt -> . ELSE else1 stmnt
    (128) empty -> .
    ELSE            shift and go to state 196
    END             reduce using rule 128 (empty -> .)

    else_stmnt                     shift and go to state 194
    empty                          shift and go to state 195

state 172

    (77) logic -> rel log2 OR log1 . logic
    (77) logic -> . rel log2 OR log1 logic
    (78) logic -> . rel log2 AND log1 logic
    (79) logic -> . rel log2
    (88) rel -> . exp rel2 relop rel1 rel
    (89) rel -> . exp rel2
    (92) exp -> . term exp2 SUB exp1 exp
    (93) exp -> . term exp2 SUM exp1 exp
    (94) exp -> . term exp2
    (97) term -> . factor term2 DIV term1 term
    (98) term -> . factor term2 MULT term1 term
    (99) term -> . factor term2
    (103) factor -> . func_exp
    (104) factor -> . FALSE ctes4
    (105) factor -> . TRUE ctes4
    (106) factor -> . CTE_STR ctes3
    (107) factor -> . CTE_FLT ctes2
    (108) factor -> . CTE_NUM ctes1
    (109) factor -> . ID fact1 LPAREN logic multiexp RPAREN
    (110) factor -> . ID fact1 arr
    (52) func_exp -> . ID fc1 LPAREN fc2 arg fc4 RPAREN fc5 fexp
    FALSE           shift and go to state 85
    TRUE            shift and go to state 86
    CTE_STR         shift and go to state 87
    CTE_FLT         shift and go to state 88
    CTE_NUM         shift and go to state 89
    ID              shift and go to state 90

    rel                            shift and go to state 96
    logic                          shift and go to state 197
    exp                            shift and go to state 97
    term                           shift and go to state 82
    factor                         shift and go to state 83
    func_exp                       shift and go to state 84

state 173

    (78) logic -> rel log2 AND log1 . logic
    (77) logic -> . rel log2 OR log1 logic
    (78) logic -> . rel log2 AND log1 logic
    (79) logic -> . rel log2
    (88) rel -> . exp rel2 relop rel1 rel
    (89) rel -> . exp rel2
    (92) exp -> . term exp2 SUB exp1 exp
    (93) exp -> . term exp2 SUM exp1 exp
    (94) exp -> . term exp2
    (97) term -> . factor term2 DIV term1 term
    (98) term -> . factor term2 MULT term1 term
    (99) term -> . factor term2
    (103) factor -> . func_exp
    (104) factor -> . FALSE ctes4
    (105) factor -> . TRUE ctes4
    (106) factor -> . CTE_STR ctes3
    (107) factor -> . CTE_FLT ctes2
    (108) factor -> . CTE_NUM ctes1
    (109) factor -> . ID fact1 LPAREN logic multiexp RPAREN
    (110) factor -> . ID fact1 arr
    (52) func_exp -> . ID fc1 LPAREN fc2 arg fc4 RPAREN fc5 fexp
    FALSE           shift and go to state 85
    TRUE            shift and go to state 86
    CTE_STR         shift and go to state 87
    CTE_FLT         shift and go to state 88
    CTE_NUM         shift and go to state 89
    ID              shift and go to state 90

    rel                            shift and go to state 96
    logic                          shift and go to state 198
    exp                            shift and go to state 97
    term                           shift and go to state 82
    factor                         shift and go to state 83
    func_exp                       shift and go to state 84

state 174

    (88) rel -> exp rel2 relop rel1 . rel
    (88) rel -> . exp rel2 relop rel1 rel
    (89) rel -> . exp rel2
    (92) exp -> . term exp2 SUB exp1 exp
    (93) exp -> . term exp2 SUM exp1 exp
    (94) exp -> . term exp2
    (97) term -> . factor term2 DIV term1 term
    (98) term -> . factor term2 MULT term1 term
    (99) term -> . factor term2
    (103) factor -> . func_exp
    (104) factor -> . FALSE ctes4
    (105) factor -> . TRUE ctes4
    (106) factor -> . CTE_STR ctes3
    (107) factor -> . CTE_FLT ctes2
    (108) factor -> . CTE_NUM ctes1
    (109) factor -> . ID fact1 LPAREN logic multiexp RPAREN
    (110) factor -> . ID fact1 arr
    (52) func_exp -> . ID fc1 LPAREN fc2 arg fc4 RPAREN fc5 fexp
    FALSE           shift and go to state 85
    TRUE            shift and go to state 86
    CTE_STR         shift and go to state 87
    CTE_FLT         shift and go to state 88
    CTE_NUM         shift and go to state 89
    ID              shift and go to state 90

    exp                            shift and go to state 97
    rel                            shift and go to state 199
    term                           shift and go to state 82
    factor                         shift and go to state 83
    func_exp                       shift and go to state 84

state 175

    (66) write_stmnt -> WRITE io1 LPAREN paren io2 multio . RPAREN io3 SEMICLN
    RPAREN          shift and go to state 200


state 176

    (65) read_stmnt -> READ io1 LPAREN paren multio io2 . RPAREN io3 SEMICLN
    RPAREN          shift and go to state 201


state 177

    (68) multio -> COMMA paren . io2 multio
    (70) io2 -> .
    COMMA           reduce using rule 70 (io2 -> .)
    RPAREN          reduce using rule 70 (io2 -> .)

    io2                            shift and go to state 202

state 178

    (62) ret_stmnt -> RETURN LPAREN paren retval RPAREN rettrue . SEMICLN
    SEMICLN         shift and go to state 203


state 179

    (51) func_stmnt -> ID fc1 LPAREN fc2 arg fc4 . RPAREN fc5 SEMICLN
    RPAREN          shift and go to state 204


state 180

    (56) arg -> paren fc3 . multiarg
    (60) multiarg -> . empty
    (61) multiarg -> . COMMA arg multiarg
    (128) empty -> .
  ! shift/reduce conflict for COMMA resolved as shift
    COMMA           shift and go to state 207
    RPAREN          reduce using rule 128 (empty -> .)

    multiarg                       shift and go to state 205
    empty                          shift and go to state 206

state 181

    (47) ass_stmnt -> ID ass1 arr ASS ass2 paren . ass3 SEMICLN
    (50) ass3 -> .
    SEMICLN         reduce using rule 50 (ass3 -> .)

    ass3                           shift and go to state 208

state 182

    (21) funcdecl -> FUNC tipofunc func1 ID func2 LPAREN param RPAREN func3 LCURLY varsdecl . func4 stmnt RCURLY resetvarcont funcdecl
    (25) func4 -> .
    WHILE           reduce using rule 25 (func4 -> .)
    IF              reduce using rule 25 (func4 -> .)
    WRITE           reduce using rule 25 (func4 -> .)
    READ            reduce using rule 25 (func4 -> .)
    RETURN          reduce using rule 25 (func4 -> .)
    ID              reduce using rule 25 (func4 -> .)
    RCURLY          reduce using rule 25 (func4 -> .)

    func4                          shift and go to state 209

state 183

    (30) param -> tipo param1 COLON ID param2 . multiparam
    (33) multiparam -> . empty
    (34) multiparam -> . COMMA param
    (128) empty -> .
    COMMA           shift and go to state 212
    RPAREN          reduce using rule 128 (empty -> .)

    multiparam                     shift and go to state 210
    empty                          shift and go to state 211

state 184

    (92) exp -> term exp2 SUB exp1 exp .
    RSQUARE         reduce using rule 92 (exp -> term exp2 SUB exp1 exp .)
    EQUAL_TO        reduce using rule 92 (exp -> term exp2 SUB exp1 exp .)
    DIFFERENT_TO    reduce using rule 92 (exp -> term exp2 SUB exp1 exp .)
    LESS_OR_EQ_THAN reduce using rule 92 (exp -> term exp2 SUB exp1 exp .)
    MORE_OR_EQ_THAN reduce using rule 92 (exp -> term exp2 SUB exp1 exp .)
    LESS_THAN       reduce using rule 92 (exp -> term exp2 SUB exp1 exp .)
    MORE_THAN       reduce using rule 92 (exp -> term exp2 SUB exp1 exp .)
    OR              reduce using rule 92 (exp -> term exp2 SUB exp1 exp .)
    AND             reduce using rule 92 (exp -> term exp2 SUB exp1 exp .)
    RPAREN          reduce using rule 92 (exp -> term exp2 SUB exp1 exp .)
    COMMA           reduce using rule 92 (exp -> term exp2 SUB exp1 exp .)
    SEMICLN         reduce using rule 92 (exp -> term exp2 SUB exp1 exp .)


state 185

    (93) exp -> term exp2 SUM exp1 exp .
    RSQUARE         reduce using rule 93 (exp -> term exp2 SUM exp1 exp .)
    EQUAL_TO        reduce using rule 93 (exp -> term exp2 SUM exp1 exp .)
    DIFFERENT_TO    reduce using rule 93 (exp -> term exp2 SUM exp1 exp .)
    LESS_OR_EQ_THAN reduce using rule 93 (exp -> term exp2 SUM exp1 exp .)
    MORE_OR_EQ_THAN reduce using rule 93 (exp -> term exp2 SUM exp1 exp .)
    LESS_THAN       reduce using rule 93 (exp -> term exp2 SUM exp1 exp .)
    MORE_THAN       reduce using rule 93 (exp -> term exp2 SUM exp1 exp .)
    OR              reduce using rule 93 (exp -> term exp2 SUM exp1 exp .)
    AND             reduce using rule 93 (exp -> term exp2 SUM exp1 exp .)
    RPAREN          reduce using rule 93 (exp -> term exp2 SUM exp1 exp .)
    COMMA           reduce using rule 93 (exp -> term exp2 SUM exp1 exp .)
    SEMICLN         reduce using rule 93 (exp -> term exp2 SUM exp1 exp .)


state 186

    (97) term -> factor term2 DIV term1 term .
    SUB             reduce using rule 97 (term -> factor term2 DIV term1 term .)
    SUM             reduce using rule 97 (term -> factor term2 DIV term1 term .)
    RSQUARE         reduce using rule 97 (term -> factor term2 DIV term1 term .)
    EQUAL_TO        reduce using rule 97 (term -> factor term2 DIV term1 term .)
    DIFFERENT_TO    reduce using rule 97 (term -> factor term2 DIV term1 term .)
    LESS_OR_EQ_THAN reduce using rule 97 (term -> factor term2 DIV term1 term .)
    MORE_OR_EQ_THAN reduce using rule 97 (term -> factor term2 DIV term1 term .)
    LESS_THAN       reduce using rule 97 (term -> factor term2 DIV term1 term .)
    MORE_THAN       reduce using rule 97 (term -> factor term2 DIV term1 term .)
    OR              reduce using rule 97 (term -> factor term2 DIV term1 term .)
    AND             reduce using rule 97 (term -> factor term2 DIV term1 term .)
    RPAREN          reduce using rule 97 (term -> factor term2 DIV term1 term .)
    COMMA           reduce using rule 97 (term -> factor term2 DIV term1 term .)
    SEMICLN         reduce using rule 97 (term -> factor term2 DIV term1 term .)


state 187

    (98) term -> factor term2 MULT term1 term .
    SUB             reduce using rule 98 (term -> factor term2 MULT term1 term .)
    SUM             reduce using rule 98 (term -> factor term2 MULT term1 term .)
    RSQUARE         reduce using rule 98 (term -> factor term2 MULT term1 term .)
    EQUAL_TO        reduce using rule 98 (term -> factor term2 MULT term1 term .)
    DIFFERENT_TO    reduce using rule 98 (term -> factor term2 MULT term1 term .)
    LESS_OR_EQ_THAN reduce using rule 98 (term -> factor term2 MULT term1 term .)
    MORE_OR_EQ_THAN reduce using rule 98 (term -> factor term2 MULT term1 term .)
    LESS_THAN       reduce using rule 98 (term -> factor term2 MULT term1 term .)
    MORE_THAN       reduce using rule 98 (term -> factor term2 MULT term1 term .)
    OR              reduce using rule 98 (term -> factor term2 MULT term1 term .)
    AND             reduce using rule 98 (term -> factor term2 MULT term1 term .)
    RPAREN          reduce using rule 98 (term -> factor term2 MULT term1 term .)
    COMMA           reduce using rule 98 (term -> factor term2 MULT term1 term .)
    SEMICLN         reduce using rule 98 (term -> factor term2 MULT term1 term .)


state 188

    (109) factor -> ID fact1 LPAREN logic multiexp . RPAREN
    RPAREN          shift and go to state 213


state 189

    (116) multiexp -> empty .
    RPAREN          reduce using rule 116 (multiexp -> empty .)


state 190

    (117) multiexp -> COMMA . paren multiexp
    (72) paren -> . logic
    (73) paren -> . LPAREN paren1 logic paren2 RPAREN paren3 logic
    (77) logic -> . rel log2 OR log1 logic
    (78) logic -> . rel log2 AND log1 logic
    (79) logic -> . rel log2
    (88) rel -> . exp rel2 relop rel1 rel
    (89) rel -> . exp rel2
    (92) exp -> . term exp2 SUB exp1 exp
    (93) exp -> . term exp2 SUM exp1 exp
    (94) exp -> . term exp2
    (97) term -> . factor term2 DIV term1 term
    (98) term -> . factor term2 MULT term1 term
    (99) term -> . factor term2
    (103) factor -> . func_exp
    (104) factor -> . FALSE ctes4
    (105) factor -> . TRUE ctes4
    (106) factor -> . CTE_STR ctes3
    (107) factor -> . CTE_FLT ctes2
    (108) factor -> . CTE_NUM ctes1
    (109) factor -> . ID fact1 LPAREN logic multiexp RPAREN
    (110) factor -> . ID fact1 arr
    (52) func_exp -> . ID fc1 LPAREN fc2 arg fc4 RPAREN fc5 fexp
    LPAREN          shift and go to state 93
    FALSE           shift and go to state 85
    TRUE            shift and go to state 86
    CTE_STR         shift and go to state 87
    CTE_FLT         shift and go to state 88
    CTE_NUM         shift and go to state 89
    ID              shift and go to state 90

    paren                          shift and go to state 214
    logic                          shift and go to state 95
    rel                            shift and go to state 96
    exp                            shift and go to state 97
    term                           shift and go to state 82
    factor                         shift and go to state 83
    func_exp                       shift and go to state 84

state 191

    (52) func_exp -> ID fc1 LPAREN fc2 arg . fc4 RPAREN fc5 fexp
    (58) fc4 -> .
    RPAREN          reduce using rule 58 (fc4 -> .)

    fc4                            shift and go to state 215

state 192

    (124) while_stmnt -> WHILE while1 LPAREN paren while2 RPAREN stmnt . while3 END
    (127) while3 -> .
    END             reduce using rule 127 (while3 -> .)

    while3                         shift and go to state 216

state 193

    (73) paren -> LPAREN paren1 logic paren2 RPAREN . paren3 logic
    (76) paren3 -> .
    FALSE           reduce using rule 76 (paren3 -> .)
    TRUE            reduce using rule 76 (paren3 -> .)
    CTE_STR         reduce using rule 76 (paren3 -> .)
    CTE_FLT         reduce using rule 76 (paren3 -> .)
    CTE_NUM         reduce using rule 76 (paren3 -> .)
    ID              reduce using rule 76 (paren3 -> .)

    paren3                         shift and go to state 217

state 194

    (118) if_stmnt -> IF LPAREN paren if1 RPAREN stmnt else_stmnt . END if2
    END             shift and go to state 218


state 195

    (121) else_stmnt -> empty .
    END             reduce using rule 121 (else_stmnt -> empty .)


state 196

    (122) else_stmnt -> ELSE . else1 stmnt
    (123) else1 -> .
    WHILE           reduce using rule 123 (else1 -> .)
    IF              reduce using rule 123 (else1 -> .)
    WRITE           reduce using rule 123 (else1 -> .)
    READ            reduce using rule 123 (else1 -> .)
    RETURN          reduce using rule 123 (else1 -> .)
    ID              reduce using rule 123 (else1 -> .)
    END             reduce using rule 123 (else1 -> .)

    else1                          shift and go to state 219

state 197

    (77) logic -> rel log2 OR log1 logic .
    RPAREN          reduce using rule 77 (logic -> rel log2 OR log1 logic .)
    COMMA           reduce using rule 77 (logic -> rel log2 OR log1 logic .)
    SEMICLN         reduce using rule 77 (logic -> rel log2 OR log1 logic .)


state 198

    (78) logic -> rel log2 AND log1 logic .
    RPAREN          reduce using rule 78 (logic -> rel log2 AND log1 logic .)
    COMMA           reduce using rule 78 (logic -> rel log2 AND log1 logic .)
    SEMICLN         reduce using rule 78 (logic -> rel log2 AND log1 logic .)


state 199

    (88) rel -> exp rel2 relop rel1 rel .
    OR              reduce using rule 88 (rel -> exp rel2 relop rel1 rel .)
    AND             reduce using rule 88 (rel -> exp rel2 relop rel1 rel .)
    RPAREN          reduce using rule 88 (rel -> exp rel2 relop rel1 rel .)
    COMMA           reduce using rule 88 (rel -> exp rel2 relop rel1 rel .)
    SEMICLN         reduce using rule 88 (rel -> exp rel2 relop rel1 rel .)


state 200

    (66) write_stmnt -> WRITE io1 LPAREN paren io2 multio RPAREN . io3 SEMICLN
    (71) io3 -> .
    SEMICLN         reduce using rule 71 (io3 -> .)

    io3                            shift and go to state 220

state 201

    (65) read_stmnt -> READ io1 LPAREN paren multio io2 RPAREN . io3 SEMICLN
    (71) io3 -> .
    SEMICLN         reduce using rule 71 (io3 -> .)

    io3                            shift and go to state 221

state 202

    (68) multio -> COMMA paren io2 . multio
    (67) multio -> .
    (68) multio -> . COMMA paren io2 multio
    RPAREN          reduce using rule 67 (multio -> .)
    COMMA           shift and go to state 153

    multio                         shift and go to state 222

state 203

    (62) ret_stmnt -> RETURN LPAREN paren retval RPAREN rettrue SEMICLN .
    WHILE           reduce using rule 62 (ret_stmnt -> RETURN LPAREN paren retval RPAREN rettrue SEMICLN .)
    IF              reduce using rule 62 (ret_stmnt -> RETURN LPAREN paren retval RPAREN rettrue SEMICLN .)
    WRITE           reduce using rule 62 (ret_stmnt -> RETURN LPAREN paren retval RPAREN rettrue SEMICLN .)
    READ            reduce using rule 62 (ret_stmnt -> RETURN LPAREN paren retval RPAREN rettrue SEMICLN .)
    RETURN          reduce using rule 62 (ret_stmnt -> RETURN LPAREN paren retval RPAREN rettrue SEMICLN .)
    ID              reduce using rule 62 (ret_stmnt -> RETURN LPAREN paren retval RPAREN rettrue SEMICLN .)
    $end            reduce using rule 62 (ret_stmnt -> RETURN LPAREN paren retval RPAREN rettrue SEMICLN .)
    ELSE            reduce using rule 62 (ret_stmnt -> RETURN LPAREN paren retval RPAREN rettrue SEMICLN .)
    END             reduce using rule 62 (ret_stmnt -> RETURN LPAREN paren retval RPAREN rettrue SEMICLN .)
    RCURLY          reduce using rule 62 (ret_stmnt -> RETURN LPAREN paren retval RPAREN rettrue SEMICLN .)


state 204

    (51) func_stmnt -> ID fc1 LPAREN fc2 arg fc4 RPAREN . fc5 SEMICLN
    (59) fc5 -> .
    SEMICLN         reduce using rule 59 (fc5 -> .)

    fc5                            shift and go to state 223

state 205

    (56) arg -> paren fc3 multiarg .
    RPAREN          reduce using rule 56 (arg -> paren fc3 multiarg .)
    COMMA           reduce using rule 56 (arg -> paren fc3 multiarg .)


state 206

    (60) multiarg -> empty .
    COMMA           reduce using rule 60 (multiarg -> empty .)
    RPAREN          reduce using rule 60 (multiarg -> empty .)


state 207

    (61) multiarg -> COMMA . arg multiarg
    (55) arg -> . empty
    (56) arg -> . paren fc3 multiarg
    (128) empty -> .
    (72) paren -> . logic
    (73) paren -> . LPAREN paren1 logic paren2 RPAREN paren3 logic
    (77) logic -> . rel log2 OR log1 logic
    (78) logic -> . rel log2 AND log1 logic
    (79) logic -> . rel log2
    (88) rel -> . exp rel2 relop rel1 rel
    (89) rel -> . exp rel2
    (92) exp -> . term exp2 SUB exp1 exp
    (93) exp -> . term exp2 SUM exp1 exp
    (94) exp -> . term exp2
    (97) term -> . factor term2 DIV term1 term
    (98) term -> . factor term2 MULT term1 term
    (99) term -> . factor term2
    (103) factor -> . func_exp
    (104) factor -> . FALSE ctes4
    (105) factor -> . TRUE ctes4
    (106) factor -> . CTE_STR ctes3
    (107) factor -> . CTE_FLT ctes2
    (108) factor -> . CTE_NUM ctes1
    (109) factor -> . ID fact1 LPAREN logic multiexp RPAREN
    (110) factor -> . ID fact1 arr
    (52) func_exp -> . ID fc1 LPAREN fc2 arg fc4 RPAREN fc5 fexp
    COMMA           reduce using rule 128 (empty -> .)
    RPAREN          reduce using rule 128 (empty -> .)
    LPAREN          shift and go to state 93
    FALSE           shift and go to state 85
    TRUE            shift and go to state 86
    CTE_STR         shift and go to state 87
    CTE_FLT         shift and go to state 88
    CTE_NUM         shift and go to state 89
    ID              shift and go to state 90

    arg                            shift and go to state 224
    empty                          shift and go to state 156
    paren                          shift and go to state 157
    logic                          shift and go to state 95
    rel                            shift and go to state 96
    exp                            shift and go to state 97
    term                           shift and go to state 82
    factor                         shift and go to state 83
    func_exp                       shift and go to state 84

state 208

    (47) ass_stmnt -> ID ass1 arr ASS ass2 paren ass3 . SEMICLN
    SEMICLN         shift and go to state 225


state 209

    (21) funcdecl -> FUNC tipofunc func1 ID func2 LPAREN param RPAREN func3 LCURLY varsdecl func4 . stmnt RCURLY resetvarcont funcdecl
    (38) stmnt -> . empty
    (39) stmnt -> . while_stmnt stmnt
    (40) stmnt -> . if_stmnt stmnt
    (41) stmnt -> . write_stmnt stmnt
    (42) stmnt -> . read_stmnt stmnt
    (43) stmnt -> . ret_stmnt stmnt
    (44) stmnt -> . func_stmnt stmnt
    (45) stmnt -> . ass_stmnt stmnt
    (128) empty -> .
    (124) while_stmnt -> . WHILE while1 LPAREN paren while2 RPAREN stmnt while3 END
    (118) if_stmnt -> . IF LPAREN paren if1 RPAREN stmnt else_stmnt END if2
    (66) write_stmnt -> . WRITE io1 LPAREN paren io2 multio RPAREN io3 SEMICLN
    (65) read_stmnt -> . READ io1 LPAREN paren multio io2 RPAREN io3 SEMICLN
    (62) ret_stmnt -> . RETURN LPAREN paren retval RPAREN rettrue SEMICLN
    (51) func_stmnt -> . ID fc1 LPAREN fc2 arg fc4 RPAREN fc5 SEMICLN
    (46) ass_stmnt -> . ID arr ASS func_stmnt SEMICLN
    (47) ass_stmnt -> . ID ass1 arr ASS ass2 paren ass3 SEMICLN
    RCURLY          reduce using rule 128 (empty -> .)
    WHILE           shift and go to state 50
    IF              shift and go to state 51
    WRITE           shift and go to state 52
    READ            shift and go to state 53
    RETURN          shift and go to state 54
    ID              shift and go to state 55

    stmnt                          shift and go to state 226
    empty                          shift and go to state 42
    while_stmnt                    shift and go to state 43
    if_stmnt                       shift and go to state 44
    write_stmnt                    shift and go to state 45
    read_stmnt                     shift and go to state 46
    ret_stmnt                      shift and go to state 47
    func_stmnt                     shift and go to state 48
    ass_stmnt                      shift and go to state 49

state 210

    (30) param -> tipo param1 COLON ID param2 multiparam .
    RPAREN          reduce using rule 30 (param -> tipo param1 COLON ID param2 multiparam .)


state 211

    (33) multiparam -> empty .
    RPAREN          reduce using rule 33 (multiparam -> empty .)


state 212

    (34) multiparam -> COMMA . param
    (29) param -> . empty
    (30) param -> . tipo param1 COLON ID param2 multiparam
    (128) empty -> .
    (14) tipo -> . BOOL
    (15) tipo -> . CHAR
    (16) tipo -> . FLOAT
    (17) tipo -> . INT
    RPAREN          reduce using rule 128 (empty -> .)
    BOOL            shift and go to state 19
    CHAR            shift and go to state 20
    FLOAT           shift and go to state 21
    INT             shift and go to state 22

    param                          shift and go to state 227
    empty                          shift and go to state 78
    tipo                           shift and go to state 79

state 213

    (109) factor -> ID fact1 LPAREN logic multiexp RPAREN .
    DIV             reduce using rule 109 (factor -> ID fact1 LPAREN logic multiexp RPAREN .)
    MULT            reduce using rule 109 (factor -> ID fact1 LPAREN logic multiexp RPAREN .)
    SUB             reduce using rule 109 (factor -> ID fact1 LPAREN logic multiexp RPAREN .)
    SUM             reduce using rule 109 (factor -> ID fact1 LPAREN logic multiexp RPAREN .)
    RSQUARE         reduce using rule 109 (factor -> ID fact1 LPAREN logic multiexp RPAREN .)
    EQUAL_TO        reduce using rule 109 (factor -> ID fact1 LPAREN logic multiexp RPAREN .)
    DIFFERENT_TO    reduce using rule 109 (factor -> ID fact1 LPAREN logic multiexp RPAREN .)
    LESS_OR_EQ_THAN reduce using rule 109 (factor -> ID fact1 LPAREN logic multiexp RPAREN .)
    MORE_OR_EQ_THAN reduce using rule 109 (factor -> ID fact1 LPAREN logic multiexp RPAREN .)
    LESS_THAN       reduce using rule 109 (factor -> ID fact1 LPAREN logic multiexp RPAREN .)
    MORE_THAN       reduce using rule 109 (factor -> ID fact1 LPAREN logic multiexp RPAREN .)
    OR              reduce using rule 109 (factor -> ID fact1 LPAREN logic multiexp RPAREN .)
    AND             reduce using rule 109 (factor -> ID fact1 LPAREN logic multiexp RPAREN .)
    RPAREN          reduce using rule 109 (factor -> ID fact1 LPAREN logic multiexp RPAREN .)
    COMMA           reduce using rule 109 (factor -> ID fact1 LPAREN logic multiexp RPAREN .)
    SEMICLN         reduce using rule 109 (factor -> ID fact1 LPAREN logic multiexp RPAREN .)


state 214

    (117) multiexp -> COMMA paren . multiexp
    (116) multiexp -> . empty
    (117) multiexp -> . COMMA paren multiexp
    (128) empty -> .
    COMMA           shift and go to state 190
    RPAREN          reduce using rule 128 (empty -> .)

    multiexp                       shift and go to state 228
    empty                          shift and go to state 189

state 215

    (52) func_exp -> ID fc1 LPAREN fc2 arg fc4 . RPAREN fc5 fexp
    RPAREN          shift and go to state 229


state 216

    (124) while_stmnt -> WHILE while1 LPAREN paren while2 RPAREN stmnt while3 . END
    END             shift and go to state 230


state 217

    (73) paren -> LPAREN paren1 logic paren2 RPAREN paren3 . logic
    (77) logic -> . rel log2 OR log1 logic
    (78) logic -> . rel log2 AND log1 logic
    (79) logic -> . rel log2
    (88) rel -> . exp rel2 relop rel1 rel
    (89) rel -> . exp rel2
    (92) exp -> . term exp2 SUB exp1 exp
    (93) exp -> . term exp2 SUM exp1 exp
    (94) exp -> . term exp2
    (97) term -> . factor term2 DIV term1 term
    (98) term -> . factor term2 MULT term1 term
    (99) term -> . factor term2
    (103) factor -> . func_exp
    (104) factor -> . FALSE ctes4
    (105) factor -> . TRUE ctes4
    (106) factor -> . CTE_STR ctes3
    (107) factor -> . CTE_FLT ctes2
    (108) factor -> . CTE_NUM ctes1
    (109) factor -> . ID fact1 LPAREN logic multiexp RPAREN
    (110) factor -> . ID fact1 arr
    (52) func_exp -> . ID fc1 LPAREN fc2 arg fc4 RPAREN fc5 fexp
    FALSE           shift and go to state 85
    TRUE            shift and go to state 86
    CTE_STR         shift and go to state 87
    CTE_FLT         shift and go to state 88
    CTE_NUM         shift and go to state 89
    ID              shift and go to state 90

    logic                          shift and go to state 231
    rel                            shift and go to state 96
    exp                            shift and go to state 97
    term                           shift and go to state 82
    factor                         shift and go to state 83
    func_exp                       shift and go to state 84

state 218

    (118) if_stmnt -> IF LPAREN paren if1 RPAREN stmnt else_stmnt END . if2
    (120) if2 -> .
    WHILE           reduce using rule 120 (if2 -> .)
    IF              reduce using rule 120 (if2 -> .)
    WRITE           reduce using rule 120 (if2 -> .)
    READ            reduce using rule 120 (if2 -> .)
    RETURN          reduce using rule 120 (if2 -> .)
    ID              reduce using rule 120 (if2 -> .)
    $end            reduce using rule 120 (if2 -> .)
    ELSE            reduce using rule 120 (if2 -> .)
    END             reduce using rule 120 (if2 -> .)
    RCURLY          reduce using rule 120 (if2 -> .)

    if2                            shift and go to state 232

state 219

    (122) else_stmnt -> ELSE else1 . stmnt
    (38) stmnt -> . empty
    (39) stmnt -> . while_stmnt stmnt
    (40) stmnt -> . if_stmnt stmnt
    (41) stmnt -> . write_stmnt stmnt
    (42) stmnt -> . read_stmnt stmnt
    (43) stmnt -> . ret_stmnt stmnt
    (44) stmnt -> . func_stmnt stmnt
    (45) stmnt -> . ass_stmnt stmnt
    (128) empty -> .
    (124) while_stmnt -> . WHILE while1 LPAREN paren while2 RPAREN stmnt while3 END
    (118) if_stmnt -> . IF LPAREN paren if1 RPAREN stmnt else_stmnt END if2
    (66) write_stmnt -> . WRITE io1 LPAREN paren io2 multio RPAREN io3 SEMICLN
    (65) read_stmnt -> . READ io1 LPAREN paren multio io2 RPAREN io3 SEMICLN
    (62) ret_stmnt -> . RETURN LPAREN paren retval RPAREN rettrue SEMICLN
    (51) func_stmnt -> . ID fc1 LPAREN fc2 arg fc4 RPAREN fc5 SEMICLN
    (46) ass_stmnt -> . ID arr ASS func_stmnt SEMICLN
    (47) ass_stmnt -> . ID ass1 arr ASS ass2 paren ass3 SEMICLN
    END             reduce using rule 128 (empty -> .)
    WHILE           shift and go to state 50
    IF              shift and go to state 51
    WRITE           shift and go to state 52
    READ            shift and go to state 53
    RETURN          shift and go to state 54
    ID              shift and go to state 55

    stmnt                          shift and go to state 233
    empty                          shift and go to state 42
    while_stmnt                    shift and go to state 43
    if_stmnt                       shift and go to state 44
    write_stmnt                    shift and go to state 45
    read_stmnt                     shift and go to state 46
    ret_stmnt                      shift and go to state 47
    func_stmnt                     shift and go to state 48
    ass_stmnt                      shift and go to state 49

state 220

    (66) write_stmnt -> WRITE io1 LPAREN paren io2 multio RPAREN io3 . SEMICLN
    SEMICLN         shift and go to state 234


state 221

    (65) read_stmnt -> READ io1 LPAREN paren multio io2 RPAREN io3 . SEMICLN
    SEMICLN         shift and go to state 235


state 222

    (68) multio -> COMMA paren io2 multio .
    RPAREN          reduce using rule 68 (multio -> COMMA paren io2 multio .)


state 223

    (51) func_stmnt -> ID fc1 LPAREN fc2 arg fc4 RPAREN fc5 . SEMICLN
    SEMICLN         shift and go to state 236


state 224

    (61) multiarg -> COMMA arg . multiarg
    (60) multiarg -> . empty
    (61) multiarg -> . COMMA arg multiarg
    (128) empty -> .
  ! shift/reduce conflict for COMMA resolved as shift
    COMMA           shift and go to state 207
    RPAREN          reduce using rule 128 (empty -> .)

    multiarg                       shift and go to state 237
    empty                          shift and go to state 206

state 225

    (47) ass_stmnt -> ID ass1 arr ASS ass2 paren ass3 SEMICLN .
    WHILE           reduce using rule 47 (ass_stmnt -> ID ass1 arr ASS ass2 paren ass3 SEMICLN .)
    IF              reduce using rule 47 (ass_stmnt -> ID ass1 arr ASS ass2 paren ass3 SEMICLN .)
    WRITE           reduce using rule 47 (ass_stmnt -> ID ass1 arr ASS ass2 paren ass3 SEMICLN .)
    READ            reduce using rule 47 (ass_stmnt -> ID ass1 arr ASS ass2 paren ass3 SEMICLN .)
    RETURN          reduce using rule 47 (ass_stmnt -> ID ass1 arr ASS ass2 paren ass3 SEMICLN .)
    ID              reduce using rule 47 (ass_stmnt -> ID ass1 arr ASS ass2 paren ass3 SEMICLN .)
    $end            reduce using rule 47 (ass_stmnt -> ID ass1 arr ASS ass2 paren ass3 SEMICLN .)
    ELSE            reduce using rule 47 (ass_stmnt -> ID ass1 arr ASS ass2 paren ass3 SEMICLN .)
    END             reduce using rule 47 (ass_stmnt -> ID ass1 arr ASS ass2 paren ass3 SEMICLN .)
    RCURLY          reduce using rule 47 (ass_stmnt -> ID ass1 arr ASS ass2 paren ass3 SEMICLN .)


state 226

    (21) funcdecl -> FUNC tipofunc func1 ID func2 LPAREN param RPAREN func3 LCURLY varsdecl func4 stmnt . RCURLY resetvarcont funcdecl
    RCURLY          shift and go to state 238


state 227

    (34) multiparam -> COMMA param .
    RPAREN          reduce using rule 34 (multiparam -> COMMA param .)


state 228

    (117) multiexp -> COMMA paren multiexp .
    RPAREN          reduce using rule 117 (multiexp -> COMMA paren multiexp .)


state 229

    (52) func_exp -> ID fc1 LPAREN fc2 arg fc4 RPAREN . fc5 fexp
    (59) fc5 -> .
    DIV             reduce using rule 59 (fc5 -> .)
    MULT            reduce using rule 59 (fc5 -> .)
    SUB             reduce using rule 59 (fc5 -> .)
    SUM             reduce using rule 59 (fc5 -> .)
    RSQUARE         reduce using rule 59 (fc5 -> .)
    EQUAL_TO        reduce using rule 59 (fc5 -> .)
    DIFFERENT_TO    reduce using rule 59 (fc5 -> .)
    LESS_OR_EQ_THAN reduce using rule 59 (fc5 -> .)
    MORE_OR_EQ_THAN reduce using rule 59 (fc5 -> .)
    LESS_THAN       reduce using rule 59 (fc5 -> .)
    MORE_THAN       reduce using rule 59 (fc5 -> .)
    OR              reduce using rule 59 (fc5 -> .)
    AND             reduce using rule 59 (fc5 -> .)
    RPAREN          reduce using rule 59 (fc5 -> .)
    COMMA           reduce using rule 59 (fc5 -> .)
    SEMICLN         reduce using rule 59 (fc5 -> .)

    fc5                            shift and go to state 239

state 230

    (124) while_stmnt -> WHILE while1 LPAREN paren while2 RPAREN stmnt while3 END .
    WHILE           reduce using rule 124 (while_stmnt -> WHILE while1 LPAREN paren while2 RPAREN stmnt while3 END .)
    IF              reduce using rule 124 (while_stmnt -> WHILE while1 LPAREN paren while2 RPAREN stmnt while3 END .)
    WRITE           reduce using rule 124 (while_stmnt -> WHILE while1 LPAREN paren while2 RPAREN stmnt while3 END .)
    READ            reduce using rule 124 (while_stmnt -> WHILE while1 LPAREN paren while2 RPAREN stmnt while3 END .)
    RETURN          reduce using rule 124 (while_stmnt -> WHILE while1 LPAREN paren while2 RPAREN stmnt while3 END .)
    ID              reduce using rule 124 (while_stmnt -> WHILE while1 LPAREN paren while2 RPAREN stmnt while3 END .)
    $end            reduce using rule 124 (while_stmnt -> WHILE while1 LPAREN paren while2 RPAREN stmnt while3 END .)
    ELSE            reduce using rule 124 (while_stmnt -> WHILE while1 LPAREN paren while2 RPAREN stmnt while3 END .)
    END             reduce using rule 124 (while_stmnt -> WHILE while1 LPAREN paren while2 RPAREN stmnt while3 END .)
    RCURLY          reduce using rule 124 (while_stmnt -> WHILE while1 LPAREN paren while2 RPAREN stmnt while3 END .)


state 231

    (73) paren -> LPAREN paren1 logic paren2 RPAREN paren3 logic .
    RPAREN          reduce using rule 73 (paren -> LPAREN paren1 logic paren2 RPAREN paren3 logic .)
    COMMA           reduce using rule 73 (paren -> LPAREN paren1 logic paren2 RPAREN paren3 logic .)
    SEMICLN         reduce using rule 73 (paren -> LPAREN paren1 logic paren2 RPAREN paren3 logic .)


state 232

    (118) if_stmnt -> IF LPAREN paren if1 RPAREN stmnt else_stmnt END if2 .
    WHILE           reduce using rule 118 (if_stmnt -> IF LPAREN paren if1 RPAREN stmnt else_stmnt END if2 .)
    IF              reduce using rule 118 (if_stmnt -> IF LPAREN paren if1 RPAREN stmnt else_stmnt END if2 .)
    WRITE           reduce using rule 118 (if_stmnt -> IF LPAREN paren if1 RPAREN stmnt else_stmnt END if2 .)
    READ            reduce using rule 118 (if_stmnt -> IF LPAREN paren if1 RPAREN stmnt else_stmnt END if2 .)
    RETURN          reduce using rule 118 (if_stmnt -> IF LPAREN paren if1 RPAREN stmnt else_stmnt END if2 .)
    ID              reduce using rule 118 (if_stmnt -> IF LPAREN paren if1 RPAREN stmnt else_stmnt END if2 .)
    $end            reduce using rule 118 (if_stmnt -> IF LPAREN paren if1 RPAREN stmnt else_stmnt END if2 .)
    ELSE            reduce using rule 118 (if_stmnt -> IF LPAREN paren if1 RPAREN stmnt else_stmnt END if2 .)
    END             reduce using rule 118 (if_stmnt -> IF LPAREN paren if1 RPAREN stmnt else_stmnt END if2 .)
    RCURLY          reduce using rule 118 (if_stmnt -> IF LPAREN paren if1 RPAREN stmnt else_stmnt END if2 .)


state 233

    (122) else_stmnt -> ELSE else1 stmnt .
    END             reduce using rule 122 (else_stmnt -> ELSE else1 stmnt .)


state 234

    (66) write_stmnt -> WRITE io1 LPAREN paren io2 multio RPAREN io3 SEMICLN .
    WHILE           reduce using rule 66 (write_stmnt -> WRITE io1 LPAREN paren io2 multio RPAREN io3 SEMICLN .)
    IF              reduce using rule 66 (write_stmnt -> WRITE io1 LPAREN paren io2 multio RPAREN io3 SEMICLN .)
    WRITE           reduce using rule 66 (write_stmnt -> WRITE io1 LPAREN paren io2 multio RPAREN io3 SEMICLN .)
    READ            reduce using rule 66 (write_stmnt -> WRITE io1 LPAREN paren io2 multio RPAREN io3 SEMICLN .)
    RETURN          reduce using rule 66 (write_stmnt -> WRITE io1 LPAREN paren io2 multio RPAREN io3 SEMICLN .)
    ID              reduce using rule 66 (write_stmnt -> WRITE io1 LPAREN paren io2 multio RPAREN io3 SEMICLN .)
    $end            reduce using rule 66 (write_stmnt -> WRITE io1 LPAREN paren io2 multio RPAREN io3 SEMICLN .)
    ELSE            reduce using rule 66 (write_stmnt -> WRITE io1 LPAREN paren io2 multio RPAREN io3 SEMICLN .)
    END             reduce using rule 66 (write_stmnt -> WRITE io1 LPAREN paren io2 multio RPAREN io3 SEMICLN .)
    RCURLY          reduce using rule 66 (write_stmnt -> WRITE io1 LPAREN paren io2 multio RPAREN io3 SEMICLN .)


state 235

    (65) read_stmnt -> READ io1 LPAREN paren multio io2 RPAREN io3 SEMICLN .
    WHILE           reduce using rule 65 (read_stmnt -> READ io1 LPAREN paren multio io2 RPAREN io3 SEMICLN .)
    IF              reduce using rule 65 (read_stmnt -> READ io1 LPAREN paren multio io2 RPAREN io3 SEMICLN .)
    WRITE           reduce using rule 65 (read_stmnt -> READ io1 LPAREN paren multio io2 RPAREN io3 SEMICLN .)
    READ            reduce using rule 65 (read_stmnt -> READ io1 LPAREN paren multio io2 RPAREN io3 SEMICLN .)
    RETURN          reduce using rule 65 (read_stmnt -> READ io1 LPAREN paren multio io2 RPAREN io3 SEMICLN .)
    ID              reduce using rule 65 (read_stmnt -> READ io1 LPAREN paren multio io2 RPAREN io3 SEMICLN .)
    $end            reduce using rule 65 (read_stmnt -> READ io1 LPAREN paren multio io2 RPAREN io3 SEMICLN .)
    ELSE            reduce using rule 65 (read_stmnt -> READ io1 LPAREN paren multio io2 RPAREN io3 SEMICLN .)
    END             reduce using rule 65 (read_stmnt -> READ io1 LPAREN paren multio io2 RPAREN io3 SEMICLN .)
    RCURLY          reduce using rule 65 (read_stmnt -> READ io1 LPAREN paren multio io2 RPAREN io3 SEMICLN .)


state 236

    (51) func_stmnt -> ID fc1 LPAREN fc2 arg fc4 RPAREN fc5 SEMICLN .
    WHILE           reduce using rule 51 (func_stmnt -> ID fc1 LPAREN fc2 arg fc4 RPAREN fc5 SEMICLN .)
    IF              reduce using rule 51 (func_stmnt -> ID fc1 LPAREN fc2 arg fc4 RPAREN fc5 SEMICLN .)
    WRITE           reduce using rule 51 (func_stmnt -> ID fc1 LPAREN fc2 arg fc4 RPAREN fc5 SEMICLN .)
    READ            reduce using rule 51 (func_stmnt -> ID fc1 LPAREN fc2 arg fc4 RPAREN fc5 SEMICLN .)
    RETURN          reduce using rule 51 (func_stmnt -> ID fc1 LPAREN fc2 arg fc4 RPAREN fc5 SEMICLN .)
    ID              reduce using rule 51 (func_stmnt -> ID fc1 LPAREN fc2 arg fc4 RPAREN fc5 SEMICLN .)
    $end            reduce using rule 51 (func_stmnt -> ID fc1 LPAREN fc2 arg fc4 RPAREN fc5 SEMICLN .)
    ELSE            reduce using rule 51 (func_stmnt -> ID fc1 LPAREN fc2 arg fc4 RPAREN fc5 SEMICLN .)
    END             reduce using rule 51 (func_stmnt -> ID fc1 LPAREN fc2 arg fc4 RPAREN fc5 SEMICLN .)
    RCURLY          reduce using rule 51 (func_stmnt -> ID fc1 LPAREN fc2 arg fc4 RPAREN fc5 SEMICLN .)
    SEMICLN         reduce using rule 51 (func_stmnt -> ID fc1 LPAREN fc2 arg fc4 RPAREN fc5 SEMICLN .)


state 237

    (61) multiarg -> COMMA arg multiarg .
    COMMA           reduce using rule 61 (multiarg -> COMMA arg multiarg .)
    RPAREN          reduce using rule 61 (multiarg -> COMMA arg multiarg .)


state 238

    (21) funcdecl -> FUNC tipofunc func1 ID func2 LPAREN param RPAREN func3 LCURLY varsdecl func4 stmnt RCURLY . resetvarcont funcdecl
    (26) resetvarcont -> .
    FUNC            reduce using rule 26 (resetvarcont -> .)
    MAIN            reduce using rule 26 (resetvarcont -> .)

    resetvarcont                   shift and go to state 240

state 239

    (52) func_exp -> ID fc1 LPAREN fc2 arg fc4 RPAREN fc5 . fexp
    (102) fexp -> .
    DIV             reduce using rule 102 (fexp -> .)
    MULT            reduce using rule 102 (fexp -> .)
    SUB             reduce using rule 102 (fexp -> .)
    SUM             reduce using rule 102 (fexp -> .)
    RSQUARE         reduce using rule 102 (fexp -> .)
    EQUAL_TO        reduce using rule 102 (fexp -> .)
    DIFFERENT_TO    reduce using rule 102 (fexp -> .)
    LESS_OR_EQ_THAN reduce using rule 102 (fexp -> .)
    MORE_OR_EQ_THAN reduce using rule 102 (fexp -> .)
    LESS_THAN       reduce using rule 102 (fexp -> .)
    MORE_THAN       reduce using rule 102 (fexp -> .)
    OR              reduce using rule 102 (fexp -> .)
    AND             reduce using rule 102 (fexp -> .)
    RPAREN          reduce using rule 102 (fexp -> .)
    COMMA           reduce using rule 102 (fexp -> .)
    SEMICLN         reduce using rule 102 (fexp -> .)

    fexp                           shift and go to state 241

state 240

    (21) funcdecl -> FUNC tipofunc func1 ID func2 LPAREN param RPAREN func3 LCURLY varsdecl func4 stmnt RCURLY resetvarcont . funcdecl
    (20) funcdecl -> . empty
    (21) funcdecl -> . FUNC tipofunc func1 ID func2 LPAREN param RPAREN func3 LCURLY varsdecl func4 stmnt RCURLY resetvarcont funcdecl
    (128) empty -> .
    FUNC            shift and go to state 12
    MAIN            reduce using rule 128 (empty -> .)

    funcdecl                       shift and go to state 242
    empty                          shift and go to state 11

state 241

    (52) func_exp -> ID fc1 LPAREN fc2 arg fc4 RPAREN fc5 fexp .
    DIV             reduce using rule 52 (func_exp -> ID fc1 LPAREN fc2 arg fc4 RPAREN fc5 fexp .)
    MULT            reduce using rule 52 (func_exp -> ID fc1 LPAREN fc2 arg fc4 RPAREN fc5 fexp .)
    SUB             reduce using rule 52 (func_exp -> ID fc1 LPAREN fc2 arg fc4 RPAREN fc5 fexp .)
    SUM             reduce using rule 52 (func_exp -> ID fc1 LPAREN fc2 arg fc4 RPAREN fc5 fexp .)
    RSQUARE         reduce using rule 52 (func_exp -> ID fc1 LPAREN fc2 arg fc4 RPAREN fc5 fexp .)
    EQUAL_TO        reduce using rule 52 (func_exp -> ID fc1 LPAREN fc2 arg fc4 RPAREN fc5 fexp .)
    DIFFERENT_TO    reduce using rule 52 (func_exp -> ID fc1 LPAREN fc2 arg fc4 RPAREN fc5 fexp .)
    LESS_OR_EQ_THAN reduce using rule 52 (func_exp -> ID fc1 LPAREN fc2 arg fc4 RPAREN fc5 fexp .)
    MORE_OR_EQ_THAN reduce using rule 52 (func_exp -> ID fc1 LPAREN fc2 arg fc4 RPAREN fc5 fexp .)
    LESS_THAN       reduce using rule 52 (func_exp -> ID fc1 LPAREN fc2 arg fc4 RPAREN fc5 fexp .)
    MORE_THAN       reduce using rule 52 (func_exp -> ID fc1 LPAREN fc2 arg fc4 RPAREN fc5 fexp .)
    OR              reduce using rule 52 (func_exp -> ID fc1 LPAREN fc2 arg fc4 RPAREN fc5 fexp .)
    AND             reduce using rule 52 (func_exp -> ID fc1 LPAREN fc2 arg fc4 RPAREN fc5 fexp .)
    RPAREN          reduce using rule 52 (func_exp -> ID fc1 LPAREN fc2 arg fc4 RPAREN fc5 fexp .)
    COMMA           reduce using rule 52 (func_exp -> ID fc1 LPAREN fc2 arg fc4 RPAREN fc5 fexp .)
    SEMICLN         reduce using rule 52 (func_exp -> ID fc1 LPAREN fc2 arg fc4 RPAREN fc5 fexp .)


state 242

    (21) funcdecl -> FUNC tipofunc func1 ID func2 LPAREN param RPAREN func3 LCURLY varsdecl func4 stmnt RCURLY resetvarcont funcdecl .
    MAIN            reduce using rule 21 (funcdecl -> FUNC tipofunc func1 ID func2 LPAREN param RPAREN func3 LCURLY varsdecl func4 stmnt RCURLY resetvarcont funcdecl .)


Conflicts:

shift/reduce conflict for LSQUARE in state 55 resolved as shift
shift/reduce conflict for COMMA in state 180 resolved as shift
shift/reduce conflict for COMMA in state 224 resolved as shift
reduce/reduce conflict in state 55 resolved using rule ass1 -> <empty>
rejected rule (empty -> <empty>) in state 55
reduce/reduce conflict in state 90 resolved using rule fc1 -> <empty>
rejected rule (fact1 -> <empty>) in state 90