Grammar:

Rule 0     S' -> program
Rule 1     program -> PROGRAM prog1 ID prog2 SEMICLN varsdecl funcdecl main
Rule 2     prog1 -> <empty>
Rule 3     prog2 -> <empty>
Rule 4     varsdecl -> empty
Rule 5     varsdecl -> VARS prog3 multivd multid
Rule 6     prog3 -> <empty>
Rule 7     multivd -> empty
Rule 8     multivd -> tipo prog4 COLON ID prog5 arr multid SEMICLN multivd
Rule 9     prog4 -> <empty>
Rule 10    prog5 -> <empty>
Rule 11    multid -> empty
Rule 12    multid -> COMMA ID prog5 arr multid
Rule 13    tipo -> BOOL
Rule 14    tipo -> CHAR
Rule 15    tipo -> FLOAT
Rule 16    tipo -> INT
Rule 17    arr -> empty
Rule 18    arr -> LSQUARE exp RSQUARE
Rule 19    funcdecl -> empty
Rule 20    funcdecl -> FUNC tipofunc func1 ID func2 LPAREN param RPAREN func3 LCURLY varsdecl func4 stmnt RCURLY resetvarcont funcdecl
Rule 21    func1 -> <empty>
Rule 22    func2 -> <empty>
Rule 23    func3 -> <empty>
Rule 24    func4 -> <empty>
Rule 25    resetvarcont -> <empty>
Rule 26    tipofunc -> tipo
Rule 27    tipofunc -> VOID
Rule 28    param -> empty
Rule 29    param -> tipo param1 COLON ID param2 multiparam
Rule 30    param1 -> <empty>
Rule 31    param2 -> <empty>
Rule 32    multiparam -> empty
Rule 33    multiparam -> COMMA param
Rule 34    main -> MAIN scopemain LPAREN RPAREN stmnt
Rule 35    scopemain -> <empty>
Rule 36    stmnt -> empty
Rule 37    stmnt -> while_stmnt stmnt
Rule 38    stmnt -> if_stmnt stmnt
Rule 39    stmnt -> write_stmnt stmnt
Rule 40    stmnt -> read_stmnt stmnt
Rule 41    stmnt -> ret_stmnt stmnt
Rule 42    stmnt -> func_stmnt stmnt
Rule 43    stmnt -> ass_stmnt stmnt
Rule 44    ass_stmnt -> ID arr ASS func_stmnt SEMICLN
Rule 45    ass_stmnt -> ID ass1 arr ASS ass2 logic ass3 SEMICLN
Rule 46    ass1 -> <empty>
Rule 47    ass2 -> <empty>
Rule 48    ass3 -> <empty>
Rule 49    func_stmnt -> ID fc1 LPAREN fc2 arg fc4 RPAREN fc5 SEMICLN
Rule 50    fc1 -> <empty>
Rule 51    fc2 -> <empty>
Rule 52    arg -> empty
Rule 53    arg -> logic fc3 multiarg
Rule 54    fc3 -> <empty>
Rule 55    fc4 -> <empty>
Rule 56    fc5 -> <empty>
Rule 57    multiarg -> empty
Rule 58    multiarg -> COMMA arg multiarg
Rule 59    ret_stmnt -> RETURN LPAREN logic RPAREN rettrue SEMICLN
Rule 60    rettrue -> <empty>
Rule 61    read_stmnt -> READ io1 LPAREN logic multio io2 RPAREN io3 SEMICLN
Rule 62    write_stmnt -> WRITE io1 LPAREN logic io2 multio RPAREN io3 SEMICLN
Rule 63    multio -> <empty>
Rule 64    multio -> COMMA logic io2 multio
Rule 65    io1 -> <empty>
Rule 66    io2 -> <empty>
Rule 67    io3 -> <empty>
Rule 68    logic -> rel log2 OR log1 logic
Rule 69    logic -> rel log2 AND log1 logic
Rule 70    logic -> rel log2
Rule 71    log1 -> <empty>
Rule 72    log2 -> <empty>
Rule 73    relop -> EQUAL_TO
Rule 74    relop -> DIFFERENT_TO
Rule 75    relop -> LESS_OR_EQ_THAN
Rule 76    relop -> MORE_OR_EQ_THAN
Rule 77    relop -> LESS_THAN
Rule 78    relop -> MORE_THAN
Rule 79    rel -> exp rel2 relop rel1 rel
Rule 80    rel -> exp rel2
Rule 81    rel1 -> <empty>
Rule 82    rel2 -> <empty>
Rule 83    exp -> term exp2 SUB exp1 exp
Rule 84    exp -> term exp2 SUM exp1 exp
Rule 85    exp -> term exp2
Rule 86    exp2 -> <empty>
Rule 87    exp1 -> <empty>
Rule 88    term -> factor term2 DIV term1 term
Rule 89    term -> factor term2 MULT term1 term
Rule 90    term -> factor term2
Rule 91    term1 -> <empty>
Rule 92    term2 -> <empty>
Rule 93    factor -> FALSE ctes4
Rule 94    factor -> TRUE ctes4
Rule 95    factor -> CTE_STR ctes3
Rule 96    factor -> CTE_FLT ctes2
Rule 97    factor -> CTE_NUM ctes1
Rule 98    factor -> ID fact1 LPAREN logic multiexp RPAREN
Rule 99    factor -> ID fact1 arr
Rule 100   ctes1 -> <empty>
Rule 101   ctes2 -> <empty>
Rule 102   ctes3 -> <empty>
Rule 103   ctes4 -> <empty>
Rule 104   fact1 -> <empty>
Rule 105   multiexp -> empty
Rule 106   multiexp -> COMMA logic multiexp
Rule 107   if_stmnt -> IF LPAREN logic if1 RPAREN stmnt else_stmnt END if2
Rule 108   if1 -> <empty>
Rule 109   if2 -> <empty>
Rule 110   else_stmnt -> empty
Rule 111   else_stmnt -> ELSE else1 stmnt
Rule 112   else1 -> <empty>
Rule 113   while_stmnt -> WHILE while1 LPAREN logic while2 RPAREN stmnt while3 END
Rule 114   while1 -> <empty>
Rule 115   while2 -> <empty>
Rule 116   while3 -> <empty>
Rule 117   empty -> <empty>

Terminals, with rules where they appear:

AND                  : 69
ASS                  : 44 45
BOOL                 : 13
CHAR                 : 14
COLON                : 8 29
COMMA                : 12 33 58 64 106
CTE_FLT              : 96
CTE_NUM              : 97
CTE_STR              : 95
DIFFERENT_TO         : 74
DIV                  : 88
ELSE                 : 111
END                  : 107 113
EQUAL_TO             : 73
FALSE                : 93
FLOAT                : 15
FUNC                 : 20
ID                   : 1 8 12 20 29 44 45 49 98 99
IF                   : 107
INT                  : 16
LCURLY               : 20
LESS_OR_EQ_THAN      : 75
LESS_THAN            : 77
LPAREN               : 20 34 49 59 61 62 98 107 113
LSQUARE              : 18
MAIN                 : 34
MORE_OR_EQ_THAN      : 76
MORE_THAN            : 78
MULT                 : 89
OR                   : 68
PROGRAM              : 1
RCURLY               : 20
READ                 : 61
RETURN               : 59
RPAREN               : 20 34 49 59 61 62 98 107 113
RSQUARE              : 18
SEMICLN              : 1 8 44 45 49 59 61 62
SUB                  : 83
SUM                  : 84
TRUE                 : 94
VARS                 : 5
VOID                 : 27
WHILE                : 113
WRITE                : 62
error                : 

Nonterminals, with rules where they appear:

arg                  : 49 58
arr                  : 8 12 44 45 99
ass1                 : 45
ass2                 : 45
ass3                 : 45
ass_stmnt            : 43
ctes1                : 97
ctes2                : 96
ctes3                : 95
ctes4                : 93 94
else1                : 111
else_stmnt           : 107
empty                : 4 7 11 17 19 28 32 36 52 57 105 110
exp                  : 18 79 80 83 84
exp1                 : 83 84
exp2                 : 83 84 85
fact1                : 98 99
factor               : 88 89 90
fc1                  : 49
fc2                  : 49
fc3                  : 53
fc4                  : 49
fc5                  : 49
func1                : 20
func2                : 20
func3                : 20
func4                : 20
func_stmnt           : 42 44
funcdecl             : 1 20
if1                  : 107
if2                  : 107
if_stmnt             : 38
io1                  : 61 62
io2                  : 61 62 64
io3                  : 61 62
log1                 : 68 69
log2                 : 68 69 70
logic                : 45 53 59 61 62 64 68 69 98 106 107 113
main                 : 1
multiarg             : 53 58
multid               : 5 8 12
multiexp             : 98 106
multio               : 61 62 64
multiparam           : 29
multivd              : 5 8
param                : 20 33
param1               : 29
param2               : 29
prog1                : 1
prog2                : 1
prog3                : 5
prog4                : 8
prog5                : 8 12
program              : 0
read_stmnt           : 40
rel                  : 68 69 70 79
rel1                 : 79
rel2                 : 79 80
relop                : 79
resetvarcont         : 20
ret_stmnt            : 41
rettrue              : 59
scopemain            : 34
stmnt                : 20 34 37 38 39 40 41 42 43 107 111 113
term                 : 83 84 85 88 89
term1                : 88 89
term2                : 88 89 90
tipo                 : 8 26 29
tipofunc             : 20
varsdecl             : 1 20
while1               : 113
while2               : 113
while3               : 113
while_stmnt          : 37
write_stmnt          : 39


state 0

    (0) S' -> . program
    (1) program -> . PROGRAM prog1 ID prog2 SEMICLN varsdecl funcdecl main
    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .


state 2

    (1) program -> PROGRAM . prog1 ID prog2 SEMICLN varsdecl funcdecl main
    (2) prog1 -> .
    ID              reduce using rule 2 (prog1 -> .)

    prog1                          shift and go to state 3

state 3

    (1) program -> PROGRAM prog1 . ID prog2 SEMICLN varsdecl funcdecl main
    ID              shift and go to state 4


state 4

    (1) program -> PROGRAM prog1 ID . prog2 SEMICLN varsdecl funcdecl main
    (3) prog2 -> .
    SEMICLN         reduce using rule 3 (prog2 -> .)

    prog2                          shift and go to state 5

state 5

    (1) program -> PROGRAM prog1 ID prog2 . SEMICLN varsdecl funcdecl main
    SEMICLN         shift and go to state 6


state 6

    (1) program -> PROGRAM prog1 ID prog2 SEMICLN . varsdecl funcdecl main
    (4) varsdecl -> . empty
    (5) varsdecl -> . VARS prog3 multivd multid
    (117) empty -> .
    VARS            shift and go to state 9
    FUNC            reduce using rule 117 (empty -> .)
    MAIN            reduce using rule 117 (empty -> .)

    varsdecl                       shift and go to state 7
    empty                          shift and go to state 8

state 7

    (1) program -> PROGRAM prog1 ID prog2 SEMICLN varsdecl . funcdecl main
    (19) funcdecl -> . empty
    (20) funcdecl -> . FUNC tipofunc func1 ID func2 LPAREN param RPAREN func3 LCURLY varsdecl func4 stmnt RCURLY resetvarcont funcdecl
    (117) empty -> .
    FUNC            shift and go to state 12
    MAIN            reduce using rule 117 (empty -> .)

    funcdecl                       shift and go to state 10
    empty                          shift and go to state 11

state 8

    (4) varsdecl -> empty .
    FUNC            reduce using rule 4 (varsdecl -> empty .)
    MAIN            reduce using rule 4 (varsdecl -> empty .)
    WHILE           reduce using rule 4 (varsdecl -> empty .)
    IF              reduce using rule 4 (varsdecl -> empty .)
    WRITE           reduce using rule 4 (varsdecl -> empty .)
    READ            reduce using rule 4 (varsdecl -> empty .)
    RETURN          reduce using rule 4 (varsdecl -> empty .)
    ID              reduce using rule 4 (varsdecl -> empty .)
    RCURLY          reduce using rule 4 (varsdecl -> empty .)


state 9

    (5) varsdecl -> VARS . prog3 multivd multid
    (6) prog3 -> .
    BOOL            reduce using rule 6 (prog3 -> .)
    CHAR            reduce using rule 6 (prog3 -> .)
    FLOAT           reduce using rule 6 (prog3 -> .)
    INT             reduce using rule 6 (prog3 -> .)
    COMMA           reduce using rule 6 (prog3 -> .)
    FUNC            reduce using rule 6 (prog3 -> .)
    MAIN            reduce using rule 6 (prog3 -> .)
    WHILE           reduce using rule 6 (prog3 -> .)
    IF              reduce using rule 6 (prog3 -> .)
    WRITE           reduce using rule 6 (prog3 -> .)
    READ            reduce using rule 6 (prog3 -> .)
    RETURN          reduce using rule 6 (prog3 -> .)
    ID              reduce using rule 6 (prog3 -> .)
    RCURLY          reduce using rule 6 (prog3 -> .)

    prog3                          shift and go to state 13

state 10

    (1) program -> PROGRAM prog1 ID prog2 SEMICLN varsdecl funcdecl . main
    (34) main -> . MAIN scopemain LPAREN RPAREN stmnt
    MAIN            shift and go to state 15

    main                           shift and go to state 14

state 11

    (19) funcdecl -> empty .
    MAIN            reduce using rule 19 (funcdecl -> empty .)


state 12

    (20) funcdecl -> FUNC . tipofunc func1 ID func2 LPAREN param RPAREN func3 LCURLY varsdecl func4 stmnt RCURLY resetvarcont funcdecl
    (26) tipofunc -> . tipo
    (27) tipofunc -> . VOID
    (13) tipo -> . BOOL
    (14) tipo -> . CHAR
    (15) tipo -> . FLOAT
    (16) tipo -> . INT
    VOID            shift and go to state 18
    BOOL            shift and go to state 19
    CHAR            shift and go to state 20
    FLOAT           shift and go to state 21
    INT             shift and go to state 22

    tipofunc                       shift and go to state 16
    tipo                           shift and go to state 17

state 13

    (5) varsdecl -> VARS prog3 . multivd multid
    (7) multivd -> . empty
    (8) multivd -> . tipo prog4 COLON ID prog5 arr multid SEMICLN multivd
    (117) empty -> .
    (13) tipo -> . BOOL
    (14) tipo -> . CHAR
    (15) tipo -> . FLOAT
    (16) tipo -> . INT
    COMMA           reduce using rule 117 (empty -> .)
    FUNC            reduce using rule 117 (empty -> .)
    MAIN            reduce using rule 117 (empty -> .)
    WHILE           reduce using rule 117 (empty -> .)
    IF              reduce using rule 117 (empty -> .)
    WRITE           reduce using rule 117 (empty -> .)
    READ            reduce using rule 117 (empty -> .)
    RETURN          reduce using rule 117 (empty -> .)
    ID              reduce using rule 117 (empty -> .)
    RCURLY          reduce using rule 117 (empty -> .)
    BOOL            shift and go to state 19
    CHAR            shift and go to state 20
    FLOAT           shift and go to state 21
    INT             shift and go to state 22

    multivd                        shift and go to state 23
    empty                          shift and go to state 24
    tipo                           shift and go to state 25

state 14

    (1) program -> PROGRAM prog1 ID prog2 SEMICLN varsdecl funcdecl main .
    $end            reduce using rule 1 (program -> PROGRAM prog1 ID prog2 SEMICLN varsdecl funcdecl main .)


state 15

    (34) main -> MAIN . scopemain LPAREN RPAREN stmnt
    (35) scopemain -> .
    LPAREN          reduce using rule 35 (scopemain -> .)

    scopemain                      shift and go to state 26

state 16

    (20) funcdecl -> FUNC tipofunc . func1 ID func2 LPAREN param RPAREN func3 LCURLY varsdecl func4 stmnt RCURLY resetvarcont funcdecl
    (21) func1 -> .
    ID              reduce using rule 21 (func1 -> .)

    func1                          shift and go to state 27

state 17

    (26) tipofunc -> tipo .
    ID              reduce using rule 26 (tipofunc -> tipo .)


state 18

    (27) tipofunc -> VOID .
    ID              reduce using rule 27 (tipofunc -> VOID .)


state 19

    (13) tipo -> BOOL .
    ID              reduce using rule 13 (tipo -> BOOL .)
    COLON           reduce using rule 13 (tipo -> BOOL .)


state 20

    (14) tipo -> CHAR .
    ID              reduce using rule 14 (tipo -> CHAR .)
    COLON           reduce using rule 14 (tipo -> CHAR .)


state 21

    (15) tipo -> FLOAT .
    ID              reduce using rule 15 (tipo -> FLOAT .)
    COLON           reduce using rule 15 (tipo -> FLOAT .)


state 22

    (16) tipo -> INT .
    ID              reduce using rule 16 (tipo -> INT .)
    COLON           reduce using rule 16 (tipo -> INT .)


state 23

    (5) varsdecl -> VARS prog3 multivd . multid
    (11) multid -> . empty
    (12) multid -> . COMMA ID prog5 arr multid
    (117) empty -> .
    COMMA           shift and go to state 30
    FUNC            reduce using rule 117 (empty -> .)
    MAIN            reduce using rule 117 (empty -> .)
    WHILE           reduce using rule 117 (empty -> .)
    IF              reduce using rule 117 (empty -> .)
    WRITE           reduce using rule 117 (empty -> .)
    READ            reduce using rule 117 (empty -> .)
    RETURN          reduce using rule 117 (empty -> .)
    ID              reduce using rule 117 (empty -> .)
    RCURLY          reduce using rule 117 (empty -> .)

    multid                         shift and go to state 28
    empty                          shift and go to state 29

state 24

    (7) multivd -> empty .
    COMMA           reduce using rule 7 (multivd -> empty .)
    FUNC            reduce using rule 7 (multivd -> empty .)
    MAIN            reduce using rule 7 (multivd -> empty .)
    WHILE           reduce using rule 7 (multivd -> empty .)
    IF              reduce using rule 7 (multivd -> empty .)
    WRITE           reduce using rule 7 (multivd -> empty .)
    READ            reduce using rule 7 (multivd -> empty .)
    RETURN          reduce using rule 7 (multivd -> empty .)
    ID              reduce using rule 7 (multivd -> empty .)
    RCURLY          reduce using rule 7 (multivd -> empty .)


state 25

    (8) multivd -> tipo . prog4 COLON ID prog5 arr multid SEMICLN multivd
    (9) prog4 -> .
    COLON           reduce using rule 9 (prog4 -> .)

    prog4                          shift and go to state 31

state 26

    (34) main -> MAIN scopemain . LPAREN RPAREN stmnt
    LPAREN          shift and go to state 32


state 27

    (20) funcdecl -> FUNC tipofunc func1 . ID func2 LPAREN param RPAREN func3 LCURLY varsdecl func4 stmnt RCURLY resetvarcont funcdecl
    ID              shift and go to state 33


state 28

    (5) varsdecl -> VARS prog3 multivd multid .
    FUNC            reduce using rule 5 (varsdecl -> VARS prog3 multivd multid .)
    MAIN            reduce using rule 5 (varsdecl -> VARS prog3 multivd multid .)
    WHILE           reduce using rule 5 (varsdecl -> VARS prog3 multivd multid .)
    IF              reduce using rule 5 (varsdecl -> VARS prog3 multivd multid .)
    WRITE           reduce using rule 5 (varsdecl -> VARS prog3 multivd multid .)
    READ            reduce using rule 5 (varsdecl -> VARS prog3 multivd multid .)
    RETURN          reduce using rule 5 (varsdecl -> VARS prog3 multivd multid .)
    ID              reduce using rule 5 (varsdecl -> VARS prog3 multivd multid .)
    RCURLY          reduce using rule 5 (varsdecl -> VARS prog3 multivd multid .)


state 29

    (11) multid -> empty .
    FUNC            reduce using rule 11 (multid -> empty .)
    MAIN            reduce using rule 11 (multid -> empty .)
    WHILE           reduce using rule 11 (multid -> empty .)
    IF              reduce using rule 11 (multid -> empty .)
    WRITE           reduce using rule 11 (multid -> empty .)
    READ            reduce using rule 11 (multid -> empty .)
    RETURN          reduce using rule 11 (multid -> empty .)
    ID              reduce using rule 11 (multid -> empty .)
    RCURLY          reduce using rule 11 (multid -> empty .)
    SEMICLN         reduce using rule 11 (multid -> empty .)


state 30

    (12) multid -> COMMA . ID prog5 arr multid
    ID              shift and go to state 34


state 31

    (8) multivd -> tipo prog4 . COLON ID prog5 arr multid SEMICLN multivd
    COLON           shift and go to state 35


state 32

    (34) main -> MAIN scopemain LPAREN . RPAREN stmnt
    RPAREN          shift and go to state 36


state 33

    (20) funcdecl -> FUNC tipofunc func1 ID . func2 LPAREN param RPAREN func3 LCURLY varsdecl func4 stmnt RCURLY resetvarcont funcdecl
    (22) func2 -> .
    LPAREN          reduce using rule 22 (func2 -> .)

    func2                          shift and go to state 37

state 34

    (12) multid -> COMMA ID . prog5 arr multid
    (10) prog5 -> .
    LSQUARE         reduce using rule 10 (prog5 -> .)
    COMMA           reduce using rule 10 (prog5 -> .)
    FUNC            reduce using rule 10 (prog5 -> .)
    MAIN            reduce using rule 10 (prog5 -> .)
    WHILE           reduce using rule 10 (prog5 -> .)
    IF              reduce using rule 10 (prog5 -> .)
    WRITE           reduce using rule 10 (prog5 -> .)
    READ            reduce using rule 10 (prog5 -> .)
    RETURN          reduce using rule 10 (prog5 -> .)
    ID              reduce using rule 10 (prog5 -> .)
    RCURLY          reduce using rule 10 (prog5 -> .)
    SEMICLN         reduce using rule 10 (prog5 -> .)

    prog5                          shift and go to state 38

state 35

    (8) multivd -> tipo prog4 COLON . ID prog5 arr multid SEMICLN multivd
    ID              shift and go to state 39


state 36

    (34) main -> MAIN scopemain LPAREN RPAREN . stmnt
    (36) stmnt -> . empty
    (37) stmnt -> . while_stmnt stmnt
    (38) stmnt -> . if_stmnt stmnt
    (39) stmnt -> . write_stmnt stmnt
    (40) stmnt -> . read_stmnt stmnt
    (41) stmnt -> . ret_stmnt stmnt
    (42) stmnt -> . func_stmnt stmnt
    (43) stmnt -> . ass_stmnt stmnt
    (117) empty -> .
    (113) while_stmnt -> . WHILE while1 LPAREN logic while2 RPAREN stmnt while3 END
    (107) if_stmnt -> . IF LPAREN logic if1 RPAREN stmnt else_stmnt END if2
    (62) write_stmnt -> . WRITE io1 LPAREN logic io2 multio RPAREN io3 SEMICLN
    (61) read_stmnt -> . READ io1 LPAREN logic multio io2 RPAREN io3 SEMICLN
    (59) ret_stmnt -> . RETURN LPAREN logic RPAREN rettrue SEMICLN
    (49) func_stmnt -> . ID fc1 LPAREN fc2 arg fc4 RPAREN fc5 SEMICLN
    (44) ass_stmnt -> . ID arr ASS func_stmnt SEMICLN
    (45) ass_stmnt -> . ID ass1 arr ASS ass2 logic ass3 SEMICLN
    $end            reduce using rule 117 (empty -> .)
    WHILE           shift and go to state 49
    IF              shift and go to state 50
    WRITE           shift and go to state 51
    READ            shift and go to state 52
    RETURN          shift and go to state 53
    ID              shift and go to state 54

    stmnt                          shift and go to state 40
    empty                          shift and go to state 41
    while_stmnt                    shift and go to state 42
    if_stmnt                       shift and go to state 43
    write_stmnt                    shift and go to state 44
    read_stmnt                     shift and go to state 45
    ret_stmnt                      shift and go to state 46
    func_stmnt                     shift and go to state 47
    ass_stmnt                      shift and go to state 48

state 37

    (20) funcdecl -> FUNC tipofunc func1 ID func2 . LPAREN param RPAREN func3 LCURLY varsdecl func4 stmnt RCURLY resetvarcont funcdecl
    LPAREN          shift and go to state 55


state 38

    (12) multid -> COMMA ID prog5 . arr multid
    (17) arr -> . empty
    (18) arr -> . LSQUARE exp RSQUARE
    (117) empty -> .
    LSQUARE         shift and go to state 58
    COMMA           reduce using rule 117 (empty -> .)
    FUNC            reduce using rule 117 (empty -> .)
    MAIN            reduce using rule 117 (empty -> .)
    WHILE           reduce using rule 117 (empty -> .)
    IF              reduce using rule 117 (empty -> .)
    WRITE           reduce using rule 117 (empty -> .)
    READ            reduce using rule 117 (empty -> .)
    RETURN          reduce using rule 117 (empty -> .)
    ID              reduce using rule 117 (empty -> .)
    RCURLY          reduce using rule 117 (empty -> .)
    SEMICLN         reduce using rule 117 (empty -> .)

    arr                            shift and go to state 56
    empty                          shift and go to state 57

state 39

    (8) multivd -> tipo prog4 COLON ID . prog5 arr multid SEMICLN multivd
    (10) prog5 -> .
    LSQUARE         reduce using rule 10 (prog5 -> .)
    COMMA           reduce using rule 10 (prog5 -> .)
    SEMICLN         reduce using rule 10 (prog5 -> .)

    prog5                          shift and go to state 59

state 40

    (34) main -> MAIN scopemain LPAREN RPAREN stmnt .
    $end            reduce using rule 34 (main -> MAIN scopemain LPAREN RPAREN stmnt .)


state 41

    (36) stmnt -> empty .
    $end            reduce using rule 36 (stmnt -> empty .)
    ELSE            reduce using rule 36 (stmnt -> empty .)
    END             reduce using rule 36 (stmnt -> empty .)
    RCURLY          reduce using rule 36 (stmnt -> empty .)


state 42

    (37) stmnt -> while_stmnt . stmnt
    (36) stmnt -> . empty
    (37) stmnt -> . while_stmnt stmnt
    (38) stmnt -> . if_stmnt stmnt
    (39) stmnt -> . write_stmnt stmnt
    (40) stmnt -> . read_stmnt stmnt
    (41) stmnt -> . ret_stmnt stmnt
    (42) stmnt -> . func_stmnt stmnt
    (43) stmnt -> . ass_stmnt stmnt
    (117) empty -> .
    (113) while_stmnt -> . WHILE while1 LPAREN logic while2 RPAREN stmnt while3 END
    (107) if_stmnt -> . IF LPAREN logic if1 RPAREN stmnt else_stmnt END if2
    (62) write_stmnt -> . WRITE io1 LPAREN logic io2 multio RPAREN io3 SEMICLN
    (61) read_stmnt -> . READ io1 LPAREN logic multio io2 RPAREN io3 SEMICLN
    (59) ret_stmnt -> . RETURN LPAREN logic RPAREN rettrue SEMICLN
    (49) func_stmnt -> . ID fc1 LPAREN fc2 arg fc4 RPAREN fc5 SEMICLN
    (44) ass_stmnt -> . ID arr ASS func_stmnt SEMICLN
    (45) ass_stmnt -> . ID ass1 arr ASS ass2 logic ass3 SEMICLN
    $end            reduce using rule 117 (empty -> .)
    ELSE            reduce using rule 117 (empty -> .)
    END             reduce using rule 117 (empty -> .)
    RCURLY          reduce using rule 117 (empty -> .)
    WHILE           shift and go to state 49
    IF              shift and go to state 50
    WRITE           shift and go to state 51
    READ            shift and go to state 52
    RETURN          shift and go to state 53
    ID              shift and go to state 54

    while_stmnt                    shift and go to state 42
    stmnt                          shift and go to state 60
    empty                          shift and go to state 41
    if_stmnt                       shift and go to state 43
    write_stmnt                    shift and go to state 44
    read_stmnt                     shift and go to state 45
    ret_stmnt                      shift and go to state 46
    func_stmnt                     shift and go to state 47
    ass_stmnt                      shift and go to state 48

state 43

    (38) stmnt -> if_stmnt . stmnt
    (36) stmnt -> . empty
    (37) stmnt -> . while_stmnt stmnt
    (38) stmnt -> . if_stmnt stmnt
    (39) stmnt -> . write_stmnt stmnt
    (40) stmnt -> . read_stmnt stmnt
    (41) stmnt -> . ret_stmnt stmnt
    (42) stmnt -> . func_stmnt stmnt
    (43) stmnt -> . ass_stmnt stmnt
    (117) empty -> .
    (113) while_stmnt -> . WHILE while1 LPAREN logic while2 RPAREN stmnt while3 END
    (107) if_stmnt -> . IF LPAREN logic if1 RPAREN stmnt else_stmnt END if2
    (62) write_stmnt -> . WRITE io1 LPAREN logic io2 multio RPAREN io3 SEMICLN
    (61) read_stmnt -> . READ io1 LPAREN logic multio io2 RPAREN io3 SEMICLN
    (59) ret_stmnt -> . RETURN LPAREN logic RPAREN rettrue SEMICLN
    (49) func_stmnt -> . ID fc1 LPAREN fc2 arg fc4 RPAREN fc5 SEMICLN
    (44) ass_stmnt -> . ID arr ASS func_stmnt SEMICLN
    (45) ass_stmnt -> . ID ass1 arr ASS ass2 logic ass3 SEMICLN
    $end            reduce using rule 117 (empty -> .)
    ELSE            reduce using rule 117 (empty -> .)
    END             reduce using rule 117 (empty -> .)
    RCURLY          reduce using rule 117 (empty -> .)
    WHILE           shift and go to state 49
    IF              shift and go to state 50
    WRITE           shift and go to state 51
    READ            shift and go to state 52
    RETURN          shift and go to state 53
    ID              shift and go to state 54

    if_stmnt                       shift and go to state 43
    stmnt                          shift and go to state 61
    empty                          shift and go to state 41
    while_stmnt                    shift and go to state 42
    write_stmnt                    shift and go to state 44
    read_stmnt                     shift and go to state 45
    ret_stmnt                      shift and go to state 46
    func_stmnt                     shift and go to state 47
    ass_stmnt                      shift and go to state 48

state 44

    (39) stmnt -> write_stmnt . stmnt
    (36) stmnt -> . empty
    (37) stmnt -> . while_stmnt stmnt
    (38) stmnt -> . if_stmnt stmnt
    (39) stmnt -> . write_stmnt stmnt
    (40) stmnt -> . read_stmnt stmnt
    (41) stmnt -> . ret_stmnt stmnt
    (42) stmnt -> . func_stmnt stmnt
    (43) stmnt -> . ass_stmnt stmnt
    (117) empty -> .
    (113) while_stmnt -> . WHILE while1 LPAREN logic while2 RPAREN stmnt while3 END
    (107) if_stmnt -> . IF LPAREN logic if1 RPAREN stmnt else_stmnt END if2
    (62) write_stmnt -> . WRITE io1 LPAREN logic io2 multio RPAREN io3 SEMICLN
    (61) read_stmnt -> . READ io1 LPAREN logic multio io2 RPAREN io3 SEMICLN
    (59) ret_stmnt -> . RETURN LPAREN logic RPAREN rettrue SEMICLN
    (49) func_stmnt -> . ID fc1 LPAREN fc2 arg fc4 RPAREN fc5 SEMICLN
    (44) ass_stmnt -> . ID arr ASS func_stmnt SEMICLN
    (45) ass_stmnt -> . ID ass1 arr ASS ass2 logic ass3 SEMICLN
    $end            reduce using rule 117 (empty -> .)
    ELSE            reduce using rule 117 (empty -> .)
    END             reduce using rule 117 (empty -> .)
    RCURLY          reduce using rule 117 (empty -> .)
    WHILE           shift and go to state 49
    IF              shift and go to state 50
    WRITE           shift and go to state 51
    READ            shift and go to state 52
    RETURN          shift and go to state 53
    ID              shift and go to state 54

    write_stmnt                    shift and go to state 44
    stmnt                          shift and go to state 62
    empty                          shift and go to state 41
    while_stmnt                    shift and go to state 42
    if_stmnt                       shift and go to state 43
    read_stmnt                     shift and go to state 45
    ret_stmnt                      shift and go to state 46
    func_stmnt                     shift and go to state 47
    ass_stmnt                      shift and go to state 48

state 45

    (40) stmnt -> read_stmnt . stmnt
    (36) stmnt -> . empty
    (37) stmnt -> . while_stmnt stmnt
    (38) stmnt -> . if_stmnt stmnt
    (39) stmnt -> . write_stmnt stmnt
    (40) stmnt -> . read_stmnt stmnt
    (41) stmnt -> . ret_stmnt stmnt
    (42) stmnt -> . func_stmnt stmnt
    (43) stmnt -> . ass_stmnt stmnt
    (117) empty -> .
    (113) while_stmnt -> . WHILE while1 LPAREN logic while2 RPAREN stmnt while3 END
    (107) if_stmnt -> . IF LPAREN logic if1 RPAREN stmnt else_stmnt END if2
    (62) write_stmnt -> . WRITE io1 LPAREN logic io2 multio RPAREN io3 SEMICLN
    (61) read_stmnt -> . READ io1 LPAREN logic multio io2 RPAREN io3 SEMICLN
    (59) ret_stmnt -> . RETURN LPAREN logic RPAREN rettrue SEMICLN
    (49) func_stmnt -> . ID fc1 LPAREN fc2 arg fc4 RPAREN fc5 SEMICLN
    (44) ass_stmnt -> . ID arr ASS func_stmnt SEMICLN
    (45) ass_stmnt -> . ID ass1 arr ASS ass2 logic ass3 SEMICLN
    $end            reduce using rule 117 (empty -> .)
    ELSE            reduce using rule 117 (empty -> .)
    END             reduce using rule 117 (empty -> .)
    RCURLY          reduce using rule 117 (empty -> .)
    WHILE           shift and go to state 49
    IF              shift and go to state 50
    WRITE           shift and go to state 51
    READ            shift and go to state 52
    RETURN          shift and go to state 53
    ID              shift and go to state 54

    read_stmnt                     shift and go to state 45
    stmnt                          shift and go to state 63
    empty                          shift and go to state 41
    while_stmnt                    shift and go to state 42
    if_stmnt                       shift and go to state 43
    write_stmnt                    shift and go to state 44
    ret_stmnt                      shift and go to state 46
    func_stmnt                     shift and go to state 47
    ass_stmnt                      shift and go to state 48

state 46

    (41) stmnt -> ret_stmnt . stmnt
    (36) stmnt -> . empty
    (37) stmnt -> . while_stmnt stmnt
    (38) stmnt -> . if_stmnt stmnt
    (39) stmnt -> . write_stmnt stmnt
    (40) stmnt -> . read_stmnt stmnt
    (41) stmnt -> . ret_stmnt stmnt
    (42) stmnt -> . func_stmnt stmnt
    (43) stmnt -> . ass_stmnt stmnt
    (117) empty -> .
    (113) while_stmnt -> . WHILE while1 LPAREN logic while2 RPAREN stmnt while3 END
    (107) if_stmnt -> . IF LPAREN logic if1 RPAREN stmnt else_stmnt END if2
    (62) write_stmnt -> . WRITE io1 LPAREN logic io2 multio RPAREN io3 SEMICLN
    (61) read_stmnt -> . READ io1 LPAREN logic multio io2 RPAREN io3 SEMICLN
    (59) ret_stmnt -> . RETURN LPAREN logic RPAREN rettrue SEMICLN
    (49) func_stmnt -> . ID fc1 LPAREN fc2 arg fc4 RPAREN fc5 SEMICLN
    (44) ass_stmnt -> . ID arr ASS func_stmnt SEMICLN
    (45) ass_stmnt -> . ID ass1 arr ASS ass2 logic ass3 SEMICLN
    $end            reduce using rule 117 (empty -> .)
    ELSE            reduce using rule 117 (empty -> .)
    END             reduce using rule 117 (empty -> .)
    RCURLY          reduce using rule 117 (empty -> .)
    WHILE           shift and go to state 49
    IF              shift and go to state 50
    WRITE           shift and go to state 51
    READ            shift and go to state 52
    RETURN          shift and go to state 53
    ID              shift and go to state 54

    ret_stmnt                      shift and go to state 46
    stmnt                          shift and go to state 64
    empty                          shift and go to state 41
    while_stmnt                    shift and go to state 42
    if_stmnt                       shift and go to state 43
    write_stmnt                    shift and go to state 44
    read_stmnt                     shift and go to state 45
    func_stmnt                     shift and go to state 47
    ass_stmnt                      shift and go to state 48

state 47

    (42) stmnt -> func_stmnt . stmnt
    (36) stmnt -> . empty
    (37) stmnt -> . while_stmnt stmnt
    (38) stmnt -> . if_stmnt stmnt
    (39) stmnt -> . write_stmnt stmnt
    (40) stmnt -> . read_stmnt stmnt
    (41) stmnt -> . ret_stmnt stmnt
    (42) stmnt -> . func_stmnt stmnt
    (43) stmnt -> . ass_stmnt stmnt
    (117) empty -> .
    (113) while_stmnt -> . WHILE while1 LPAREN logic while2 RPAREN stmnt while3 END
    (107) if_stmnt -> . IF LPAREN logic if1 RPAREN stmnt else_stmnt END if2
    (62) write_stmnt -> . WRITE io1 LPAREN logic io2 multio RPAREN io3 SEMICLN
    (61) read_stmnt -> . READ io1 LPAREN logic multio io2 RPAREN io3 SEMICLN
    (59) ret_stmnt -> . RETURN LPAREN logic RPAREN rettrue SEMICLN
    (49) func_stmnt -> . ID fc1 LPAREN fc2 arg fc4 RPAREN fc5 SEMICLN
    (44) ass_stmnt -> . ID arr ASS func_stmnt SEMICLN
    (45) ass_stmnt -> . ID ass1 arr ASS ass2 logic ass3 SEMICLN
    $end            reduce using rule 117 (empty -> .)
    ELSE            reduce using rule 117 (empty -> .)
    END             reduce using rule 117 (empty -> .)
    RCURLY          reduce using rule 117 (empty -> .)
    WHILE           shift and go to state 49
    IF              shift and go to state 50
    WRITE           shift and go to state 51
    READ            shift and go to state 52
    RETURN          shift and go to state 53
    ID              shift and go to state 54

    func_stmnt                     shift and go to state 47
    stmnt                          shift and go to state 65
    empty                          shift and go to state 41
    while_stmnt                    shift and go to state 42
    if_stmnt                       shift and go to state 43
    write_stmnt                    shift and go to state 44
    read_stmnt                     shift and go to state 45
    ret_stmnt                      shift and go to state 46
    ass_stmnt                      shift and go to state 48

state 48

    (43) stmnt -> ass_stmnt . stmnt
    (36) stmnt -> . empty
    (37) stmnt -> . while_stmnt stmnt
    (38) stmnt -> . if_stmnt stmnt
    (39) stmnt -> . write_stmnt stmnt
    (40) stmnt -> . read_stmnt stmnt
    (41) stmnt -> . ret_stmnt stmnt
    (42) stmnt -> . func_stmnt stmnt
    (43) stmnt -> . ass_stmnt stmnt
    (117) empty -> .
    (113) while_stmnt -> . WHILE while1 LPAREN logic while2 RPAREN stmnt while3 END
    (107) if_stmnt -> . IF LPAREN logic if1 RPAREN stmnt else_stmnt END if2
    (62) write_stmnt -> . WRITE io1 LPAREN logic io2 multio RPAREN io3 SEMICLN
    (61) read_stmnt -> . READ io1 LPAREN logic multio io2 RPAREN io3 SEMICLN
    (59) ret_stmnt -> . RETURN LPAREN logic RPAREN rettrue SEMICLN
    (49) func_stmnt -> . ID fc1 LPAREN fc2 arg fc4 RPAREN fc5 SEMICLN
    (44) ass_stmnt -> . ID arr ASS func_stmnt SEMICLN
    (45) ass_stmnt -> . ID ass1 arr ASS ass2 logic ass3 SEMICLN
    $end            reduce using rule 117 (empty -> .)
    ELSE            reduce using rule 117 (empty -> .)
    END             reduce using rule 117 (empty -> .)
    RCURLY          reduce using rule 117 (empty -> .)
    WHILE           shift and go to state 49
    IF              shift and go to state 50
    WRITE           shift and go to state 51
    READ            shift and go to state 52
    RETURN          shift and go to state 53
    ID              shift and go to state 54

    ass_stmnt                      shift and go to state 48
    stmnt                          shift and go to state 66
    empty                          shift and go to state 41
    while_stmnt                    shift and go to state 42
    if_stmnt                       shift and go to state 43
    write_stmnt                    shift and go to state 44
    read_stmnt                     shift and go to state 45
    ret_stmnt                      shift and go to state 46
    func_stmnt                     shift and go to state 47

state 49

    (113) while_stmnt -> WHILE . while1 LPAREN logic while2 RPAREN stmnt while3 END
    (114) while1 -> .
    LPAREN          reduce using rule 114 (while1 -> .)

    while1                         shift and go to state 67

state 50

    (107) if_stmnt -> IF . LPAREN logic if1 RPAREN stmnt else_stmnt END if2
    LPAREN          shift and go to state 68


state 51

    (62) write_stmnt -> WRITE . io1 LPAREN logic io2 multio RPAREN io3 SEMICLN
    (65) io1 -> .
    LPAREN          reduce using rule 65 (io1 -> .)

    io1                            shift and go to state 69

state 52

    (61) read_stmnt -> READ . io1 LPAREN logic multio io2 RPAREN io3 SEMICLN
    (65) io1 -> .
    LPAREN          reduce using rule 65 (io1 -> .)

    io1                            shift and go to state 70

state 53

    (59) ret_stmnt -> RETURN . LPAREN logic RPAREN rettrue SEMICLN
    LPAREN          shift and go to state 71


state 54

    (49) func_stmnt -> ID . fc1 LPAREN fc2 arg fc4 RPAREN fc5 SEMICLN
    (44) ass_stmnt -> ID . arr ASS func_stmnt SEMICLN
    (45) ass_stmnt -> ID . ass1 arr ASS ass2 logic ass3 SEMICLN
    (50) fc1 -> .
    (17) arr -> . empty
    (18) arr -> . LSQUARE exp RSQUARE
    (46) ass1 -> .
    (117) empty -> .
  ! shift/reduce conflict for LSQUARE resolved as shift
  ! reduce/reduce conflict for ASS resolved using rule 46 (ass1 -> .)
    LPAREN          reduce using rule 50 (fc1 -> .)
    LSQUARE         shift and go to state 58
    ASS             reduce using rule 46 (ass1 -> .)

    fc1                            shift and go to state 72
    arr                            shift and go to state 73
    ass1                           shift and go to state 74
    empty                          shift and go to state 57

state 55

    (20) funcdecl -> FUNC tipofunc func1 ID func2 LPAREN . param RPAREN func3 LCURLY varsdecl func4 stmnt RCURLY resetvarcont funcdecl
    (28) param -> . empty
    (29) param -> . tipo param1 COLON ID param2 multiparam
    (117) empty -> .
    (13) tipo -> . BOOL
    (14) tipo -> . CHAR
    (15) tipo -> . FLOAT
    (16) tipo -> . INT
    RPAREN          reduce using rule 117 (empty -> .)
    BOOL            shift and go to state 19
    CHAR            shift and go to state 20
    FLOAT           shift and go to state 21
    INT             shift and go to state 22

    param                          shift and go to state 75
    empty                          shift and go to state 76
    tipo                           shift and go to state 77

state 56

    (12) multid -> COMMA ID prog5 arr . multid
    (11) multid -> . empty
    (12) multid -> . COMMA ID prog5 arr multid
    (117) empty -> .
    COMMA           shift and go to state 30
    FUNC            reduce using rule 117 (empty -> .)
    MAIN            reduce using rule 117 (empty -> .)
    WHILE           reduce using rule 117 (empty -> .)
    IF              reduce using rule 117 (empty -> .)
    WRITE           reduce using rule 117 (empty -> .)
    READ            reduce using rule 117 (empty -> .)
    RETURN          reduce using rule 117 (empty -> .)
    ID              reduce using rule 117 (empty -> .)
    RCURLY          reduce using rule 117 (empty -> .)
    SEMICLN         reduce using rule 117 (empty -> .)

    multid                         shift and go to state 78
    empty                          shift and go to state 29

state 57

    (17) arr -> empty .
    COMMA           reduce using rule 17 (arr -> empty .)
    FUNC            reduce using rule 17 (arr -> empty .)
    MAIN            reduce using rule 17 (arr -> empty .)
    WHILE           reduce using rule 17 (arr -> empty .)
    IF              reduce using rule 17 (arr -> empty .)
    WRITE           reduce using rule 17 (arr -> empty .)
    READ            reduce using rule 17 (arr -> empty .)
    RETURN          reduce using rule 17 (arr -> empty .)
    ID              reduce using rule 17 (arr -> empty .)
    RCURLY          reduce using rule 17 (arr -> empty .)
    SEMICLN         reduce using rule 17 (arr -> empty .)
    ASS             reduce using rule 17 (arr -> empty .)
    DIV             reduce using rule 17 (arr -> empty .)
    MULT            reduce using rule 17 (arr -> empty .)
    SUB             reduce using rule 17 (arr -> empty .)
    SUM             reduce using rule 17 (arr -> empty .)
    RSQUARE         reduce using rule 17 (arr -> empty .)
    EQUAL_TO        reduce using rule 17 (arr -> empty .)
    DIFFERENT_TO    reduce using rule 17 (arr -> empty .)
    LESS_OR_EQ_THAN reduce using rule 17 (arr -> empty .)
    MORE_OR_EQ_THAN reduce using rule 17 (arr -> empty .)
    LESS_THAN       reduce using rule 17 (arr -> empty .)
    MORE_THAN       reduce using rule 17 (arr -> empty .)
    OR              reduce using rule 17 (arr -> empty .)
    AND             reduce using rule 17 (arr -> empty .)
    RPAREN          reduce using rule 17 (arr -> empty .)


state 58

    (18) arr -> LSQUARE . exp RSQUARE
    (83) exp -> . term exp2 SUB exp1 exp
    (84) exp -> . term exp2 SUM exp1 exp
    (85) exp -> . term exp2
    (88) term -> . factor term2 DIV term1 term
    (89) term -> . factor term2 MULT term1 term
    (90) term -> . factor term2
    (93) factor -> . FALSE ctes4
    (94) factor -> . TRUE ctes4
    (95) factor -> . CTE_STR ctes3
    (96) factor -> . CTE_FLT ctes2
    (97) factor -> . CTE_NUM ctes1
    (98) factor -> . ID fact1 LPAREN logic multiexp RPAREN
    (99) factor -> . ID fact1 arr
    FALSE           shift and go to state 82
    TRUE            shift and go to state 83
    CTE_STR         shift and go to state 84
    CTE_FLT         shift and go to state 85
    CTE_NUM         shift and go to state 86
    ID              shift and go to state 87

    exp                            shift and go to state 79
    term                           shift and go to state 80
    factor                         shift and go to state 81

state 59

    (8) multivd -> tipo prog4 COLON ID prog5 . arr multid SEMICLN multivd
    (17) arr -> . empty
    (18) arr -> . LSQUARE exp RSQUARE
    (117) empty -> .
    LSQUARE         shift and go to state 58
    COMMA           reduce using rule 117 (empty -> .)
    SEMICLN         reduce using rule 117 (empty -> .)

    arr                            shift and go to state 88
    empty                          shift and go to state 57

state 60

    (37) stmnt -> while_stmnt stmnt .
    $end            reduce using rule 37 (stmnt -> while_stmnt stmnt .)
    ELSE            reduce using rule 37 (stmnt -> while_stmnt stmnt .)
    END             reduce using rule 37 (stmnt -> while_stmnt stmnt .)
    RCURLY          reduce using rule 37 (stmnt -> while_stmnt stmnt .)


state 61

    (38) stmnt -> if_stmnt stmnt .
    $end            reduce using rule 38 (stmnt -> if_stmnt stmnt .)
    ELSE            reduce using rule 38 (stmnt -> if_stmnt stmnt .)
    END             reduce using rule 38 (stmnt -> if_stmnt stmnt .)
    RCURLY          reduce using rule 38 (stmnt -> if_stmnt stmnt .)


state 62

    (39) stmnt -> write_stmnt stmnt .
    $end            reduce using rule 39 (stmnt -> write_stmnt stmnt .)
    ELSE            reduce using rule 39 (stmnt -> write_stmnt stmnt .)
    END             reduce using rule 39 (stmnt -> write_stmnt stmnt .)
    RCURLY          reduce using rule 39 (stmnt -> write_stmnt stmnt .)


state 63

    (40) stmnt -> read_stmnt stmnt .
    $end            reduce using rule 40 (stmnt -> read_stmnt stmnt .)
    ELSE            reduce using rule 40 (stmnt -> read_stmnt stmnt .)
    END             reduce using rule 40 (stmnt -> read_stmnt stmnt .)
    RCURLY          reduce using rule 40 (stmnt -> read_stmnt stmnt .)


state 64

    (41) stmnt -> ret_stmnt stmnt .
    $end            reduce using rule 41 (stmnt -> ret_stmnt stmnt .)
    ELSE            reduce using rule 41 (stmnt -> ret_stmnt stmnt .)
    END             reduce using rule 41 (stmnt -> ret_stmnt stmnt .)
    RCURLY          reduce using rule 41 (stmnt -> ret_stmnt stmnt .)


state 65

    (42) stmnt -> func_stmnt stmnt .
    $end            reduce using rule 42 (stmnt -> func_stmnt stmnt .)
    ELSE            reduce using rule 42 (stmnt -> func_stmnt stmnt .)
    END             reduce using rule 42 (stmnt -> func_stmnt stmnt .)
    RCURLY          reduce using rule 42 (stmnt -> func_stmnt stmnt .)


state 66

    (43) stmnt -> ass_stmnt stmnt .
    $end            reduce using rule 43 (stmnt -> ass_stmnt stmnt .)
    ELSE            reduce using rule 43 (stmnt -> ass_stmnt stmnt .)
    END             reduce using rule 43 (stmnt -> ass_stmnt stmnt .)
    RCURLY          reduce using rule 43 (stmnt -> ass_stmnt stmnt .)


state 67

    (113) while_stmnt -> WHILE while1 . LPAREN logic while2 RPAREN stmnt while3 END
    LPAREN          shift and go to state 89


state 68

    (107) if_stmnt -> IF LPAREN . logic if1 RPAREN stmnt else_stmnt END if2
    (68) logic -> . rel log2 OR log1 logic
    (69) logic -> . rel log2 AND log1 logic
    (70) logic -> . rel log2
    (79) rel -> . exp rel2 relop rel1 rel
    (80) rel -> . exp rel2
    (83) exp -> . term exp2 SUB exp1 exp
    (84) exp -> . term exp2 SUM exp1 exp
    (85) exp -> . term exp2
    (88) term -> . factor term2 DIV term1 term
    (89) term -> . factor term2 MULT term1 term
    (90) term -> . factor term2
    (93) factor -> . FALSE ctes4
    (94) factor -> . TRUE ctes4
    (95) factor -> . CTE_STR ctes3
    (96) factor -> . CTE_FLT ctes2
    (97) factor -> . CTE_NUM ctes1
    (98) factor -> . ID fact1 LPAREN logic multiexp RPAREN
    (99) factor -> . ID fact1 arr
    FALSE           shift and go to state 82
    TRUE            shift and go to state 83
    CTE_STR         shift and go to state 84
    CTE_FLT         shift and go to state 85
    CTE_NUM         shift and go to state 86
    ID              shift and go to state 87

    logic                          shift and go to state 90
    rel                            shift and go to state 91
    exp                            shift and go to state 92
    term                           shift and go to state 80
    factor                         shift and go to state 81

state 69

    (62) write_stmnt -> WRITE io1 . LPAREN logic io2 multio RPAREN io3 SEMICLN
    LPAREN          shift and go to state 93


state 70

    (61) read_stmnt -> READ io1 . LPAREN logic multio io2 RPAREN io3 SEMICLN
    LPAREN          shift and go to state 94


state 71

    (59) ret_stmnt -> RETURN LPAREN . logic RPAREN rettrue SEMICLN
    (68) logic -> . rel log2 OR log1 logic
    (69) logic -> . rel log2 AND log1 logic
    (70) logic -> . rel log2
    (79) rel -> . exp rel2 relop rel1 rel
    (80) rel -> . exp rel2
    (83) exp -> . term exp2 SUB exp1 exp
    (84) exp -> . term exp2 SUM exp1 exp
    (85) exp -> . term exp2
    (88) term -> . factor term2 DIV term1 term
    (89) term -> . factor term2 MULT term1 term
    (90) term -> . factor term2
    (93) factor -> . FALSE ctes4
    (94) factor -> . TRUE ctes4
    (95) factor -> . CTE_STR ctes3
    (96) factor -> . CTE_FLT ctes2
    (97) factor -> . CTE_NUM ctes1
    (98) factor -> . ID fact1 LPAREN logic multiexp RPAREN
    (99) factor -> . ID fact1 arr
    FALSE           shift and go to state 82
    TRUE            shift and go to state 83
    CTE_STR         shift and go to state 84
    CTE_FLT         shift and go to state 85
    CTE_NUM         shift and go to state 86
    ID              shift and go to state 87

    logic                          shift and go to state 95
    rel                            shift and go to state 91
    exp                            shift and go to state 92
    term                           shift and go to state 80
    factor                         shift and go to state 81

state 72

    (49) func_stmnt -> ID fc1 . LPAREN fc2 arg fc4 RPAREN fc5 SEMICLN
    LPAREN          shift and go to state 96


state 73

    (44) ass_stmnt -> ID arr . ASS func_stmnt SEMICLN
    ASS             shift and go to state 97


state 74

    (45) ass_stmnt -> ID ass1 . arr ASS ass2 logic ass3 SEMICLN
    (17) arr -> . empty
    (18) arr -> . LSQUARE exp RSQUARE
    (117) empty -> .
    LSQUARE         shift and go to state 58
    ASS             reduce using rule 117 (empty -> .)

    arr                            shift and go to state 98
    empty                          shift and go to state 57

state 75

    (20) funcdecl -> FUNC tipofunc func1 ID func2 LPAREN param . RPAREN func3 LCURLY varsdecl func4 stmnt RCURLY resetvarcont funcdecl
    RPAREN          shift and go to state 99


state 76

    (28) param -> empty .
    RPAREN          reduce using rule 28 (param -> empty .)


state 77

    (29) param -> tipo . param1 COLON ID param2 multiparam
    (30) param1 -> .
    COLON           reduce using rule 30 (param1 -> .)

    param1                         shift and go to state 100

state 78

    (12) multid -> COMMA ID prog5 arr multid .
    FUNC            reduce using rule 12 (multid -> COMMA ID prog5 arr multid .)
    MAIN            reduce using rule 12 (multid -> COMMA ID prog5 arr multid .)
    WHILE           reduce using rule 12 (multid -> COMMA ID prog5 arr multid .)
    IF              reduce using rule 12 (multid -> COMMA ID prog5 arr multid .)
    WRITE           reduce using rule 12 (multid -> COMMA ID prog5 arr multid .)
    READ            reduce using rule 12 (multid -> COMMA ID prog5 arr multid .)
    RETURN          reduce using rule 12 (multid -> COMMA ID prog5 arr multid .)
    ID              reduce using rule 12 (multid -> COMMA ID prog5 arr multid .)
    RCURLY          reduce using rule 12 (multid -> COMMA ID prog5 arr multid .)
    SEMICLN         reduce using rule 12 (multid -> COMMA ID prog5 arr multid .)


state 79

    (18) arr -> LSQUARE exp . RSQUARE
    RSQUARE         shift and go to state 101


state 80

    (83) exp -> term . exp2 SUB exp1 exp
    (84) exp -> term . exp2 SUM exp1 exp
    (85) exp -> term . exp2
    (86) exp2 -> .
    SUB             reduce using rule 86 (exp2 -> .)
    SUM             reduce using rule 86 (exp2 -> .)
    RSQUARE         reduce using rule 86 (exp2 -> .)
    EQUAL_TO        reduce using rule 86 (exp2 -> .)
    DIFFERENT_TO    reduce using rule 86 (exp2 -> .)
    LESS_OR_EQ_THAN reduce using rule 86 (exp2 -> .)
    MORE_OR_EQ_THAN reduce using rule 86 (exp2 -> .)
    LESS_THAN       reduce using rule 86 (exp2 -> .)
    MORE_THAN       reduce using rule 86 (exp2 -> .)
    OR              reduce using rule 86 (exp2 -> .)
    AND             reduce using rule 86 (exp2 -> .)
    RPAREN          reduce using rule 86 (exp2 -> .)
    COMMA           reduce using rule 86 (exp2 -> .)
    SEMICLN         reduce using rule 86 (exp2 -> .)

    exp2                           shift and go to state 102

state 81

    (88) term -> factor . term2 DIV term1 term
    (89) term -> factor . term2 MULT term1 term
    (90) term -> factor . term2
    (92) term2 -> .
    DIV             reduce using rule 92 (term2 -> .)
    MULT            reduce using rule 92 (term2 -> .)
    SUB             reduce using rule 92 (term2 -> .)
    SUM             reduce using rule 92 (term2 -> .)
    RSQUARE         reduce using rule 92 (term2 -> .)
    EQUAL_TO        reduce using rule 92 (term2 -> .)
    DIFFERENT_TO    reduce using rule 92 (term2 -> .)
    LESS_OR_EQ_THAN reduce using rule 92 (term2 -> .)
    MORE_OR_EQ_THAN reduce using rule 92 (term2 -> .)
    LESS_THAN       reduce using rule 92 (term2 -> .)
    MORE_THAN       reduce using rule 92 (term2 -> .)
    OR              reduce using rule 92 (term2 -> .)
    AND             reduce using rule 92 (term2 -> .)
    RPAREN          reduce using rule 92 (term2 -> .)
    COMMA           reduce using rule 92 (term2 -> .)
    SEMICLN         reduce using rule 92 (term2 -> .)

    term2                          shift and go to state 103

state 82

    (93) factor -> FALSE . ctes4
    (103) ctes4 -> .
    DIV             reduce using rule 103 (ctes4 -> .)
    MULT            reduce using rule 103 (ctes4 -> .)
    SUB             reduce using rule 103 (ctes4 -> .)
    SUM             reduce using rule 103 (ctes4 -> .)
    RSQUARE         reduce using rule 103 (ctes4 -> .)
    EQUAL_TO        reduce using rule 103 (ctes4 -> .)
    DIFFERENT_TO    reduce using rule 103 (ctes4 -> .)
    LESS_OR_EQ_THAN reduce using rule 103 (ctes4 -> .)
    MORE_OR_EQ_THAN reduce using rule 103 (ctes4 -> .)
    LESS_THAN       reduce using rule 103 (ctes4 -> .)
    MORE_THAN       reduce using rule 103 (ctes4 -> .)
    OR              reduce using rule 103 (ctes4 -> .)
    AND             reduce using rule 103 (ctes4 -> .)
    RPAREN          reduce using rule 103 (ctes4 -> .)
    COMMA           reduce using rule 103 (ctes4 -> .)
    SEMICLN         reduce using rule 103 (ctes4 -> .)

    ctes4                          shift and go to state 104

state 83

    (94) factor -> TRUE . ctes4
    (103) ctes4 -> .
    DIV             reduce using rule 103 (ctes4 -> .)
    MULT            reduce using rule 103 (ctes4 -> .)
    SUB             reduce using rule 103 (ctes4 -> .)
    SUM             reduce using rule 103 (ctes4 -> .)
    RSQUARE         reduce using rule 103 (ctes4 -> .)
    EQUAL_TO        reduce using rule 103 (ctes4 -> .)
    DIFFERENT_TO    reduce using rule 103 (ctes4 -> .)
    LESS_OR_EQ_THAN reduce using rule 103 (ctes4 -> .)
    MORE_OR_EQ_THAN reduce using rule 103 (ctes4 -> .)
    LESS_THAN       reduce using rule 103 (ctes4 -> .)
    MORE_THAN       reduce using rule 103 (ctes4 -> .)
    OR              reduce using rule 103 (ctes4 -> .)
    AND             reduce using rule 103 (ctes4 -> .)
    RPAREN          reduce using rule 103 (ctes4 -> .)
    COMMA           reduce using rule 103 (ctes4 -> .)
    SEMICLN         reduce using rule 103 (ctes4 -> .)

    ctes4                          shift and go to state 105

state 84

    (95) factor -> CTE_STR . ctes3
    (102) ctes3 -> .
    DIV             reduce using rule 102 (ctes3 -> .)
    MULT            reduce using rule 102 (ctes3 -> .)
    SUB             reduce using rule 102 (ctes3 -> .)
    SUM             reduce using rule 102 (ctes3 -> .)
    RSQUARE         reduce using rule 102 (ctes3 -> .)
    EQUAL_TO        reduce using rule 102 (ctes3 -> .)
    DIFFERENT_TO    reduce using rule 102 (ctes3 -> .)
    LESS_OR_EQ_THAN reduce using rule 102 (ctes3 -> .)
    MORE_OR_EQ_THAN reduce using rule 102 (ctes3 -> .)
    LESS_THAN       reduce using rule 102 (ctes3 -> .)
    MORE_THAN       reduce using rule 102 (ctes3 -> .)
    OR              reduce using rule 102 (ctes3 -> .)
    AND             reduce using rule 102 (ctes3 -> .)
    RPAREN          reduce using rule 102 (ctes3 -> .)
    COMMA           reduce using rule 102 (ctes3 -> .)
    SEMICLN         reduce using rule 102 (ctes3 -> .)

    ctes3                          shift and go to state 106

state 85

    (96) factor -> CTE_FLT . ctes2
    (101) ctes2 -> .
    DIV             reduce using rule 101 (ctes2 -> .)
    MULT            reduce using rule 101 (ctes2 -> .)
    SUB             reduce using rule 101 (ctes2 -> .)
    SUM             reduce using rule 101 (ctes2 -> .)
    RSQUARE         reduce using rule 101 (ctes2 -> .)
    EQUAL_TO        reduce using rule 101 (ctes2 -> .)
    DIFFERENT_TO    reduce using rule 101 (ctes2 -> .)
    LESS_OR_EQ_THAN reduce using rule 101 (ctes2 -> .)
    MORE_OR_EQ_THAN reduce using rule 101 (ctes2 -> .)
    LESS_THAN       reduce using rule 101 (ctes2 -> .)
    MORE_THAN       reduce using rule 101 (ctes2 -> .)
    OR              reduce using rule 101 (ctes2 -> .)
    AND             reduce using rule 101 (ctes2 -> .)
    RPAREN          reduce using rule 101 (ctes2 -> .)
    COMMA           reduce using rule 101 (ctes2 -> .)
    SEMICLN         reduce using rule 101 (ctes2 -> .)

    ctes2                          shift and go to state 107

state 86

    (97) factor -> CTE_NUM . ctes1
    (100) ctes1 -> .
    DIV             reduce using rule 100 (ctes1 -> .)
    MULT            reduce using rule 100 (ctes1 -> .)
    SUB             reduce using rule 100 (ctes1 -> .)
    SUM             reduce using rule 100 (ctes1 -> .)
    RSQUARE         reduce using rule 100 (ctes1 -> .)
    EQUAL_TO        reduce using rule 100 (ctes1 -> .)
    DIFFERENT_TO    reduce using rule 100 (ctes1 -> .)
    LESS_OR_EQ_THAN reduce using rule 100 (ctes1 -> .)
    MORE_OR_EQ_THAN reduce using rule 100 (ctes1 -> .)
    LESS_THAN       reduce using rule 100 (ctes1 -> .)
    MORE_THAN       reduce using rule 100 (ctes1 -> .)
    OR              reduce using rule 100 (ctes1 -> .)
    AND             reduce using rule 100 (ctes1 -> .)
    RPAREN          reduce using rule 100 (ctes1 -> .)
    COMMA           reduce using rule 100 (ctes1 -> .)
    SEMICLN         reduce using rule 100 (ctes1 -> .)

    ctes1                          shift and go to state 108

state 87

    (98) factor -> ID . fact1 LPAREN logic multiexp RPAREN
    (99) factor -> ID . fact1 arr
    (104) fact1 -> .
    LPAREN          reduce using rule 104 (fact1 -> .)
    LSQUARE         reduce using rule 104 (fact1 -> .)
    DIV             reduce using rule 104 (fact1 -> .)
    MULT            reduce using rule 104 (fact1 -> .)
    SUB             reduce using rule 104 (fact1 -> .)
    SUM             reduce using rule 104 (fact1 -> .)
    RSQUARE         reduce using rule 104 (fact1 -> .)
    EQUAL_TO        reduce using rule 104 (fact1 -> .)
    DIFFERENT_TO    reduce using rule 104 (fact1 -> .)
    LESS_OR_EQ_THAN reduce using rule 104 (fact1 -> .)
    MORE_OR_EQ_THAN reduce using rule 104 (fact1 -> .)
    LESS_THAN       reduce using rule 104 (fact1 -> .)
    MORE_THAN       reduce using rule 104 (fact1 -> .)
    OR              reduce using rule 104 (fact1 -> .)
    AND             reduce using rule 104 (fact1 -> .)
    RPAREN          reduce using rule 104 (fact1 -> .)
    COMMA           reduce using rule 104 (fact1 -> .)
    SEMICLN         reduce using rule 104 (fact1 -> .)

    fact1                          shift and go to state 109

state 88

    (8) multivd -> tipo prog4 COLON ID prog5 arr . multid SEMICLN multivd
    (11) multid -> . empty
    (12) multid -> . COMMA ID prog5 arr multid
    (117) empty -> .
    COMMA           shift and go to state 30
    SEMICLN         reduce using rule 117 (empty -> .)

    multid                         shift and go to state 110
    empty                          shift and go to state 29

state 89

    (113) while_stmnt -> WHILE while1 LPAREN . logic while2 RPAREN stmnt while3 END
    (68) logic -> . rel log2 OR log1 logic
    (69) logic -> . rel log2 AND log1 logic
    (70) logic -> . rel log2
    (79) rel -> . exp rel2 relop rel1 rel
    (80) rel -> . exp rel2
    (83) exp -> . term exp2 SUB exp1 exp
    (84) exp -> . term exp2 SUM exp1 exp
    (85) exp -> . term exp2
    (88) term -> . factor term2 DIV term1 term
    (89) term -> . factor term2 MULT term1 term
    (90) term -> . factor term2
    (93) factor -> . FALSE ctes4
    (94) factor -> . TRUE ctes4
    (95) factor -> . CTE_STR ctes3
    (96) factor -> . CTE_FLT ctes2
    (97) factor -> . CTE_NUM ctes1
    (98) factor -> . ID fact1 LPAREN logic multiexp RPAREN
    (99) factor -> . ID fact1 arr
    FALSE           shift and go to state 82
    TRUE            shift and go to state 83
    CTE_STR         shift and go to state 84
    CTE_FLT         shift and go to state 85
    CTE_NUM         shift and go to state 86
    ID              shift and go to state 87

    logic                          shift and go to state 111
    rel                            shift and go to state 91
    exp                            shift and go to state 92
    term                           shift and go to state 80
    factor                         shift and go to state 81

state 90

    (107) if_stmnt -> IF LPAREN logic . if1 RPAREN stmnt else_stmnt END if2
    (108) if1 -> .
    RPAREN          reduce using rule 108 (if1 -> .)

    if1                            shift and go to state 112

state 91

    (68) logic -> rel . log2 OR log1 logic
    (69) logic -> rel . log2 AND log1 logic
    (70) logic -> rel . log2
    (72) log2 -> .
    OR              reduce using rule 72 (log2 -> .)
    AND             reduce using rule 72 (log2 -> .)
    RPAREN          reduce using rule 72 (log2 -> .)
    COMMA           reduce using rule 72 (log2 -> .)
    SEMICLN         reduce using rule 72 (log2 -> .)

    log2                           shift and go to state 113

state 92

    (79) rel -> exp . rel2 relop rel1 rel
    (80) rel -> exp . rel2
    (82) rel2 -> .
    EQUAL_TO        reduce using rule 82 (rel2 -> .)
    DIFFERENT_TO    reduce using rule 82 (rel2 -> .)
    LESS_OR_EQ_THAN reduce using rule 82 (rel2 -> .)
    MORE_OR_EQ_THAN reduce using rule 82 (rel2 -> .)
    LESS_THAN       reduce using rule 82 (rel2 -> .)
    MORE_THAN       reduce using rule 82 (rel2 -> .)
    OR              reduce using rule 82 (rel2 -> .)
    AND             reduce using rule 82 (rel2 -> .)
    RPAREN          reduce using rule 82 (rel2 -> .)
    COMMA           reduce using rule 82 (rel2 -> .)
    SEMICLN         reduce using rule 82 (rel2 -> .)

    rel2                           shift and go to state 114

state 93

    (62) write_stmnt -> WRITE io1 LPAREN . logic io2 multio RPAREN io3 SEMICLN
    (68) logic -> . rel log2 OR log1 logic
    (69) logic -> . rel log2 AND log1 logic
    (70) logic -> . rel log2
    (79) rel -> . exp rel2 relop rel1 rel
    (80) rel -> . exp rel2
    (83) exp -> . term exp2 SUB exp1 exp
    (84) exp -> . term exp2 SUM exp1 exp
    (85) exp -> . term exp2
    (88) term -> . factor term2 DIV term1 term
    (89) term -> . factor term2 MULT term1 term
    (90) term -> . factor term2
    (93) factor -> . FALSE ctes4
    (94) factor -> . TRUE ctes4
    (95) factor -> . CTE_STR ctes3
    (96) factor -> . CTE_FLT ctes2
    (97) factor -> . CTE_NUM ctes1
    (98) factor -> . ID fact1 LPAREN logic multiexp RPAREN
    (99) factor -> . ID fact1 arr
    FALSE           shift and go to state 82
    TRUE            shift and go to state 83
    CTE_STR         shift and go to state 84
    CTE_FLT         shift and go to state 85
    CTE_NUM         shift and go to state 86
    ID              shift and go to state 87

    logic                          shift and go to state 115
    rel                            shift and go to state 91
    exp                            shift and go to state 92
    term                           shift and go to state 80
    factor                         shift and go to state 81

state 94

    (61) read_stmnt -> READ io1 LPAREN . logic multio io2 RPAREN io3 SEMICLN
    (68) logic -> . rel log2 OR log1 logic
    (69) logic -> . rel log2 AND log1 logic
    (70) logic -> . rel log2
    (79) rel -> . exp rel2 relop rel1 rel
    (80) rel -> . exp rel2
    (83) exp -> . term exp2 SUB exp1 exp
    (84) exp -> . term exp2 SUM exp1 exp
    (85) exp -> . term exp2
    (88) term -> . factor term2 DIV term1 term
    (89) term -> . factor term2 MULT term1 term
    (90) term -> . factor term2
    (93) factor -> . FALSE ctes4
    (94) factor -> . TRUE ctes4
    (95) factor -> . CTE_STR ctes3
    (96) factor -> . CTE_FLT ctes2
    (97) factor -> . CTE_NUM ctes1
    (98) factor -> . ID fact1 LPAREN logic multiexp RPAREN
    (99) factor -> . ID fact1 arr
    FALSE           shift and go to state 82
    TRUE            shift and go to state 83
    CTE_STR         shift and go to state 84
    CTE_FLT         shift and go to state 85
    CTE_NUM         shift and go to state 86
    ID              shift and go to state 87

    logic                          shift and go to state 116
    rel                            shift and go to state 91
    exp                            shift and go to state 92
    term                           shift and go to state 80
    factor                         shift and go to state 81

state 95

    (59) ret_stmnt -> RETURN LPAREN logic . RPAREN rettrue SEMICLN
    RPAREN          shift and go to state 117


state 96

    (49) func_stmnt -> ID fc1 LPAREN . fc2 arg fc4 RPAREN fc5 SEMICLN
    (51) fc2 -> .
    FALSE           reduce using rule 51 (fc2 -> .)
    TRUE            reduce using rule 51 (fc2 -> .)
    CTE_STR         reduce using rule 51 (fc2 -> .)
    CTE_FLT         reduce using rule 51 (fc2 -> .)
    CTE_NUM         reduce using rule 51 (fc2 -> .)
    ID              reduce using rule 51 (fc2 -> .)
    RPAREN          reduce using rule 51 (fc2 -> .)

    fc2                            shift and go to state 118

state 97

    (44) ass_stmnt -> ID arr ASS . func_stmnt SEMICLN
    (49) func_stmnt -> . ID fc1 LPAREN fc2 arg fc4 RPAREN fc5 SEMICLN
    ID              shift and go to state 119

    func_stmnt                     shift and go to state 120

state 98

    (45) ass_stmnt -> ID ass1 arr . ASS ass2 logic ass3 SEMICLN
    ASS             shift and go to state 121


state 99

    (20) funcdecl -> FUNC tipofunc func1 ID func2 LPAREN param RPAREN . func3 LCURLY varsdecl func4 stmnt RCURLY resetvarcont funcdecl
    (23) func3 -> .
    LCURLY          reduce using rule 23 (func3 -> .)

    func3                          shift and go to state 122

state 100

    (29) param -> tipo param1 . COLON ID param2 multiparam
    COLON           shift and go to state 123


state 101

    (18) arr -> LSQUARE exp RSQUARE .
    COMMA           reduce using rule 18 (arr -> LSQUARE exp RSQUARE .)
    FUNC            reduce using rule 18 (arr -> LSQUARE exp RSQUARE .)
    MAIN            reduce using rule 18 (arr -> LSQUARE exp RSQUARE .)
    WHILE           reduce using rule 18 (arr -> LSQUARE exp RSQUARE .)
    IF              reduce using rule 18 (arr -> LSQUARE exp RSQUARE .)
    WRITE           reduce using rule 18 (arr -> LSQUARE exp RSQUARE .)
    READ            reduce using rule 18 (arr -> LSQUARE exp RSQUARE .)
    RETURN          reduce using rule 18 (arr -> LSQUARE exp RSQUARE .)
    ID              reduce using rule 18 (arr -> LSQUARE exp RSQUARE .)
    RCURLY          reduce using rule 18 (arr -> LSQUARE exp RSQUARE .)
    SEMICLN         reduce using rule 18 (arr -> LSQUARE exp RSQUARE .)
    ASS             reduce using rule 18 (arr -> LSQUARE exp RSQUARE .)
    DIV             reduce using rule 18 (arr -> LSQUARE exp RSQUARE .)
    MULT            reduce using rule 18 (arr -> LSQUARE exp RSQUARE .)
    SUB             reduce using rule 18 (arr -> LSQUARE exp RSQUARE .)
    SUM             reduce using rule 18 (arr -> LSQUARE exp RSQUARE .)
    RSQUARE         reduce using rule 18 (arr -> LSQUARE exp RSQUARE .)
    EQUAL_TO        reduce using rule 18 (arr -> LSQUARE exp RSQUARE .)
    DIFFERENT_TO    reduce using rule 18 (arr -> LSQUARE exp RSQUARE .)
    LESS_OR_EQ_THAN reduce using rule 18 (arr -> LSQUARE exp RSQUARE .)
    MORE_OR_EQ_THAN reduce using rule 18 (arr -> LSQUARE exp RSQUARE .)
    LESS_THAN       reduce using rule 18 (arr -> LSQUARE exp RSQUARE .)
    MORE_THAN       reduce using rule 18 (arr -> LSQUARE exp RSQUARE .)
    OR              reduce using rule 18 (arr -> LSQUARE exp RSQUARE .)
    AND             reduce using rule 18 (arr -> LSQUARE exp RSQUARE .)
    RPAREN          reduce using rule 18 (arr -> LSQUARE exp RSQUARE .)


state 102

    (83) exp -> term exp2 . SUB exp1 exp
    (84) exp -> term exp2 . SUM exp1 exp
    (85) exp -> term exp2 .
    SUB             shift and go to state 124
    SUM             shift and go to state 125
    RSQUARE         reduce using rule 85 (exp -> term exp2 .)
    EQUAL_TO        reduce using rule 85 (exp -> term exp2 .)
    DIFFERENT_TO    reduce using rule 85 (exp -> term exp2 .)
    LESS_OR_EQ_THAN reduce using rule 85 (exp -> term exp2 .)
    MORE_OR_EQ_THAN reduce using rule 85 (exp -> term exp2 .)
    LESS_THAN       reduce using rule 85 (exp -> term exp2 .)
    MORE_THAN       reduce using rule 85 (exp -> term exp2 .)
    OR              reduce using rule 85 (exp -> term exp2 .)
    AND             reduce using rule 85 (exp -> term exp2 .)
    RPAREN          reduce using rule 85 (exp -> term exp2 .)
    COMMA           reduce using rule 85 (exp -> term exp2 .)
    SEMICLN         reduce using rule 85 (exp -> term exp2 .)


state 103

    (88) term -> factor term2 . DIV term1 term
    (89) term -> factor term2 . MULT term1 term
    (90) term -> factor term2 .
    DIV             shift and go to state 126
    MULT            shift and go to state 127
    SUB             reduce using rule 90 (term -> factor term2 .)
    SUM             reduce using rule 90 (term -> factor term2 .)
    RSQUARE         reduce using rule 90 (term -> factor term2 .)
    EQUAL_TO        reduce using rule 90 (term -> factor term2 .)
    DIFFERENT_TO    reduce using rule 90 (term -> factor term2 .)
    LESS_OR_EQ_THAN reduce using rule 90 (term -> factor term2 .)
    MORE_OR_EQ_THAN reduce using rule 90 (term -> factor term2 .)
    LESS_THAN       reduce using rule 90 (term -> factor term2 .)
    MORE_THAN       reduce using rule 90 (term -> factor term2 .)
    OR              reduce using rule 90 (term -> factor term2 .)
    AND             reduce using rule 90 (term -> factor term2 .)
    RPAREN          reduce using rule 90 (term -> factor term2 .)
    COMMA           reduce using rule 90 (term -> factor term2 .)
    SEMICLN         reduce using rule 90 (term -> factor term2 .)


state 104

    (93) factor -> FALSE ctes4 .
    DIV             reduce using rule 93 (factor -> FALSE ctes4 .)
    MULT            reduce using rule 93 (factor -> FALSE ctes4 .)
    SUB             reduce using rule 93 (factor -> FALSE ctes4 .)
    SUM             reduce using rule 93 (factor -> FALSE ctes4 .)
    RSQUARE         reduce using rule 93 (factor -> FALSE ctes4 .)
    EQUAL_TO        reduce using rule 93 (factor -> FALSE ctes4 .)
    DIFFERENT_TO    reduce using rule 93 (factor -> FALSE ctes4 .)
    LESS_OR_EQ_THAN reduce using rule 93 (factor -> FALSE ctes4 .)
    MORE_OR_EQ_THAN reduce using rule 93 (factor -> FALSE ctes4 .)
    LESS_THAN       reduce using rule 93 (factor -> FALSE ctes4 .)
    MORE_THAN       reduce using rule 93 (factor -> FALSE ctes4 .)
    OR              reduce using rule 93 (factor -> FALSE ctes4 .)
    AND             reduce using rule 93 (factor -> FALSE ctes4 .)
    RPAREN          reduce using rule 93 (factor -> FALSE ctes4 .)
    COMMA           reduce using rule 93 (factor -> FALSE ctes4 .)
    SEMICLN         reduce using rule 93 (factor -> FALSE ctes4 .)


state 105

    (94) factor -> TRUE ctes4 .
    DIV             reduce using rule 94 (factor -> TRUE ctes4 .)
    MULT            reduce using rule 94 (factor -> TRUE ctes4 .)
    SUB             reduce using rule 94 (factor -> TRUE ctes4 .)
    SUM             reduce using rule 94 (factor -> TRUE ctes4 .)
    RSQUARE         reduce using rule 94 (factor -> TRUE ctes4 .)
    EQUAL_TO        reduce using rule 94 (factor -> TRUE ctes4 .)
    DIFFERENT_TO    reduce using rule 94 (factor -> TRUE ctes4 .)
    LESS_OR_EQ_THAN reduce using rule 94 (factor -> TRUE ctes4 .)
    MORE_OR_EQ_THAN reduce using rule 94 (factor -> TRUE ctes4 .)
    LESS_THAN       reduce using rule 94 (factor -> TRUE ctes4 .)
    MORE_THAN       reduce using rule 94 (factor -> TRUE ctes4 .)
    OR              reduce using rule 94 (factor -> TRUE ctes4 .)
    AND             reduce using rule 94 (factor -> TRUE ctes4 .)
    RPAREN          reduce using rule 94 (factor -> TRUE ctes4 .)
    COMMA           reduce using rule 94 (factor -> TRUE ctes4 .)
    SEMICLN         reduce using rule 94 (factor -> TRUE ctes4 .)


state 106

    (95) factor -> CTE_STR ctes3 .
    DIV             reduce using rule 95 (factor -> CTE_STR ctes3 .)
    MULT            reduce using rule 95 (factor -> CTE_STR ctes3 .)
    SUB             reduce using rule 95 (factor -> CTE_STR ctes3 .)
    SUM             reduce using rule 95 (factor -> CTE_STR ctes3 .)
    RSQUARE         reduce using rule 95 (factor -> CTE_STR ctes3 .)
    EQUAL_TO        reduce using rule 95 (factor -> CTE_STR ctes3 .)
    DIFFERENT_TO    reduce using rule 95 (factor -> CTE_STR ctes3 .)
    LESS_OR_EQ_THAN reduce using rule 95 (factor -> CTE_STR ctes3 .)
    MORE_OR_EQ_THAN reduce using rule 95 (factor -> CTE_STR ctes3 .)
    LESS_THAN       reduce using rule 95 (factor -> CTE_STR ctes3 .)
    MORE_THAN       reduce using rule 95 (factor -> CTE_STR ctes3 .)
    OR              reduce using rule 95 (factor -> CTE_STR ctes3 .)
    AND             reduce using rule 95 (factor -> CTE_STR ctes3 .)
    RPAREN          reduce using rule 95 (factor -> CTE_STR ctes3 .)
    COMMA           reduce using rule 95 (factor -> CTE_STR ctes3 .)
    SEMICLN         reduce using rule 95 (factor -> CTE_STR ctes3 .)


state 107

    (96) factor -> CTE_FLT ctes2 .
    DIV             reduce using rule 96 (factor -> CTE_FLT ctes2 .)
    MULT            reduce using rule 96 (factor -> CTE_FLT ctes2 .)
    SUB             reduce using rule 96 (factor -> CTE_FLT ctes2 .)
    SUM             reduce using rule 96 (factor -> CTE_FLT ctes2 .)
    RSQUARE         reduce using rule 96 (factor -> CTE_FLT ctes2 .)
    EQUAL_TO        reduce using rule 96 (factor -> CTE_FLT ctes2 .)
    DIFFERENT_TO    reduce using rule 96 (factor -> CTE_FLT ctes2 .)
    LESS_OR_EQ_THAN reduce using rule 96 (factor -> CTE_FLT ctes2 .)
    MORE_OR_EQ_THAN reduce using rule 96 (factor -> CTE_FLT ctes2 .)
    LESS_THAN       reduce using rule 96 (factor -> CTE_FLT ctes2 .)
    MORE_THAN       reduce using rule 96 (factor -> CTE_FLT ctes2 .)
    OR              reduce using rule 96 (factor -> CTE_FLT ctes2 .)
    AND             reduce using rule 96 (factor -> CTE_FLT ctes2 .)
    RPAREN          reduce using rule 96 (factor -> CTE_FLT ctes2 .)
    COMMA           reduce using rule 96 (factor -> CTE_FLT ctes2 .)
    SEMICLN         reduce using rule 96 (factor -> CTE_FLT ctes2 .)


state 108

    (97) factor -> CTE_NUM ctes1 .
    DIV             reduce using rule 97 (factor -> CTE_NUM ctes1 .)
    MULT            reduce using rule 97 (factor -> CTE_NUM ctes1 .)
    SUB             reduce using rule 97 (factor -> CTE_NUM ctes1 .)
    SUM             reduce using rule 97 (factor -> CTE_NUM ctes1 .)
    RSQUARE         reduce using rule 97 (factor -> CTE_NUM ctes1 .)
    EQUAL_TO        reduce using rule 97 (factor -> CTE_NUM ctes1 .)
    DIFFERENT_TO    reduce using rule 97 (factor -> CTE_NUM ctes1 .)
    LESS_OR_EQ_THAN reduce using rule 97 (factor -> CTE_NUM ctes1 .)
    MORE_OR_EQ_THAN reduce using rule 97 (factor -> CTE_NUM ctes1 .)
    LESS_THAN       reduce using rule 97 (factor -> CTE_NUM ctes1 .)
    MORE_THAN       reduce using rule 97 (factor -> CTE_NUM ctes1 .)
    OR              reduce using rule 97 (factor -> CTE_NUM ctes1 .)
    AND             reduce using rule 97 (factor -> CTE_NUM ctes1 .)
    RPAREN          reduce using rule 97 (factor -> CTE_NUM ctes1 .)
    COMMA           reduce using rule 97 (factor -> CTE_NUM ctes1 .)
    SEMICLN         reduce using rule 97 (factor -> CTE_NUM ctes1 .)


state 109

    (98) factor -> ID fact1 . LPAREN logic multiexp RPAREN
    (99) factor -> ID fact1 . arr
    (17) arr -> . empty
    (18) arr -> . LSQUARE exp RSQUARE
    (117) empty -> .
    LPAREN          shift and go to state 128
    LSQUARE         shift and go to state 58
    DIV             reduce using rule 117 (empty -> .)
    MULT            reduce using rule 117 (empty -> .)
    SUB             reduce using rule 117 (empty -> .)
    SUM             reduce using rule 117 (empty -> .)
    RSQUARE         reduce using rule 117 (empty -> .)
    EQUAL_TO        reduce using rule 117 (empty -> .)
    DIFFERENT_TO    reduce using rule 117 (empty -> .)
    LESS_OR_EQ_THAN reduce using rule 117 (empty -> .)
    MORE_OR_EQ_THAN reduce using rule 117 (empty -> .)
    LESS_THAN       reduce using rule 117 (empty -> .)
    MORE_THAN       reduce using rule 117 (empty -> .)
    OR              reduce using rule 117 (empty -> .)
    AND             reduce using rule 117 (empty -> .)
    RPAREN          reduce using rule 117 (empty -> .)
    COMMA           reduce using rule 117 (empty -> .)
    SEMICLN         reduce using rule 117 (empty -> .)

    arr                            shift and go to state 129
    empty                          shift and go to state 57

state 110

    (8) multivd -> tipo prog4 COLON ID prog5 arr multid . SEMICLN multivd
    SEMICLN         shift and go to state 130


state 111

    (113) while_stmnt -> WHILE while1 LPAREN logic . while2 RPAREN stmnt while3 END
    (115) while2 -> .
    RPAREN          reduce using rule 115 (while2 -> .)

    while2                         shift and go to state 131

state 112

    (107) if_stmnt -> IF LPAREN logic if1 . RPAREN stmnt else_stmnt END if2
    RPAREN          shift and go to state 132


state 113

    (68) logic -> rel log2 . OR log1 logic
    (69) logic -> rel log2 . AND log1 logic
    (70) logic -> rel log2 .
    OR              shift and go to state 133
    AND             shift and go to state 134
    RPAREN          reduce using rule 70 (logic -> rel log2 .)
    COMMA           reduce using rule 70 (logic -> rel log2 .)
    SEMICLN         reduce using rule 70 (logic -> rel log2 .)


state 114

    (79) rel -> exp rel2 . relop rel1 rel
    (80) rel -> exp rel2 .
    (73) relop -> . EQUAL_TO
    (74) relop -> . DIFFERENT_TO
    (75) relop -> . LESS_OR_EQ_THAN
    (76) relop -> . MORE_OR_EQ_THAN
    (77) relop -> . LESS_THAN
    (78) relop -> . MORE_THAN
    OR              reduce using rule 80 (rel -> exp rel2 .)
    AND             reduce using rule 80 (rel -> exp rel2 .)
    RPAREN          reduce using rule 80 (rel -> exp rel2 .)
    COMMA           reduce using rule 80 (rel -> exp rel2 .)
    SEMICLN         reduce using rule 80 (rel -> exp rel2 .)
    EQUAL_TO        shift and go to state 136
    DIFFERENT_TO    shift and go to state 137
    LESS_OR_EQ_THAN shift and go to state 138
    MORE_OR_EQ_THAN shift and go to state 139
    LESS_THAN       shift and go to state 140
    MORE_THAN       shift and go to state 141

    relop                          shift and go to state 135

state 115

    (62) write_stmnt -> WRITE io1 LPAREN logic . io2 multio RPAREN io3 SEMICLN
    (66) io2 -> .
    COMMA           reduce using rule 66 (io2 -> .)
    RPAREN          reduce using rule 66 (io2 -> .)

    io2                            shift and go to state 142

state 116

    (61) read_stmnt -> READ io1 LPAREN logic . multio io2 RPAREN io3 SEMICLN
    (63) multio -> .
    (64) multio -> . COMMA logic io2 multio
    RPAREN          reduce using rule 63 (multio -> .)
    COMMA           shift and go to state 144

    multio                         shift and go to state 143

state 117

    (59) ret_stmnt -> RETURN LPAREN logic RPAREN . rettrue SEMICLN
    (60) rettrue -> .
    SEMICLN         reduce using rule 60 (rettrue -> .)

    rettrue                        shift and go to state 145

state 118

    (49) func_stmnt -> ID fc1 LPAREN fc2 . arg fc4 RPAREN fc5 SEMICLN
    (52) arg -> . empty
    (53) arg -> . logic fc3 multiarg
    (117) empty -> .
    (68) logic -> . rel log2 OR log1 logic
    (69) logic -> . rel log2 AND log1 logic
    (70) logic -> . rel log2
    (79) rel -> . exp rel2 relop rel1 rel
    (80) rel -> . exp rel2
    (83) exp -> . term exp2 SUB exp1 exp
    (84) exp -> . term exp2 SUM exp1 exp
    (85) exp -> . term exp2
    (88) term -> . factor term2 DIV term1 term
    (89) term -> . factor term2 MULT term1 term
    (90) term -> . factor term2
    (93) factor -> . FALSE ctes4
    (94) factor -> . TRUE ctes4
    (95) factor -> . CTE_STR ctes3
    (96) factor -> . CTE_FLT ctes2
    (97) factor -> . CTE_NUM ctes1
    (98) factor -> . ID fact1 LPAREN logic multiexp RPAREN
    (99) factor -> . ID fact1 arr
    RPAREN          reduce using rule 117 (empty -> .)
    FALSE           shift and go to state 82
    TRUE            shift and go to state 83
    CTE_STR         shift and go to state 84
    CTE_FLT         shift and go to state 85
    CTE_NUM         shift and go to state 86
    ID              shift and go to state 87

    arg                            shift and go to state 146
    empty                          shift and go to state 147
    logic                          shift and go to state 148
    rel                            shift and go to state 91
    exp                            shift and go to state 92
    term                           shift and go to state 80
    factor                         shift and go to state 81

state 119

    (49) func_stmnt -> ID . fc1 LPAREN fc2 arg fc4 RPAREN fc5 SEMICLN
    (50) fc1 -> .
    LPAREN          reduce using rule 50 (fc1 -> .)

    fc1                            shift and go to state 72

state 120

    (44) ass_stmnt -> ID arr ASS func_stmnt . SEMICLN
    SEMICLN         shift and go to state 149


state 121

    (45) ass_stmnt -> ID ass1 arr ASS . ass2 logic ass3 SEMICLN
    (47) ass2 -> .
    FALSE           reduce using rule 47 (ass2 -> .)
    TRUE            reduce using rule 47 (ass2 -> .)
    CTE_STR         reduce using rule 47 (ass2 -> .)
    CTE_FLT         reduce using rule 47 (ass2 -> .)
    CTE_NUM         reduce using rule 47 (ass2 -> .)
    ID              reduce using rule 47 (ass2 -> .)

    ass2                           shift and go to state 150

state 122

    (20) funcdecl -> FUNC tipofunc func1 ID func2 LPAREN param RPAREN func3 . LCURLY varsdecl func4 stmnt RCURLY resetvarcont funcdecl
    LCURLY          shift and go to state 151


state 123

    (29) param -> tipo param1 COLON . ID param2 multiparam
    ID              shift and go to state 152


state 124

    (83) exp -> term exp2 SUB . exp1 exp
    (87) exp1 -> .
    FALSE           reduce using rule 87 (exp1 -> .)
    TRUE            reduce using rule 87 (exp1 -> .)
    CTE_STR         reduce using rule 87 (exp1 -> .)
    CTE_FLT         reduce using rule 87 (exp1 -> .)
    CTE_NUM         reduce using rule 87 (exp1 -> .)
    ID              reduce using rule 87 (exp1 -> .)

    exp1                           shift and go to state 153

state 125

    (84) exp -> term exp2 SUM . exp1 exp
    (87) exp1 -> .
    FALSE           reduce using rule 87 (exp1 -> .)
    TRUE            reduce using rule 87 (exp1 -> .)
    CTE_STR         reduce using rule 87 (exp1 -> .)
    CTE_FLT         reduce using rule 87 (exp1 -> .)
    CTE_NUM         reduce using rule 87 (exp1 -> .)
    ID              reduce using rule 87 (exp1 -> .)

    exp1                           shift and go to state 154

state 126

    (88) term -> factor term2 DIV . term1 term
    (91) term1 -> .
    FALSE           reduce using rule 91 (term1 -> .)
    TRUE            reduce using rule 91 (term1 -> .)
    CTE_STR         reduce using rule 91 (term1 -> .)
    CTE_FLT         reduce using rule 91 (term1 -> .)
    CTE_NUM         reduce using rule 91 (term1 -> .)
    ID              reduce using rule 91 (term1 -> .)

    term1                          shift and go to state 155

state 127

    (89) term -> factor term2 MULT . term1 term
    (91) term1 -> .
    FALSE           reduce using rule 91 (term1 -> .)
    TRUE            reduce using rule 91 (term1 -> .)
    CTE_STR         reduce using rule 91 (term1 -> .)
    CTE_FLT         reduce using rule 91 (term1 -> .)
    CTE_NUM         reduce using rule 91 (term1 -> .)
    ID              reduce using rule 91 (term1 -> .)

    term1                          shift and go to state 156

state 128

    (98) factor -> ID fact1 LPAREN . logic multiexp RPAREN
    (68) logic -> . rel log2 OR log1 logic
    (69) logic -> . rel log2 AND log1 logic
    (70) logic -> . rel log2
    (79) rel -> . exp rel2 relop rel1 rel
    (80) rel -> . exp rel2
    (83) exp -> . term exp2 SUB exp1 exp
    (84) exp -> . term exp2 SUM exp1 exp
    (85) exp -> . term exp2
    (88) term -> . factor term2 DIV term1 term
    (89) term -> . factor term2 MULT term1 term
    (90) term -> . factor term2
    (93) factor -> . FALSE ctes4
    (94) factor -> . TRUE ctes4
    (95) factor -> . CTE_STR ctes3
    (96) factor -> . CTE_FLT ctes2
    (97) factor -> . CTE_NUM ctes1
    (98) factor -> . ID fact1 LPAREN logic multiexp RPAREN
    (99) factor -> . ID fact1 arr
    FALSE           shift and go to state 82
    TRUE            shift and go to state 83
    CTE_STR         shift and go to state 84
    CTE_FLT         shift and go to state 85
    CTE_NUM         shift and go to state 86
    ID              shift and go to state 87

    logic                          shift and go to state 157
    rel                            shift and go to state 91
    exp                            shift and go to state 92
    term                           shift and go to state 80
    factor                         shift and go to state 81

state 129

    (99) factor -> ID fact1 arr .
    DIV             reduce using rule 99 (factor -> ID fact1 arr .)
    MULT            reduce using rule 99 (factor -> ID fact1 arr .)
    SUB             reduce using rule 99 (factor -> ID fact1 arr .)
    SUM             reduce using rule 99 (factor -> ID fact1 arr .)
    RSQUARE         reduce using rule 99 (factor -> ID fact1 arr .)
    EQUAL_TO        reduce using rule 99 (factor -> ID fact1 arr .)
    DIFFERENT_TO    reduce using rule 99 (factor -> ID fact1 arr .)
    LESS_OR_EQ_THAN reduce using rule 99 (factor -> ID fact1 arr .)
    MORE_OR_EQ_THAN reduce using rule 99 (factor -> ID fact1 arr .)
    LESS_THAN       reduce using rule 99 (factor -> ID fact1 arr .)
    MORE_THAN       reduce using rule 99 (factor -> ID fact1 arr .)
    OR              reduce using rule 99 (factor -> ID fact1 arr .)
    AND             reduce using rule 99 (factor -> ID fact1 arr .)
    RPAREN          reduce using rule 99 (factor -> ID fact1 arr .)
    COMMA           reduce using rule 99 (factor -> ID fact1 arr .)
    SEMICLN         reduce using rule 99 (factor -> ID fact1 arr .)


state 130

    (8) multivd -> tipo prog4 COLON ID prog5 arr multid SEMICLN . multivd
    (7) multivd -> . empty
    (8) multivd -> . tipo prog4 COLON ID prog5 arr multid SEMICLN multivd
    (117) empty -> .
    (13) tipo -> . BOOL
    (14) tipo -> . CHAR
    (15) tipo -> . FLOAT
    (16) tipo -> . INT
    COMMA           reduce using rule 117 (empty -> .)
    FUNC            reduce using rule 117 (empty -> .)
    MAIN            reduce using rule 117 (empty -> .)
    WHILE           reduce using rule 117 (empty -> .)
    IF              reduce using rule 117 (empty -> .)
    WRITE           reduce using rule 117 (empty -> .)
    READ            reduce using rule 117 (empty -> .)
    RETURN          reduce using rule 117 (empty -> .)
    ID              reduce using rule 117 (empty -> .)
    RCURLY          reduce using rule 117 (empty -> .)
    BOOL            shift and go to state 19
    CHAR            shift and go to state 20
    FLOAT           shift and go to state 21
    INT             shift and go to state 22

    tipo                           shift and go to state 25
    multivd                        shift and go to state 158
    empty                          shift and go to state 24

state 131

    (113) while_stmnt -> WHILE while1 LPAREN logic while2 . RPAREN stmnt while3 END
    RPAREN          shift and go to state 159


state 132

    (107) if_stmnt -> IF LPAREN logic if1 RPAREN . stmnt else_stmnt END if2
    (36) stmnt -> . empty
    (37) stmnt -> . while_stmnt stmnt
    (38) stmnt -> . if_stmnt stmnt
    (39) stmnt -> . write_stmnt stmnt
    (40) stmnt -> . read_stmnt stmnt
    (41) stmnt -> . ret_stmnt stmnt
    (42) stmnt -> . func_stmnt stmnt
    (43) stmnt -> . ass_stmnt stmnt
    (117) empty -> .
    (113) while_stmnt -> . WHILE while1 LPAREN logic while2 RPAREN stmnt while3 END
    (107) if_stmnt -> . IF LPAREN logic if1 RPAREN stmnt else_stmnt END if2
    (62) write_stmnt -> . WRITE io1 LPAREN logic io2 multio RPAREN io3 SEMICLN
    (61) read_stmnt -> . READ io1 LPAREN logic multio io2 RPAREN io3 SEMICLN
    (59) ret_stmnt -> . RETURN LPAREN logic RPAREN rettrue SEMICLN
    (49) func_stmnt -> . ID fc1 LPAREN fc2 arg fc4 RPAREN fc5 SEMICLN
    (44) ass_stmnt -> . ID arr ASS func_stmnt SEMICLN
    (45) ass_stmnt -> . ID ass1 arr ASS ass2 logic ass3 SEMICLN
    ELSE            reduce using rule 117 (empty -> .)
    END             reduce using rule 117 (empty -> .)
    WHILE           shift and go to state 49
    IF              shift and go to state 50
    WRITE           shift and go to state 51
    READ            shift and go to state 52
    RETURN          shift and go to state 53
    ID              shift and go to state 54

    stmnt                          shift and go to state 160
    empty                          shift and go to state 41
    while_stmnt                    shift and go to state 42
    if_stmnt                       shift and go to state 43
    write_stmnt                    shift and go to state 44
    read_stmnt                     shift and go to state 45
    ret_stmnt                      shift and go to state 46
    func_stmnt                     shift and go to state 47
    ass_stmnt                      shift and go to state 48

state 133

    (68) logic -> rel log2 OR . log1 logic
    (71) log1 -> .
    FALSE           reduce using rule 71 (log1 -> .)
    TRUE            reduce using rule 71 (log1 -> .)
    CTE_STR         reduce using rule 71 (log1 -> .)
    CTE_FLT         reduce using rule 71 (log1 -> .)
    CTE_NUM         reduce using rule 71 (log1 -> .)
    ID              reduce using rule 71 (log1 -> .)

    log1                           shift and go to state 161

state 134

    (69) logic -> rel log2 AND . log1 logic
    (71) log1 -> .
    FALSE           reduce using rule 71 (log1 -> .)
    TRUE            reduce using rule 71 (log1 -> .)
    CTE_STR         reduce using rule 71 (log1 -> .)
    CTE_FLT         reduce using rule 71 (log1 -> .)
    CTE_NUM         reduce using rule 71 (log1 -> .)
    ID              reduce using rule 71 (log1 -> .)

    log1                           shift and go to state 162

state 135

    (79) rel -> exp rel2 relop . rel1 rel
    (81) rel1 -> .
    FALSE           reduce using rule 81 (rel1 -> .)
    TRUE            reduce using rule 81 (rel1 -> .)
    CTE_STR         reduce using rule 81 (rel1 -> .)
    CTE_FLT         reduce using rule 81 (rel1 -> .)
    CTE_NUM         reduce using rule 81 (rel1 -> .)
    ID              reduce using rule 81 (rel1 -> .)

    rel1                           shift and go to state 163

state 136

    (73) relop -> EQUAL_TO .
    FALSE           reduce using rule 73 (relop -> EQUAL_TO .)
    TRUE            reduce using rule 73 (relop -> EQUAL_TO .)
    CTE_STR         reduce using rule 73 (relop -> EQUAL_TO .)
    CTE_FLT         reduce using rule 73 (relop -> EQUAL_TO .)
    CTE_NUM         reduce using rule 73 (relop -> EQUAL_TO .)
    ID              reduce using rule 73 (relop -> EQUAL_TO .)


state 137

    (74) relop -> DIFFERENT_TO .
    FALSE           reduce using rule 74 (relop -> DIFFERENT_TO .)
    TRUE            reduce using rule 74 (relop -> DIFFERENT_TO .)
    CTE_STR         reduce using rule 74 (relop -> DIFFERENT_TO .)
    CTE_FLT         reduce using rule 74 (relop -> DIFFERENT_TO .)
    CTE_NUM         reduce using rule 74 (relop -> DIFFERENT_TO .)
    ID              reduce using rule 74 (relop -> DIFFERENT_TO .)


state 138

    (75) relop -> LESS_OR_EQ_THAN .
    FALSE           reduce using rule 75 (relop -> LESS_OR_EQ_THAN .)
    TRUE            reduce using rule 75 (relop -> LESS_OR_EQ_THAN .)
    CTE_STR         reduce using rule 75 (relop -> LESS_OR_EQ_THAN .)
    CTE_FLT         reduce using rule 75 (relop -> LESS_OR_EQ_THAN .)
    CTE_NUM         reduce using rule 75 (relop -> LESS_OR_EQ_THAN .)
    ID              reduce using rule 75 (relop -> LESS_OR_EQ_THAN .)


state 139

    (76) relop -> MORE_OR_EQ_THAN .
    FALSE           reduce using rule 76 (relop -> MORE_OR_EQ_THAN .)
    TRUE            reduce using rule 76 (relop -> MORE_OR_EQ_THAN .)
    CTE_STR         reduce using rule 76 (relop -> MORE_OR_EQ_THAN .)
    CTE_FLT         reduce using rule 76 (relop -> MORE_OR_EQ_THAN .)
    CTE_NUM         reduce using rule 76 (relop -> MORE_OR_EQ_THAN .)
    ID              reduce using rule 76 (relop -> MORE_OR_EQ_THAN .)


state 140

    (77) relop -> LESS_THAN .
    FALSE           reduce using rule 77 (relop -> LESS_THAN .)
    TRUE            reduce using rule 77 (relop -> LESS_THAN .)
    CTE_STR         reduce using rule 77 (relop -> LESS_THAN .)
    CTE_FLT         reduce using rule 77 (relop -> LESS_THAN .)
    CTE_NUM         reduce using rule 77 (relop -> LESS_THAN .)
    ID              reduce using rule 77 (relop -> LESS_THAN .)


state 141

    (78) relop -> MORE_THAN .
    FALSE           reduce using rule 78 (relop -> MORE_THAN .)
    TRUE            reduce using rule 78 (relop -> MORE_THAN .)
    CTE_STR         reduce using rule 78 (relop -> MORE_THAN .)
    CTE_FLT         reduce using rule 78 (relop -> MORE_THAN .)
    CTE_NUM         reduce using rule 78 (relop -> MORE_THAN .)
    ID              reduce using rule 78 (relop -> MORE_THAN .)


state 142

    (62) write_stmnt -> WRITE io1 LPAREN logic io2 . multio RPAREN io3 SEMICLN
    (63) multio -> .
    (64) multio -> . COMMA logic io2 multio
    RPAREN          reduce using rule 63 (multio -> .)
    COMMA           shift and go to state 144

    multio                         shift and go to state 164

state 143

    (61) read_stmnt -> READ io1 LPAREN logic multio . io2 RPAREN io3 SEMICLN
    (66) io2 -> .
    RPAREN          reduce using rule 66 (io2 -> .)

    io2                            shift and go to state 165

state 144

    (64) multio -> COMMA . logic io2 multio
    (68) logic -> . rel log2 OR log1 logic
    (69) logic -> . rel log2 AND log1 logic
    (70) logic -> . rel log2
    (79) rel -> . exp rel2 relop rel1 rel
    (80) rel -> . exp rel2
    (83) exp -> . term exp2 SUB exp1 exp
    (84) exp -> . term exp2 SUM exp1 exp
    (85) exp -> . term exp2
    (88) term -> . factor term2 DIV term1 term
    (89) term -> . factor term2 MULT term1 term
    (90) term -> . factor term2
    (93) factor -> . FALSE ctes4
    (94) factor -> . TRUE ctes4
    (95) factor -> . CTE_STR ctes3
    (96) factor -> . CTE_FLT ctes2
    (97) factor -> . CTE_NUM ctes1
    (98) factor -> . ID fact1 LPAREN logic multiexp RPAREN
    (99) factor -> . ID fact1 arr
    FALSE           shift and go to state 82
    TRUE            shift and go to state 83
    CTE_STR         shift and go to state 84
    CTE_FLT         shift and go to state 85
    CTE_NUM         shift and go to state 86
    ID              shift and go to state 87

    logic                          shift and go to state 166
    rel                            shift and go to state 91
    exp                            shift and go to state 92
    term                           shift and go to state 80
    factor                         shift and go to state 81

state 145

    (59) ret_stmnt -> RETURN LPAREN logic RPAREN rettrue . SEMICLN
    SEMICLN         shift and go to state 167


state 146

    (49) func_stmnt -> ID fc1 LPAREN fc2 arg . fc4 RPAREN fc5 SEMICLN
    (55) fc4 -> .
    RPAREN          reduce using rule 55 (fc4 -> .)

    fc4                            shift and go to state 168

state 147

    (52) arg -> empty .
    RPAREN          reduce using rule 52 (arg -> empty .)
    COMMA           reduce using rule 52 (arg -> empty .)


state 148

    (53) arg -> logic . fc3 multiarg
    (54) fc3 -> .
    COMMA           reduce using rule 54 (fc3 -> .)
    RPAREN          reduce using rule 54 (fc3 -> .)

    fc3                            shift and go to state 169

state 149

    (44) ass_stmnt -> ID arr ASS func_stmnt SEMICLN .
    WHILE           reduce using rule 44 (ass_stmnt -> ID arr ASS func_stmnt SEMICLN .)
    IF              reduce using rule 44 (ass_stmnt -> ID arr ASS func_stmnt SEMICLN .)
    WRITE           reduce using rule 44 (ass_stmnt -> ID arr ASS func_stmnt SEMICLN .)
    READ            reduce using rule 44 (ass_stmnt -> ID arr ASS func_stmnt SEMICLN .)
    RETURN          reduce using rule 44 (ass_stmnt -> ID arr ASS func_stmnt SEMICLN .)
    ID              reduce using rule 44 (ass_stmnt -> ID arr ASS func_stmnt SEMICLN .)
    $end            reduce using rule 44 (ass_stmnt -> ID arr ASS func_stmnt SEMICLN .)
    ELSE            reduce using rule 44 (ass_stmnt -> ID arr ASS func_stmnt SEMICLN .)
    END             reduce using rule 44 (ass_stmnt -> ID arr ASS func_stmnt SEMICLN .)
    RCURLY          reduce using rule 44 (ass_stmnt -> ID arr ASS func_stmnt SEMICLN .)


state 150

    (45) ass_stmnt -> ID ass1 arr ASS ass2 . logic ass3 SEMICLN
    (68) logic -> . rel log2 OR log1 logic
    (69) logic -> . rel log2 AND log1 logic
    (70) logic -> . rel log2
    (79) rel -> . exp rel2 relop rel1 rel
    (80) rel -> . exp rel2
    (83) exp -> . term exp2 SUB exp1 exp
    (84) exp -> . term exp2 SUM exp1 exp
    (85) exp -> . term exp2
    (88) term -> . factor term2 DIV term1 term
    (89) term -> . factor term2 MULT term1 term
    (90) term -> . factor term2
    (93) factor -> . FALSE ctes4
    (94) factor -> . TRUE ctes4
    (95) factor -> . CTE_STR ctes3
    (96) factor -> . CTE_FLT ctes2
    (97) factor -> . CTE_NUM ctes1
    (98) factor -> . ID fact1 LPAREN logic multiexp RPAREN
    (99) factor -> . ID fact1 arr
    FALSE           shift and go to state 82
    TRUE            shift and go to state 83
    CTE_STR         shift and go to state 84
    CTE_FLT         shift and go to state 85
    CTE_NUM         shift and go to state 86
    ID              shift and go to state 87

    logic                          shift and go to state 170
    rel                            shift and go to state 91
    exp                            shift and go to state 92
    term                           shift and go to state 80
    factor                         shift and go to state 81

state 151

    (20) funcdecl -> FUNC tipofunc func1 ID func2 LPAREN param RPAREN func3 LCURLY . varsdecl func4 stmnt RCURLY resetvarcont funcdecl
    (4) varsdecl -> . empty
    (5) varsdecl -> . VARS prog3 multivd multid
    (117) empty -> .
    VARS            shift and go to state 9
    WHILE           reduce using rule 117 (empty -> .)
    IF              reduce using rule 117 (empty -> .)
    WRITE           reduce using rule 117 (empty -> .)
    READ            reduce using rule 117 (empty -> .)
    RETURN          reduce using rule 117 (empty -> .)
    ID              reduce using rule 117 (empty -> .)
    RCURLY          reduce using rule 117 (empty -> .)

    varsdecl                       shift and go to state 171
    empty                          shift and go to state 8

state 152

    (29) param -> tipo param1 COLON ID . param2 multiparam
    (31) param2 -> .
    COMMA           reduce using rule 31 (param2 -> .)
    RPAREN          reduce using rule 31 (param2 -> .)

    param2                         shift and go to state 172

state 153

    (83) exp -> term exp2 SUB exp1 . exp
    (83) exp -> . term exp2 SUB exp1 exp
    (84) exp -> . term exp2 SUM exp1 exp
    (85) exp -> . term exp2
    (88) term -> . factor term2 DIV term1 term
    (89) term -> . factor term2 MULT term1 term
    (90) term -> . factor term2
    (93) factor -> . FALSE ctes4
    (94) factor -> . TRUE ctes4
    (95) factor -> . CTE_STR ctes3
    (96) factor -> . CTE_FLT ctes2
    (97) factor -> . CTE_NUM ctes1
    (98) factor -> . ID fact1 LPAREN logic multiexp RPAREN
    (99) factor -> . ID fact1 arr
    FALSE           shift and go to state 82
    TRUE            shift and go to state 83
    CTE_STR         shift and go to state 84
    CTE_FLT         shift and go to state 85
    CTE_NUM         shift and go to state 86
    ID              shift and go to state 87

    term                           shift and go to state 80
    exp                            shift and go to state 173
    factor                         shift and go to state 81

state 154

    (84) exp -> term exp2 SUM exp1 . exp
    (83) exp -> . term exp2 SUB exp1 exp
    (84) exp -> . term exp2 SUM exp1 exp
    (85) exp -> . term exp2
    (88) term -> . factor term2 DIV term1 term
    (89) term -> . factor term2 MULT term1 term
    (90) term -> . factor term2
    (93) factor -> . FALSE ctes4
    (94) factor -> . TRUE ctes4
    (95) factor -> . CTE_STR ctes3
    (96) factor -> . CTE_FLT ctes2
    (97) factor -> . CTE_NUM ctes1
    (98) factor -> . ID fact1 LPAREN logic multiexp RPAREN
    (99) factor -> . ID fact1 arr
    FALSE           shift and go to state 82
    TRUE            shift and go to state 83
    CTE_STR         shift and go to state 84
    CTE_FLT         shift and go to state 85
    CTE_NUM         shift and go to state 86
    ID              shift and go to state 87

    term                           shift and go to state 80
    exp                            shift and go to state 174
    factor                         shift and go to state 81

state 155

    (88) term -> factor term2 DIV term1 . term
    (88) term -> . factor term2 DIV term1 term
    (89) term -> . factor term2 MULT term1 term
    (90) term -> . factor term2
    (93) factor -> . FALSE ctes4
    (94) factor -> . TRUE ctes4
    (95) factor -> . CTE_STR ctes3
    (96) factor -> . CTE_FLT ctes2
    (97) factor -> . CTE_NUM ctes1
    (98) factor -> . ID fact1 LPAREN logic multiexp RPAREN
    (99) factor -> . ID fact1 arr
    FALSE           shift and go to state 82
    TRUE            shift and go to state 83
    CTE_STR         shift and go to state 84
    CTE_FLT         shift and go to state 85
    CTE_NUM         shift and go to state 86
    ID              shift and go to state 87

    factor                         shift and go to state 81
    term                           shift and go to state 175

state 156

    (89) term -> factor term2 MULT term1 . term
    (88) term -> . factor term2 DIV term1 term
    (89) term -> . factor term2 MULT term1 term
    (90) term -> . factor term2
    (93) factor -> . FALSE ctes4
    (94) factor -> . TRUE ctes4
    (95) factor -> . CTE_STR ctes3
    (96) factor -> . CTE_FLT ctes2
    (97) factor -> . CTE_NUM ctes1
    (98) factor -> . ID fact1 LPAREN logic multiexp RPAREN
    (99) factor -> . ID fact1 arr
    FALSE           shift and go to state 82
    TRUE            shift and go to state 83
    CTE_STR         shift and go to state 84
    CTE_FLT         shift and go to state 85
    CTE_NUM         shift and go to state 86
    ID              shift and go to state 87

    factor                         shift and go to state 81
    term                           shift and go to state 176

state 157

    (98) factor -> ID fact1 LPAREN logic . multiexp RPAREN
    (105) multiexp -> . empty
    (106) multiexp -> . COMMA logic multiexp
    (117) empty -> .
    COMMA           shift and go to state 179
    RPAREN          reduce using rule 117 (empty -> .)

    multiexp                       shift and go to state 177
    empty                          shift and go to state 178

state 158

    (8) multivd -> tipo prog4 COLON ID prog5 arr multid SEMICLN multivd .
    COMMA           reduce using rule 8 (multivd -> tipo prog4 COLON ID prog5 arr multid SEMICLN multivd .)
    FUNC            reduce using rule 8 (multivd -> tipo prog4 COLON ID prog5 arr multid SEMICLN multivd .)
    MAIN            reduce using rule 8 (multivd -> tipo prog4 COLON ID prog5 arr multid SEMICLN multivd .)
    WHILE           reduce using rule 8 (multivd -> tipo prog4 COLON ID prog5 arr multid SEMICLN multivd .)
    IF              reduce using rule 8 (multivd -> tipo prog4 COLON ID prog5 arr multid SEMICLN multivd .)
    WRITE           reduce using rule 8 (multivd -> tipo prog4 COLON ID prog5 arr multid SEMICLN multivd .)
    READ            reduce using rule 8 (multivd -> tipo prog4 COLON ID prog5 arr multid SEMICLN multivd .)
    RETURN          reduce using rule 8 (multivd -> tipo prog4 COLON ID prog5 arr multid SEMICLN multivd .)
    ID              reduce using rule 8 (multivd -> tipo prog4 COLON ID prog5 arr multid SEMICLN multivd .)
    RCURLY          reduce using rule 8 (multivd -> tipo prog4 COLON ID prog5 arr multid SEMICLN multivd .)


state 159

    (113) while_stmnt -> WHILE while1 LPAREN logic while2 RPAREN . stmnt while3 END
    (36) stmnt -> . empty
    (37) stmnt -> . while_stmnt stmnt
    (38) stmnt -> . if_stmnt stmnt
    (39) stmnt -> . write_stmnt stmnt
    (40) stmnt -> . read_stmnt stmnt
    (41) stmnt -> . ret_stmnt stmnt
    (42) stmnt -> . func_stmnt stmnt
    (43) stmnt -> . ass_stmnt stmnt
    (117) empty -> .
    (113) while_stmnt -> . WHILE while1 LPAREN logic while2 RPAREN stmnt while3 END
    (107) if_stmnt -> . IF LPAREN logic if1 RPAREN stmnt else_stmnt END if2
    (62) write_stmnt -> . WRITE io1 LPAREN logic io2 multio RPAREN io3 SEMICLN
    (61) read_stmnt -> . READ io1 LPAREN logic multio io2 RPAREN io3 SEMICLN
    (59) ret_stmnt -> . RETURN LPAREN logic RPAREN rettrue SEMICLN
    (49) func_stmnt -> . ID fc1 LPAREN fc2 arg fc4 RPAREN fc5 SEMICLN
    (44) ass_stmnt -> . ID arr ASS func_stmnt SEMICLN
    (45) ass_stmnt -> . ID ass1 arr ASS ass2 logic ass3 SEMICLN
    END             reduce using rule 117 (empty -> .)
    WHILE           shift and go to state 49
    IF              shift and go to state 50
    WRITE           shift and go to state 51
    READ            shift and go to state 52
    RETURN          shift and go to state 53
    ID              shift and go to state 54

    stmnt                          shift and go to state 180
    empty                          shift and go to state 41
    while_stmnt                    shift and go to state 42
    if_stmnt                       shift and go to state 43
    write_stmnt                    shift and go to state 44
    read_stmnt                     shift and go to state 45
    ret_stmnt                      shift and go to state 46
    func_stmnt                     shift and go to state 47
    ass_stmnt                      shift and go to state 48

state 160

    (107) if_stmnt -> IF LPAREN logic if1 RPAREN stmnt . else_stmnt END if2
    (110) else_stmnt -> . empty
    (111) else_stmnt -> . ELSE else1 stmnt
    (117) empty -> .
    ELSE            shift and go to state 183
    END             reduce using rule 117 (empty -> .)

    else_stmnt                     shift and go to state 181
    empty                          shift and go to state 182

state 161

    (68) logic -> rel log2 OR log1 . logic
    (68) logic -> . rel log2 OR log1 logic
    (69) logic -> . rel log2 AND log1 logic
    (70) logic -> . rel log2
    (79) rel -> . exp rel2 relop rel1 rel
    (80) rel -> . exp rel2
    (83) exp -> . term exp2 SUB exp1 exp
    (84) exp -> . term exp2 SUM exp1 exp
    (85) exp -> . term exp2
    (88) term -> . factor term2 DIV term1 term
    (89) term -> . factor term2 MULT term1 term
    (90) term -> . factor term2
    (93) factor -> . FALSE ctes4
    (94) factor -> . TRUE ctes4
    (95) factor -> . CTE_STR ctes3
    (96) factor -> . CTE_FLT ctes2
    (97) factor -> . CTE_NUM ctes1
    (98) factor -> . ID fact1 LPAREN logic multiexp RPAREN
    (99) factor -> . ID fact1 arr
    FALSE           shift and go to state 82
    TRUE            shift and go to state 83
    CTE_STR         shift and go to state 84
    CTE_FLT         shift and go to state 85
    CTE_NUM         shift and go to state 86
    ID              shift and go to state 87

    rel                            shift and go to state 91
    logic                          shift and go to state 184
    exp                            shift and go to state 92
    term                           shift and go to state 80
    factor                         shift and go to state 81

state 162

    (69) logic -> rel log2 AND log1 . logic
    (68) logic -> . rel log2 OR log1 logic
    (69) logic -> . rel log2 AND log1 logic
    (70) logic -> . rel log2
    (79) rel -> . exp rel2 relop rel1 rel
    (80) rel -> . exp rel2
    (83) exp -> . term exp2 SUB exp1 exp
    (84) exp -> . term exp2 SUM exp1 exp
    (85) exp -> . term exp2
    (88) term -> . factor term2 DIV term1 term
    (89) term -> . factor term2 MULT term1 term
    (90) term -> . factor term2
    (93) factor -> . FALSE ctes4
    (94) factor -> . TRUE ctes4
    (95) factor -> . CTE_STR ctes3
    (96) factor -> . CTE_FLT ctes2
    (97) factor -> . CTE_NUM ctes1
    (98) factor -> . ID fact1 LPAREN logic multiexp RPAREN
    (99) factor -> . ID fact1 arr
    FALSE           shift and go to state 82
    TRUE            shift and go to state 83
    CTE_STR         shift and go to state 84
    CTE_FLT         shift and go to state 85
    CTE_NUM         shift and go to state 86
    ID              shift and go to state 87

    rel                            shift and go to state 91
    logic                          shift and go to state 185
    exp                            shift and go to state 92
    term                           shift and go to state 80
    factor                         shift and go to state 81

state 163

    (79) rel -> exp rel2 relop rel1 . rel
    (79) rel -> . exp rel2 relop rel1 rel
    (80) rel -> . exp rel2
    (83) exp -> . term exp2 SUB exp1 exp
    (84) exp -> . term exp2 SUM exp1 exp
    (85) exp -> . term exp2
    (88) term -> . factor term2 DIV term1 term
    (89) term -> . factor term2 MULT term1 term
    (90) term -> . factor term2
    (93) factor -> . FALSE ctes4
    (94) factor -> . TRUE ctes4
    (95) factor -> . CTE_STR ctes3
    (96) factor -> . CTE_FLT ctes2
    (97) factor -> . CTE_NUM ctes1
    (98) factor -> . ID fact1 LPAREN logic multiexp RPAREN
    (99) factor -> . ID fact1 arr
    FALSE           shift and go to state 82
    TRUE            shift and go to state 83
    CTE_STR         shift and go to state 84
    CTE_FLT         shift and go to state 85
    CTE_NUM         shift and go to state 86
    ID              shift and go to state 87

    exp                            shift and go to state 92
    rel                            shift and go to state 186
    term                           shift and go to state 80
    factor                         shift and go to state 81

state 164

    (62) write_stmnt -> WRITE io1 LPAREN logic io2 multio . RPAREN io3 SEMICLN
    RPAREN          shift and go to state 187


state 165

    (61) read_stmnt -> READ io1 LPAREN logic multio io2 . RPAREN io3 SEMICLN
    RPAREN          shift and go to state 188


state 166

    (64) multio -> COMMA logic . io2 multio
    (66) io2 -> .
    COMMA           reduce using rule 66 (io2 -> .)
    RPAREN          reduce using rule 66 (io2 -> .)

    io2                            shift and go to state 189

state 167

    (59) ret_stmnt -> RETURN LPAREN logic RPAREN rettrue SEMICLN .
    WHILE           reduce using rule 59 (ret_stmnt -> RETURN LPAREN logic RPAREN rettrue SEMICLN .)
    IF              reduce using rule 59 (ret_stmnt -> RETURN LPAREN logic RPAREN rettrue SEMICLN .)
    WRITE           reduce using rule 59 (ret_stmnt -> RETURN LPAREN logic RPAREN rettrue SEMICLN .)
    READ            reduce using rule 59 (ret_stmnt -> RETURN LPAREN logic RPAREN rettrue SEMICLN .)
    RETURN          reduce using rule 59 (ret_stmnt -> RETURN LPAREN logic RPAREN rettrue SEMICLN .)
    ID              reduce using rule 59 (ret_stmnt -> RETURN LPAREN logic RPAREN rettrue SEMICLN .)
    $end            reduce using rule 59 (ret_stmnt -> RETURN LPAREN logic RPAREN rettrue SEMICLN .)
    ELSE            reduce using rule 59 (ret_stmnt -> RETURN LPAREN logic RPAREN rettrue SEMICLN .)
    END             reduce using rule 59 (ret_stmnt -> RETURN LPAREN logic RPAREN rettrue SEMICLN .)
    RCURLY          reduce using rule 59 (ret_stmnt -> RETURN LPAREN logic RPAREN rettrue SEMICLN .)


state 168

    (49) func_stmnt -> ID fc1 LPAREN fc2 arg fc4 . RPAREN fc5 SEMICLN
    RPAREN          shift and go to state 190


state 169

    (53) arg -> logic fc3 . multiarg
    (57) multiarg -> . empty
    (58) multiarg -> . COMMA arg multiarg
    (117) empty -> .
  ! shift/reduce conflict for COMMA resolved as shift
    COMMA           shift and go to state 193
    RPAREN          reduce using rule 117 (empty -> .)

    multiarg                       shift and go to state 191
    empty                          shift and go to state 192

state 170

    (45) ass_stmnt -> ID ass1 arr ASS ass2 logic . ass3 SEMICLN
    (48) ass3 -> .
    SEMICLN         reduce using rule 48 (ass3 -> .)

    ass3                           shift and go to state 194

state 171

    (20) funcdecl -> FUNC tipofunc func1 ID func2 LPAREN param RPAREN func3 LCURLY varsdecl . func4 stmnt RCURLY resetvarcont funcdecl
    (24) func4 -> .
    WHILE           reduce using rule 24 (func4 -> .)
    IF              reduce using rule 24 (func4 -> .)
    WRITE           reduce using rule 24 (func4 -> .)
    READ            reduce using rule 24 (func4 -> .)
    RETURN          reduce using rule 24 (func4 -> .)
    ID              reduce using rule 24 (func4 -> .)
    RCURLY          reduce using rule 24 (func4 -> .)

    func4                          shift and go to state 195

state 172

    (29) param -> tipo param1 COLON ID param2 . multiparam
    (32) multiparam -> . empty
    (33) multiparam -> . COMMA param
    (117) empty -> .
    COMMA           shift and go to state 198
    RPAREN          reduce using rule 117 (empty -> .)

    multiparam                     shift and go to state 196
    empty                          shift and go to state 197

state 173

    (83) exp -> term exp2 SUB exp1 exp .
    RSQUARE         reduce using rule 83 (exp -> term exp2 SUB exp1 exp .)
    EQUAL_TO        reduce using rule 83 (exp -> term exp2 SUB exp1 exp .)
    DIFFERENT_TO    reduce using rule 83 (exp -> term exp2 SUB exp1 exp .)
    LESS_OR_EQ_THAN reduce using rule 83 (exp -> term exp2 SUB exp1 exp .)
    MORE_OR_EQ_THAN reduce using rule 83 (exp -> term exp2 SUB exp1 exp .)
    LESS_THAN       reduce using rule 83 (exp -> term exp2 SUB exp1 exp .)
    MORE_THAN       reduce using rule 83 (exp -> term exp2 SUB exp1 exp .)
    OR              reduce using rule 83 (exp -> term exp2 SUB exp1 exp .)
    AND             reduce using rule 83 (exp -> term exp2 SUB exp1 exp .)
    RPAREN          reduce using rule 83 (exp -> term exp2 SUB exp1 exp .)
    COMMA           reduce using rule 83 (exp -> term exp2 SUB exp1 exp .)
    SEMICLN         reduce using rule 83 (exp -> term exp2 SUB exp1 exp .)


state 174

    (84) exp -> term exp2 SUM exp1 exp .
    RSQUARE         reduce using rule 84 (exp -> term exp2 SUM exp1 exp .)
    EQUAL_TO        reduce using rule 84 (exp -> term exp2 SUM exp1 exp .)
    DIFFERENT_TO    reduce using rule 84 (exp -> term exp2 SUM exp1 exp .)
    LESS_OR_EQ_THAN reduce using rule 84 (exp -> term exp2 SUM exp1 exp .)
    MORE_OR_EQ_THAN reduce using rule 84 (exp -> term exp2 SUM exp1 exp .)
    LESS_THAN       reduce using rule 84 (exp -> term exp2 SUM exp1 exp .)
    MORE_THAN       reduce using rule 84 (exp -> term exp2 SUM exp1 exp .)
    OR              reduce using rule 84 (exp -> term exp2 SUM exp1 exp .)
    AND             reduce using rule 84 (exp -> term exp2 SUM exp1 exp .)
    RPAREN          reduce using rule 84 (exp -> term exp2 SUM exp1 exp .)
    COMMA           reduce using rule 84 (exp -> term exp2 SUM exp1 exp .)
    SEMICLN         reduce using rule 84 (exp -> term exp2 SUM exp1 exp .)


state 175

    (88) term -> factor term2 DIV term1 term .
    SUB             reduce using rule 88 (term -> factor term2 DIV term1 term .)
    SUM             reduce using rule 88 (term -> factor term2 DIV term1 term .)
    RSQUARE         reduce using rule 88 (term -> factor term2 DIV term1 term .)
    EQUAL_TO        reduce using rule 88 (term -> factor term2 DIV term1 term .)
    DIFFERENT_TO    reduce using rule 88 (term -> factor term2 DIV term1 term .)
    LESS_OR_EQ_THAN reduce using rule 88 (term -> factor term2 DIV term1 term .)
    MORE_OR_EQ_THAN reduce using rule 88 (term -> factor term2 DIV term1 term .)
    LESS_THAN       reduce using rule 88 (term -> factor term2 DIV term1 term .)
    MORE_THAN       reduce using rule 88 (term -> factor term2 DIV term1 term .)
    OR              reduce using rule 88 (term -> factor term2 DIV term1 term .)
    AND             reduce using rule 88 (term -> factor term2 DIV term1 term .)
    RPAREN          reduce using rule 88 (term -> factor term2 DIV term1 term .)
    COMMA           reduce using rule 88 (term -> factor term2 DIV term1 term .)
    SEMICLN         reduce using rule 88 (term -> factor term2 DIV term1 term .)


state 176

    (89) term -> factor term2 MULT term1 term .
    SUB             reduce using rule 89 (term -> factor term2 MULT term1 term .)
    SUM             reduce using rule 89 (term -> factor term2 MULT term1 term .)
    RSQUARE         reduce using rule 89 (term -> factor term2 MULT term1 term .)
    EQUAL_TO        reduce using rule 89 (term -> factor term2 MULT term1 term .)
    DIFFERENT_TO    reduce using rule 89 (term -> factor term2 MULT term1 term .)
    LESS_OR_EQ_THAN reduce using rule 89 (term -> factor term2 MULT term1 term .)
    MORE_OR_EQ_THAN reduce using rule 89 (term -> factor term2 MULT term1 term .)
    LESS_THAN       reduce using rule 89 (term -> factor term2 MULT term1 term .)
    MORE_THAN       reduce using rule 89 (term -> factor term2 MULT term1 term .)
    OR              reduce using rule 89 (term -> factor term2 MULT term1 term .)
    AND             reduce using rule 89 (term -> factor term2 MULT term1 term .)
    RPAREN          reduce using rule 89 (term -> factor term2 MULT term1 term .)
    COMMA           reduce using rule 89 (term -> factor term2 MULT term1 term .)
    SEMICLN         reduce using rule 89 (term -> factor term2 MULT term1 term .)


state 177

    (98) factor -> ID fact1 LPAREN logic multiexp . RPAREN
    RPAREN          shift and go to state 199


state 178

    (105) multiexp -> empty .
    RPAREN          reduce using rule 105 (multiexp -> empty .)


state 179

    (106) multiexp -> COMMA . logic multiexp
    (68) logic -> . rel log2 OR log1 logic
    (69) logic -> . rel log2 AND log1 logic
    (70) logic -> . rel log2
    (79) rel -> . exp rel2 relop rel1 rel
    (80) rel -> . exp rel2
    (83) exp -> . term exp2 SUB exp1 exp
    (84) exp -> . term exp2 SUM exp1 exp
    (85) exp -> . term exp2
    (88) term -> . factor term2 DIV term1 term
    (89) term -> . factor term2 MULT term1 term
    (90) term -> . factor term2
    (93) factor -> . FALSE ctes4
    (94) factor -> . TRUE ctes4
    (95) factor -> . CTE_STR ctes3
    (96) factor -> . CTE_FLT ctes2
    (97) factor -> . CTE_NUM ctes1
    (98) factor -> . ID fact1 LPAREN logic multiexp RPAREN
    (99) factor -> . ID fact1 arr
    FALSE           shift and go to state 82
    TRUE            shift and go to state 83
    CTE_STR         shift and go to state 84
    CTE_FLT         shift and go to state 85
    CTE_NUM         shift and go to state 86
    ID              shift and go to state 87

    logic                          shift and go to state 200
    rel                            shift and go to state 91
    exp                            shift and go to state 92
    term                           shift and go to state 80
    factor                         shift and go to state 81

state 180

    (113) while_stmnt -> WHILE while1 LPAREN logic while2 RPAREN stmnt . while3 END
    (116) while3 -> .
    END             reduce using rule 116 (while3 -> .)

    while3                         shift and go to state 201

state 181

    (107) if_stmnt -> IF LPAREN logic if1 RPAREN stmnt else_stmnt . END if2
    END             shift and go to state 202


state 182

    (110) else_stmnt -> empty .
    END             reduce using rule 110 (else_stmnt -> empty .)


state 183

    (111) else_stmnt -> ELSE . else1 stmnt
    (112) else1 -> .
    WHILE           reduce using rule 112 (else1 -> .)
    IF              reduce using rule 112 (else1 -> .)
    WRITE           reduce using rule 112 (else1 -> .)
    READ            reduce using rule 112 (else1 -> .)
    RETURN          reduce using rule 112 (else1 -> .)
    ID              reduce using rule 112 (else1 -> .)
    END             reduce using rule 112 (else1 -> .)

    else1                          shift and go to state 203

state 184

    (68) logic -> rel log2 OR log1 logic .
    RPAREN          reduce using rule 68 (logic -> rel log2 OR log1 logic .)
    COMMA           reduce using rule 68 (logic -> rel log2 OR log1 logic .)
    SEMICLN         reduce using rule 68 (logic -> rel log2 OR log1 logic .)


state 185

    (69) logic -> rel log2 AND log1 logic .
    RPAREN          reduce using rule 69 (logic -> rel log2 AND log1 logic .)
    COMMA           reduce using rule 69 (logic -> rel log2 AND log1 logic .)
    SEMICLN         reduce using rule 69 (logic -> rel log2 AND log1 logic .)


state 186

    (79) rel -> exp rel2 relop rel1 rel .
    OR              reduce using rule 79 (rel -> exp rel2 relop rel1 rel .)
    AND             reduce using rule 79 (rel -> exp rel2 relop rel1 rel .)
    RPAREN          reduce using rule 79 (rel -> exp rel2 relop rel1 rel .)
    COMMA           reduce using rule 79 (rel -> exp rel2 relop rel1 rel .)
    SEMICLN         reduce using rule 79 (rel -> exp rel2 relop rel1 rel .)


state 187

    (62) write_stmnt -> WRITE io1 LPAREN logic io2 multio RPAREN . io3 SEMICLN
    (67) io3 -> .
    SEMICLN         reduce using rule 67 (io3 -> .)

    io3                            shift and go to state 204

state 188

    (61) read_stmnt -> READ io1 LPAREN logic multio io2 RPAREN . io3 SEMICLN
    (67) io3 -> .
    SEMICLN         reduce using rule 67 (io3 -> .)

    io3                            shift and go to state 205

state 189

    (64) multio -> COMMA logic io2 . multio
    (63) multio -> .
    (64) multio -> . COMMA logic io2 multio
    RPAREN          reduce using rule 63 (multio -> .)
    COMMA           shift and go to state 144

    multio                         shift and go to state 206

state 190

    (49) func_stmnt -> ID fc1 LPAREN fc2 arg fc4 RPAREN . fc5 SEMICLN
    (56) fc5 -> .
    SEMICLN         reduce using rule 56 (fc5 -> .)

    fc5                            shift and go to state 207

state 191

    (53) arg -> logic fc3 multiarg .
    RPAREN          reduce using rule 53 (arg -> logic fc3 multiarg .)
    COMMA           reduce using rule 53 (arg -> logic fc3 multiarg .)


state 192

    (57) multiarg -> empty .
    COMMA           reduce using rule 57 (multiarg -> empty .)
    RPAREN          reduce using rule 57 (multiarg -> empty .)


state 193

    (58) multiarg -> COMMA . arg multiarg
    (52) arg -> . empty
    (53) arg -> . logic fc3 multiarg
    (117) empty -> .
    (68) logic -> . rel log2 OR log1 logic
    (69) logic -> . rel log2 AND log1 logic
    (70) logic -> . rel log2
    (79) rel -> . exp rel2 relop rel1 rel
    (80) rel -> . exp rel2
    (83) exp -> . term exp2 SUB exp1 exp
    (84) exp -> . term exp2 SUM exp1 exp
    (85) exp -> . term exp2
    (88) term -> . factor term2 DIV term1 term
    (89) term -> . factor term2 MULT term1 term
    (90) term -> . factor term2
    (93) factor -> . FALSE ctes4
    (94) factor -> . TRUE ctes4
    (95) factor -> . CTE_STR ctes3
    (96) factor -> . CTE_FLT ctes2
    (97) factor -> . CTE_NUM ctes1
    (98) factor -> . ID fact1 LPAREN logic multiexp RPAREN
    (99) factor -> . ID fact1 arr
    COMMA           reduce using rule 117 (empty -> .)
    RPAREN          reduce using rule 117 (empty -> .)
    FALSE           shift and go to state 82
    TRUE            shift and go to state 83
    CTE_STR         shift and go to state 84
    CTE_FLT         shift and go to state 85
    CTE_NUM         shift and go to state 86
    ID              shift and go to state 87

    arg                            shift and go to state 208
    empty                          shift and go to state 147
    logic                          shift and go to state 148
    rel                            shift and go to state 91
    exp                            shift and go to state 92
    term                           shift and go to state 80
    factor                         shift and go to state 81

state 194

    (45) ass_stmnt -> ID ass1 arr ASS ass2 logic ass3 . SEMICLN
    SEMICLN         shift and go to state 209


state 195

    (20) funcdecl -> FUNC tipofunc func1 ID func2 LPAREN param RPAREN func3 LCURLY varsdecl func4 . stmnt RCURLY resetvarcont funcdecl
    (36) stmnt -> . empty
    (37) stmnt -> . while_stmnt stmnt
    (38) stmnt -> . if_stmnt stmnt
    (39) stmnt -> . write_stmnt stmnt
    (40) stmnt -> . read_stmnt stmnt
    (41) stmnt -> . ret_stmnt stmnt
    (42) stmnt -> . func_stmnt stmnt
    (43) stmnt -> . ass_stmnt stmnt
    (117) empty -> .
    (113) while_stmnt -> . WHILE while1 LPAREN logic while2 RPAREN stmnt while3 END
    (107) if_stmnt -> . IF LPAREN logic if1 RPAREN stmnt else_stmnt END if2
    (62) write_stmnt -> . WRITE io1 LPAREN logic io2 multio RPAREN io3 SEMICLN
    (61) read_stmnt -> . READ io1 LPAREN logic multio io2 RPAREN io3 SEMICLN
    (59) ret_stmnt -> . RETURN LPAREN logic RPAREN rettrue SEMICLN
    (49) func_stmnt -> . ID fc1 LPAREN fc2 arg fc4 RPAREN fc5 SEMICLN
    (44) ass_stmnt -> . ID arr ASS func_stmnt SEMICLN
    (45) ass_stmnt -> . ID ass1 arr ASS ass2 logic ass3 SEMICLN
    RCURLY          reduce using rule 117 (empty -> .)
    WHILE           shift and go to state 49
    IF              shift and go to state 50
    WRITE           shift and go to state 51
    READ            shift and go to state 52
    RETURN          shift and go to state 53
    ID              shift and go to state 54

    stmnt                          shift and go to state 210
    empty                          shift and go to state 41
    while_stmnt                    shift and go to state 42
    if_stmnt                       shift and go to state 43
    write_stmnt                    shift and go to state 44
    read_stmnt                     shift and go to state 45
    ret_stmnt                      shift and go to state 46
    func_stmnt                     shift and go to state 47
    ass_stmnt                      shift and go to state 48

state 196

    (29) param -> tipo param1 COLON ID param2 multiparam .
    RPAREN          reduce using rule 29 (param -> tipo param1 COLON ID param2 multiparam .)


state 197

    (32) multiparam -> empty .
    RPAREN          reduce using rule 32 (multiparam -> empty .)


state 198

    (33) multiparam -> COMMA . param
    (28) param -> . empty
    (29) param -> . tipo param1 COLON ID param2 multiparam
    (117) empty -> .
    (13) tipo -> . BOOL
    (14) tipo -> . CHAR
    (15) tipo -> . FLOAT
    (16) tipo -> . INT
    RPAREN          reduce using rule 117 (empty -> .)
    BOOL            shift and go to state 19
    CHAR            shift and go to state 20
    FLOAT           shift and go to state 21
    INT             shift and go to state 22

    param                          shift and go to state 211
    empty                          shift and go to state 76
    tipo                           shift and go to state 77

state 199

    (98) factor -> ID fact1 LPAREN logic multiexp RPAREN .
    DIV             reduce using rule 98 (factor -> ID fact1 LPAREN logic multiexp RPAREN .)
    MULT            reduce using rule 98 (factor -> ID fact1 LPAREN logic multiexp RPAREN .)
    SUB             reduce using rule 98 (factor -> ID fact1 LPAREN logic multiexp RPAREN .)
    SUM             reduce using rule 98 (factor -> ID fact1 LPAREN logic multiexp RPAREN .)
    RSQUARE         reduce using rule 98 (factor -> ID fact1 LPAREN logic multiexp RPAREN .)
    EQUAL_TO        reduce using rule 98 (factor -> ID fact1 LPAREN logic multiexp RPAREN .)
    DIFFERENT_TO    reduce using rule 98 (factor -> ID fact1 LPAREN logic multiexp RPAREN .)
    LESS_OR_EQ_THAN reduce using rule 98 (factor -> ID fact1 LPAREN logic multiexp RPAREN .)
    MORE_OR_EQ_THAN reduce using rule 98 (factor -> ID fact1 LPAREN logic multiexp RPAREN .)
    LESS_THAN       reduce using rule 98 (factor -> ID fact1 LPAREN logic multiexp RPAREN .)
    MORE_THAN       reduce using rule 98 (factor -> ID fact1 LPAREN logic multiexp RPAREN .)
    OR              reduce using rule 98 (factor -> ID fact1 LPAREN logic multiexp RPAREN .)
    AND             reduce using rule 98 (factor -> ID fact1 LPAREN logic multiexp RPAREN .)
    RPAREN          reduce using rule 98 (factor -> ID fact1 LPAREN logic multiexp RPAREN .)
    COMMA           reduce using rule 98 (factor -> ID fact1 LPAREN logic multiexp RPAREN .)
    SEMICLN         reduce using rule 98 (factor -> ID fact1 LPAREN logic multiexp RPAREN .)


state 200

    (106) multiexp -> COMMA logic . multiexp
    (105) multiexp -> . empty
    (106) multiexp -> . COMMA logic multiexp
    (117) empty -> .
    COMMA           shift and go to state 179
    RPAREN          reduce using rule 117 (empty -> .)

    multiexp                       shift and go to state 212
    empty                          shift and go to state 178

state 201

    (113) while_stmnt -> WHILE while1 LPAREN logic while2 RPAREN stmnt while3 . END
    END             shift and go to state 213


state 202

    (107) if_stmnt -> IF LPAREN logic if1 RPAREN stmnt else_stmnt END . if2
    (109) if2 -> .
    WHILE           reduce using rule 109 (if2 -> .)
    IF              reduce using rule 109 (if2 -> .)
    WRITE           reduce using rule 109 (if2 -> .)
    READ            reduce using rule 109 (if2 -> .)
    RETURN          reduce using rule 109 (if2 -> .)
    ID              reduce using rule 109 (if2 -> .)
    $end            reduce using rule 109 (if2 -> .)
    ELSE            reduce using rule 109 (if2 -> .)
    END             reduce using rule 109 (if2 -> .)
    RCURLY          reduce using rule 109 (if2 -> .)

    if2                            shift and go to state 214

state 203

    (111) else_stmnt -> ELSE else1 . stmnt
    (36) stmnt -> . empty
    (37) stmnt -> . while_stmnt stmnt
    (38) stmnt -> . if_stmnt stmnt
    (39) stmnt -> . write_stmnt stmnt
    (40) stmnt -> . read_stmnt stmnt
    (41) stmnt -> . ret_stmnt stmnt
    (42) stmnt -> . func_stmnt stmnt
    (43) stmnt -> . ass_stmnt stmnt
    (117) empty -> .
    (113) while_stmnt -> . WHILE while1 LPAREN logic while2 RPAREN stmnt while3 END
    (107) if_stmnt -> . IF LPAREN logic if1 RPAREN stmnt else_stmnt END if2
    (62) write_stmnt -> . WRITE io1 LPAREN logic io2 multio RPAREN io3 SEMICLN
    (61) read_stmnt -> . READ io1 LPAREN logic multio io2 RPAREN io3 SEMICLN
    (59) ret_stmnt -> . RETURN LPAREN logic RPAREN rettrue SEMICLN
    (49) func_stmnt -> . ID fc1 LPAREN fc2 arg fc4 RPAREN fc5 SEMICLN
    (44) ass_stmnt -> . ID arr ASS func_stmnt SEMICLN
    (45) ass_stmnt -> . ID ass1 arr ASS ass2 logic ass3 SEMICLN
    END             reduce using rule 117 (empty -> .)
    WHILE           shift and go to state 49
    IF              shift and go to state 50
    WRITE           shift and go to state 51
    READ            shift and go to state 52
    RETURN          shift and go to state 53
    ID              shift and go to state 54

    stmnt                          shift and go to state 215
    empty                          shift and go to state 41
    while_stmnt                    shift and go to state 42
    if_stmnt                       shift and go to state 43
    write_stmnt                    shift and go to state 44
    read_stmnt                     shift and go to state 45
    ret_stmnt                      shift and go to state 46
    func_stmnt                     shift and go to state 47
    ass_stmnt                      shift and go to state 48

state 204

    (62) write_stmnt -> WRITE io1 LPAREN logic io2 multio RPAREN io3 . SEMICLN
    SEMICLN         shift and go to state 216


state 205

    (61) read_stmnt -> READ io1 LPAREN logic multio io2 RPAREN io3 . SEMICLN
    SEMICLN         shift and go to state 217


state 206

    (64) multio -> COMMA logic io2 multio .
    RPAREN          reduce using rule 64 (multio -> COMMA logic io2 multio .)


state 207

    (49) func_stmnt -> ID fc1 LPAREN fc2 arg fc4 RPAREN fc5 . SEMICLN
    SEMICLN         shift and go to state 218


state 208

    (58) multiarg -> COMMA arg . multiarg
    (57) multiarg -> . empty
    (58) multiarg -> . COMMA arg multiarg
    (117) empty -> .
  ! shift/reduce conflict for COMMA resolved as shift
    COMMA           shift and go to state 193
    RPAREN          reduce using rule 117 (empty -> .)

    multiarg                       shift and go to state 219
    empty                          shift and go to state 192

state 209

    (45) ass_stmnt -> ID ass1 arr ASS ass2 logic ass3 SEMICLN .
    WHILE           reduce using rule 45 (ass_stmnt -> ID ass1 arr ASS ass2 logic ass3 SEMICLN .)
    IF              reduce using rule 45 (ass_stmnt -> ID ass1 arr ASS ass2 logic ass3 SEMICLN .)
    WRITE           reduce using rule 45 (ass_stmnt -> ID ass1 arr ASS ass2 logic ass3 SEMICLN .)
    READ            reduce using rule 45 (ass_stmnt -> ID ass1 arr ASS ass2 logic ass3 SEMICLN .)
    RETURN          reduce using rule 45 (ass_stmnt -> ID ass1 arr ASS ass2 logic ass3 SEMICLN .)
    ID              reduce using rule 45 (ass_stmnt -> ID ass1 arr ASS ass2 logic ass3 SEMICLN .)
    $end            reduce using rule 45 (ass_stmnt -> ID ass1 arr ASS ass2 logic ass3 SEMICLN .)
    ELSE            reduce using rule 45 (ass_stmnt -> ID ass1 arr ASS ass2 logic ass3 SEMICLN .)
    END             reduce using rule 45 (ass_stmnt -> ID ass1 arr ASS ass2 logic ass3 SEMICLN .)
    RCURLY          reduce using rule 45 (ass_stmnt -> ID ass1 arr ASS ass2 logic ass3 SEMICLN .)


state 210

    (20) funcdecl -> FUNC tipofunc func1 ID func2 LPAREN param RPAREN func3 LCURLY varsdecl func4 stmnt . RCURLY resetvarcont funcdecl
    RCURLY          shift and go to state 220


state 211

    (33) multiparam -> COMMA param .
    RPAREN          reduce using rule 33 (multiparam -> COMMA param .)


state 212

    (106) multiexp -> COMMA logic multiexp .
    RPAREN          reduce using rule 106 (multiexp -> COMMA logic multiexp .)


state 213

    (113) while_stmnt -> WHILE while1 LPAREN logic while2 RPAREN stmnt while3 END .
    WHILE           reduce using rule 113 (while_stmnt -> WHILE while1 LPAREN logic while2 RPAREN stmnt while3 END .)
    IF              reduce using rule 113 (while_stmnt -> WHILE while1 LPAREN logic while2 RPAREN stmnt while3 END .)
    WRITE           reduce using rule 113 (while_stmnt -> WHILE while1 LPAREN logic while2 RPAREN stmnt while3 END .)
    READ            reduce using rule 113 (while_stmnt -> WHILE while1 LPAREN logic while2 RPAREN stmnt while3 END .)
    RETURN          reduce using rule 113 (while_stmnt -> WHILE while1 LPAREN logic while2 RPAREN stmnt while3 END .)
    ID              reduce using rule 113 (while_stmnt -> WHILE while1 LPAREN logic while2 RPAREN stmnt while3 END .)
    $end            reduce using rule 113 (while_stmnt -> WHILE while1 LPAREN logic while2 RPAREN stmnt while3 END .)
    ELSE            reduce using rule 113 (while_stmnt -> WHILE while1 LPAREN logic while2 RPAREN stmnt while3 END .)
    END             reduce using rule 113 (while_stmnt -> WHILE while1 LPAREN logic while2 RPAREN stmnt while3 END .)
    RCURLY          reduce using rule 113 (while_stmnt -> WHILE while1 LPAREN logic while2 RPAREN stmnt while3 END .)


state 214

    (107) if_stmnt -> IF LPAREN logic if1 RPAREN stmnt else_stmnt END if2 .
    WHILE           reduce using rule 107 (if_stmnt -> IF LPAREN logic if1 RPAREN stmnt else_stmnt END if2 .)
    IF              reduce using rule 107 (if_stmnt -> IF LPAREN logic if1 RPAREN stmnt else_stmnt END if2 .)
    WRITE           reduce using rule 107 (if_stmnt -> IF LPAREN logic if1 RPAREN stmnt else_stmnt END if2 .)
    READ            reduce using rule 107 (if_stmnt -> IF LPAREN logic if1 RPAREN stmnt else_stmnt END if2 .)
    RETURN          reduce using rule 107 (if_stmnt -> IF LPAREN logic if1 RPAREN stmnt else_stmnt END if2 .)
    ID              reduce using rule 107 (if_stmnt -> IF LPAREN logic if1 RPAREN stmnt else_stmnt END if2 .)
    $end            reduce using rule 107 (if_stmnt -> IF LPAREN logic if1 RPAREN stmnt else_stmnt END if2 .)
    ELSE            reduce using rule 107 (if_stmnt -> IF LPAREN logic if1 RPAREN stmnt else_stmnt END if2 .)
    END             reduce using rule 107 (if_stmnt -> IF LPAREN logic if1 RPAREN stmnt else_stmnt END if2 .)
    RCURLY          reduce using rule 107 (if_stmnt -> IF LPAREN logic if1 RPAREN stmnt else_stmnt END if2 .)


state 215

    (111) else_stmnt -> ELSE else1 stmnt .
    END             reduce using rule 111 (else_stmnt -> ELSE else1 stmnt .)


state 216

    (62) write_stmnt -> WRITE io1 LPAREN logic io2 multio RPAREN io3 SEMICLN .
    WHILE           reduce using rule 62 (write_stmnt -> WRITE io1 LPAREN logic io2 multio RPAREN io3 SEMICLN .)
    IF              reduce using rule 62 (write_stmnt -> WRITE io1 LPAREN logic io2 multio RPAREN io3 SEMICLN .)
    WRITE           reduce using rule 62 (write_stmnt -> WRITE io1 LPAREN logic io2 multio RPAREN io3 SEMICLN .)
    READ            reduce using rule 62 (write_stmnt -> WRITE io1 LPAREN logic io2 multio RPAREN io3 SEMICLN .)
    RETURN          reduce using rule 62 (write_stmnt -> WRITE io1 LPAREN logic io2 multio RPAREN io3 SEMICLN .)
    ID              reduce using rule 62 (write_stmnt -> WRITE io1 LPAREN logic io2 multio RPAREN io3 SEMICLN .)
    $end            reduce using rule 62 (write_stmnt -> WRITE io1 LPAREN logic io2 multio RPAREN io3 SEMICLN .)
    ELSE            reduce using rule 62 (write_stmnt -> WRITE io1 LPAREN logic io2 multio RPAREN io3 SEMICLN .)
    END             reduce using rule 62 (write_stmnt -> WRITE io1 LPAREN logic io2 multio RPAREN io3 SEMICLN .)
    RCURLY          reduce using rule 62 (write_stmnt -> WRITE io1 LPAREN logic io2 multio RPAREN io3 SEMICLN .)


state 217

    (61) read_stmnt -> READ io1 LPAREN logic multio io2 RPAREN io3 SEMICLN .
    WHILE           reduce using rule 61 (read_stmnt -> READ io1 LPAREN logic multio io2 RPAREN io3 SEMICLN .)
    IF              reduce using rule 61 (read_stmnt -> READ io1 LPAREN logic multio io2 RPAREN io3 SEMICLN .)
    WRITE           reduce using rule 61 (read_stmnt -> READ io1 LPAREN logic multio io2 RPAREN io3 SEMICLN .)
    READ            reduce using rule 61 (read_stmnt -> READ io1 LPAREN logic multio io2 RPAREN io3 SEMICLN .)
    RETURN          reduce using rule 61 (read_stmnt -> READ io1 LPAREN logic multio io2 RPAREN io3 SEMICLN .)
    ID              reduce using rule 61 (read_stmnt -> READ io1 LPAREN logic multio io2 RPAREN io3 SEMICLN .)
    $end            reduce using rule 61 (read_stmnt -> READ io1 LPAREN logic multio io2 RPAREN io3 SEMICLN .)
    ELSE            reduce using rule 61 (read_stmnt -> READ io1 LPAREN logic multio io2 RPAREN io3 SEMICLN .)
    END             reduce using rule 61 (read_stmnt -> READ io1 LPAREN logic multio io2 RPAREN io3 SEMICLN .)
    RCURLY          reduce using rule 61 (read_stmnt -> READ io1 LPAREN logic multio io2 RPAREN io3 SEMICLN .)


state 218

    (49) func_stmnt -> ID fc1 LPAREN fc2 arg fc4 RPAREN fc5 SEMICLN .
    WHILE           reduce using rule 49 (func_stmnt -> ID fc1 LPAREN fc2 arg fc4 RPAREN fc5 SEMICLN .)
    IF              reduce using rule 49 (func_stmnt -> ID fc1 LPAREN fc2 arg fc4 RPAREN fc5 SEMICLN .)
    WRITE           reduce using rule 49 (func_stmnt -> ID fc1 LPAREN fc2 arg fc4 RPAREN fc5 SEMICLN .)
    READ            reduce using rule 49 (func_stmnt -> ID fc1 LPAREN fc2 arg fc4 RPAREN fc5 SEMICLN .)
    RETURN          reduce using rule 49 (func_stmnt -> ID fc1 LPAREN fc2 arg fc4 RPAREN fc5 SEMICLN .)
    ID              reduce using rule 49 (func_stmnt -> ID fc1 LPAREN fc2 arg fc4 RPAREN fc5 SEMICLN .)
    $end            reduce using rule 49 (func_stmnt -> ID fc1 LPAREN fc2 arg fc4 RPAREN fc5 SEMICLN .)
    ELSE            reduce using rule 49 (func_stmnt -> ID fc1 LPAREN fc2 arg fc4 RPAREN fc5 SEMICLN .)
    END             reduce using rule 49 (func_stmnt -> ID fc1 LPAREN fc2 arg fc4 RPAREN fc5 SEMICLN .)
    RCURLY          reduce using rule 49 (func_stmnt -> ID fc1 LPAREN fc2 arg fc4 RPAREN fc5 SEMICLN .)
    SEMICLN         reduce using rule 49 (func_stmnt -> ID fc1 LPAREN fc2 arg fc4 RPAREN fc5 SEMICLN .)


state 219

    (58) multiarg -> COMMA arg multiarg .
    COMMA           reduce using rule 58 (multiarg -> COMMA arg multiarg .)
    RPAREN          reduce using rule 58 (multiarg -> COMMA arg multiarg .)


state 220

    (20) funcdecl -> FUNC tipofunc func1 ID func2 LPAREN param RPAREN func3 LCURLY varsdecl func4 stmnt RCURLY . resetvarcont funcdecl
    (25) resetvarcont -> .
    FUNC            reduce using rule 25 (resetvarcont -> .)
    MAIN            reduce using rule 25 (resetvarcont -> .)

    resetvarcont                   shift and go to state 221

state 221

    (20) funcdecl -> FUNC tipofunc func1 ID func2 LPAREN param RPAREN func3 LCURLY varsdecl func4 stmnt RCURLY resetvarcont . funcdecl
    (19) funcdecl -> . empty
    (20) funcdecl -> . FUNC tipofunc func1 ID func2 LPAREN param RPAREN func3 LCURLY varsdecl func4 stmnt RCURLY resetvarcont funcdecl
    (117) empty -> .
    FUNC            shift and go to state 12
    MAIN            reduce using rule 117 (empty -> .)

    funcdecl                       shift and go to state 222
    empty                          shift and go to state 11

state 222

    (20) funcdecl -> FUNC tipofunc func1 ID func2 LPAREN param RPAREN func3 LCURLY varsdecl func4 stmnt RCURLY resetvarcont funcdecl .
    MAIN            reduce using rule 20 (funcdecl -> FUNC tipofunc func1 ID func2 LPAREN param RPAREN func3 LCURLY varsdecl func4 stmnt RCURLY resetvarcont funcdecl .)


Conflicts:

shift/reduce conflict for LSQUARE in state 54 resolved as shift
shift/reduce conflict for COMMA in state 169 resolved as shift
shift/reduce conflict for COMMA in state 208 resolved as shift
reduce/reduce conflict in state 54 resolved using rule ass1 -> <empty>
rejected rule (empty -> <empty>) in state 54