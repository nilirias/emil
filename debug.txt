Grammar:

Rule 0     S' -> program
Rule 1     program -> PROGRAM prog1 ID prog2 SEMICLN varsdecl funcdecl main
Rule 2     prog1 -> <empty>
Rule 3     prog2 -> <empty>
Rule 4     varsdecl -> empty
Rule 5     varsdecl -> VARS prog3 multivd multid
Rule 6     prog3 -> <empty>
Rule 7     multivd -> empty
Rule 8     multivd -> tipo prog4 COLON ID prog5 arr multid SEMICLN multivd
Rule 9     prog4 -> <empty>
Rule 10    prog5 -> <empty>
Rule 11    multid -> empty
Rule 12    multid -> COMMA ID prog5 arr multid
Rule 13    tipo -> BOOL
Rule 14    tipo -> CHAR
Rule 15    tipo -> FLOAT
Rule 16    tipo -> INT
Rule 17    arr -> empty
Rule 18    arr -> LSQUARE exp RSQUARE
Rule 19    funcdecl -> empty
Rule 20    funcdecl -> FUNC tipofunc ID LPAREN param RPAREN varsdecl LCURLY stmnt RCURLY
Rule 21    tipofunc -> tipo
Rule 22    tipofunc -> VOID
Rule 23    param -> empty
Rule 24    param -> tipo COLON ID multiparam
Rule 25    multiparam -> empty
Rule 26    multiparam -> COMMA param
Rule 27    main -> MAIN LPAREN RPAREN stmnt
Rule 28    stmnt -> empty
Rule 29    stmnt -> while_stmnt stmnt
Rule 30    stmnt -> if_stmnt stmnt
Rule 31    stmnt -> write_stmnt stmnt
Rule 32    stmnt -> read_stmnt stmnt
Rule 33    stmnt -> ret_stmnt stmnt
Rule 34    stmnt -> func_stmnt stmnt
Rule 35    stmnt -> ass_stmnt stmnt
Rule 36    ass_stmnt -> ID arr ASS func_stmnt SEMICLN
Rule 37    ass_stmnt -> ID arr ASS logic SEMICLN
Rule 38    func_stmnt -> ID LPAREN arg RPAREN SEMICLN
Rule 39    arg -> empty
Rule 40    arg -> logic multiarg
Rule 41    multiarg -> empty
Rule 42    multiarg -> COMMA arg multiarg
Rule 43    ret_stmnt -> RETURN LPAREN logic RPAREN SEMICLN
Rule 44    read_stmnt -> READ LPAREN ID multid RPAREN SEMICLN
Rule 45    write_stmnt -> WRITE LPAREN ID multid RPAREN SEMICLN
Rule 46    logic -> rel log2 OR log1 logic
Rule 47    logic -> rel log2 AND log1 logic
Rule 48    logic -> rel log2
Rule 49    log1 -> <empty>
Rule 50    log2 -> <empty>
Rule 51    relop -> EQUAL_TO
Rule 52    relop -> DIFFERENT_TO
Rule 53    relop -> LESS_OR_EQ_THAN
Rule 54    relop -> MORE_OR_EQ_THAN
Rule 55    relop -> LESS_THAN
Rule 56    relop -> MORE_THAN
Rule 57    rel -> exp rel2 relop rel1 rel
Rule 58    rel -> exp rel2
Rule 59    rel1 -> <empty>
Rule 60    rel2 -> <empty>
Rule 61    exp -> term exp2 SUB exp1 exp
Rule 62    exp -> term exp2 SUM exp1 exp
Rule 63    exp -> term exp2
Rule 64    exp2 -> <empty>
Rule 65    exp1 -> <empty>
Rule 66    term -> factor term2 DIV term1 term
Rule 67    term -> factor term2 MULT term1 term
Rule 68    term -> factor term2
Rule 69    term1 -> <empty>
Rule 70    term2 -> <empty>
Rule 71    factor -> FALSE fact1
Rule 72    factor -> TRUE fact1
Rule 73    factor -> CTE_STR fact1
Rule 74    factor -> CTE_FLT fact1
Rule 75    factor -> CTE_NUM fact1
Rule 76    factor -> ID fact1 LPAREN logic multiexp RPAREN
Rule 77    factor -> ID fact1 arr
Rule 78    fact1 -> <empty>
Rule 79    multiexp -> empty
Rule 80    multiexp -> COMMA logic multiexp
Rule 81    if_stmnt -> IF LPAREN logic RPAREN else_stmnt END
Rule 82    else_stmnt -> empty
Rule 83    else_stmnt -> ELSE stmnt
Rule 84    while_stmnt -> WHILE LPAREN logic RPAREN stmnt END
Rule 85    empty -> <empty>

Terminals, with rules where they appear:

AND                  : 47
ASS                  : 36 37
BOOL                 : 13
CHAR                 : 14
COLON                : 8 24
COMMA                : 12 26 42 80
CTE_FLT              : 74
CTE_NUM              : 75
CTE_STR              : 73
DIFFERENT_TO         : 52
DIV                  : 66
ELSE                 : 83
END                  : 81 84
EQUAL_TO             : 51
FALSE                : 71
FLOAT                : 15
FUNC                 : 20
ID                   : 1 8 12 20 24 36 37 38 44 45 76 77
IF                   : 81
INT                  : 16
LCURLY               : 20
LESS_OR_EQ_THAN      : 53
LESS_THAN            : 55
LPAREN               : 20 27 38 43 44 45 76 81 84
LSQUARE              : 18
MAIN                 : 27
MORE_OR_EQ_THAN      : 54
MORE_THAN            : 56
MULT                 : 67
OR                   : 46
PROGRAM              : 1
RCURLY               : 20
READ                 : 44
RETURN               : 43
RPAREN               : 20 27 38 43 44 45 76 81 84
RSQUARE              : 18
SEMICLN              : 1 8 36 37 38 43 44 45
SUB                  : 61
SUM                  : 62
TRUE                 : 72
VARS                 : 5
VOID                 : 22
WHILE                : 84
WRITE                : 45
error                : 

Nonterminals, with rules where they appear:

arg                  : 38 42
arr                  : 8 12 36 37 77
ass_stmnt            : 35
else_stmnt           : 81
empty                : 4 7 11 17 19 23 25 28 39 41 79 82
exp                  : 18 57 58 61 62
exp1                 : 61 62
exp2                 : 61 62 63
fact1                : 71 72 73 74 75 76 77
factor               : 66 67 68
func_stmnt           : 34 36
funcdecl             : 1
if_stmnt             : 30
log1                 : 46 47
log2                 : 46 47 48
logic                : 37 40 43 46 47 76 80 81 84
main                 : 1
multiarg             : 40 42
multid               : 5 8 12 44 45
multiexp             : 76 80
multiparam           : 24
multivd              : 5 8
param                : 20 26
prog1                : 1
prog2                : 1
prog3                : 5
prog4                : 8
prog5                : 8 12
program              : 0
read_stmnt           : 32
rel                  : 46 47 48 57
rel1                 : 57
rel2                 : 57 58
relop                : 57
ret_stmnt            : 33
stmnt                : 20 27 29 30 31 32 33 34 35 83 84
term                 : 61 62 63 66 67
term1                : 66 67
term2                : 66 67 68
tipo                 : 8 21 24
tipofunc             : 20
varsdecl             : 1 20
while_stmnt          : 29
write_stmnt          : 31


state 0

    (0) S' -> . program
    (1) program -> . PROGRAM prog1 ID prog2 SEMICLN varsdecl funcdecl main
    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .


state 2

    (1) program -> PROGRAM . prog1 ID prog2 SEMICLN varsdecl funcdecl main
    (2) prog1 -> .
    ID              reduce using rule 2 (prog1 -> .)

    prog1                          shift and go to state 3

state 3

    (1) program -> PROGRAM prog1 . ID prog2 SEMICLN varsdecl funcdecl main
    ID              shift and go to state 4


state 4

    (1) program -> PROGRAM prog1 ID . prog2 SEMICLN varsdecl funcdecl main
    (3) prog2 -> .
    SEMICLN         reduce using rule 3 (prog2 -> .)

    prog2                          shift and go to state 5

state 5

    (1) program -> PROGRAM prog1 ID prog2 . SEMICLN varsdecl funcdecl main
    SEMICLN         shift and go to state 6


state 6

    (1) program -> PROGRAM prog1 ID prog2 SEMICLN . varsdecl funcdecl main
    (4) varsdecl -> . empty
    (5) varsdecl -> . VARS prog3 multivd multid
    (85) empty -> .
    VARS            shift and go to state 9
    FUNC            reduce using rule 85 (empty -> .)
    MAIN            reduce using rule 85 (empty -> .)

    varsdecl                       shift and go to state 7
    empty                          shift and go to state 8

state 7

    (1) program -> PROGRAM prog1 ID prog2 SEMICLN varsdecl . funcdecl main
    (19) funcdecl -> . empty
    (20) funcdecl -> . FUNC tipofunc ID LPAREN param RPAREN varsdecl LCURLY stmnt RCURLY
    (85) empty -> .
    FUNC            shift and go to state 12
    MAIN            reduce using rule 85 (empty -> .)

    funcdecl                       shift and go to state 10
    empty                          shift and go to state 11

state 8

    (4) varsdecl -> empty .
    FUNC            reduce using rule 4 (varsdecl -> empty .)
    MAIN            reduce using rule 4 (varsdecl -> empty .)
    LCURLY          reduce using rule 4 (varsdecl -> empty .)


state 9

    (5) varsdecl -> VARS . prog3 multivd multid
    (6) prog3 -> .
    BOOL            reduce using rule 6 (prog3 -> .)
    CHAR            reduce using rule 6 (prog3 -> .)
    FLOAT           reduce using rule 6 (prog3 -> .)
    INT             reduce using rule 6 (prog3 -> .)
    COMMA           reduce using rule 6 (prog3 -> .)
    FUNC            reduce using rule 6 (prog3 -> .)
    MAIN            reduce using rule 6 (prog3 -> .)
    LCURLY          reduce using rule 6 (prog3 -> .)

    prog3                          shift and go to state 13

state 10

    (1) program -> PROGRAM prog1 ID prog2 SEMICLN varsdecl funcdecl . main
    (27) main -> . MAIN LPAREN RPAREN stmnt
    MAIN            shift and go to state 15

    main                           shift and go to state 14

state 11

    (19) funcdecl -> empty .
    MAIN            reduce using rule 19 (funcdecl -> empty .)


state 12

    (20) funcdecl -> FUNC . tipofunc ID LPAREN param RPAREN varsdecl LCURLY stmnt RCURLY
    (21) tipofunc -> . tipo
    (22) tipofunc -> . VOID
    (13) tipo -> . BOOL
    (14) tipo -> . CHAR
    (15) tipo -> . FLOAT
    (16) tipo -> . INT
    VOID            shift and go to state 18
    BOOL            shift and go to state 19
    CHAR            shift and go to state 20
    FLOAT           shift and go to state 21
    INT             shift and go to state 22

    tipofunc                       shift and go to state 16
    tipo                           shift and go to state 17

state 13

    (5) varsdecl -> VARS prog3 . multivd multid
    (7) multivd -> . empty
    (8) multivd -> . tipo prog4 COLON ID prog5 arr multid SEMICLN multivd
    (85) empty -> .
    (13) tipo -> . BOOL
    (14) tipo -> . CHAR
    (15) tipo -> . FLOAT
    (16) tipo -> . INT
    COMMA           reduce using rule 85 (empty -> .)
    FUNC            reduce using rule 85 (empty -> .)
    MAIN            reduce using rule 85 (empty -> .)
    LCURLY          reduce using rule 85 (empty -> .)
    BOOL            shift and go to state 19
    CHAR            shift and go to state 20
    FLOAT           shift and go to state 21
    INT             shift and go to state 22

    multivd                        shift and go to state 23
    empty                          shift and go to state 24
    tipo                           shift and go to state 25

state 14

    (1) program -> PROGRAM prog1 ID prog2 SEMICLN varsdecl funcdecl main .
    $end            reduce using rule 1 (program -> PROGRAM prog1 ID prog2 SEMICLN varsdecl funcdecl main .)


state 15

    (27) main -> MAIN . LPAREN RPAREN stmnt
    LPAREN          shift and go to state 26


state 16

    (20) funcdecl -> FUNC tipofunc . ID LPAREN param RPAREN varsdecl LCURLY stmnt RCURLY
    ID              shift and go to state 27


state 17

    (21) tipofunc -> tipo .
    ID              reduce using rule 21 (tipofunc -> tipo .)


state 18

    (22) tipofunc -> VOID .
    ID              reduce using rule 22 (tipofunc -> VOID .)


state 19

    (13) tipo -> BOOL .
    ID              reduce using rule 13 (tipo -> BOOL .)
    COLON           reduce using rule 13 (tipo -> BOOL .)


state 20

    (14) tipo -> CHAR .
    ID              reduce using rule 14 (tipo -> CHAR .)
    COLON           reduce using rule 14 (tipo -> CHAR .)


state 21

    (15) tipo -> FLOAT .
    ID              reduce using rule 15 (tipo -> FLOAT .)
    COLON           reduce using rule 15 (tipo -> FLOAT .)


state 22

    (16) tipo -> INT .
    ID              reduce using rule 16 (tipo -> INT .)
    COLON           reduce using rule 16 (tipo -> INT .)


state 23

    (5) varsdecl -> VARS prog3 multivd . multid
    (11) multid -> . empty
    (12) multid -> . COMMA ID prog5 arr multid
    (85) empty -> .
    COMMA           shift and go to state 30
    FUNC            reduce using rule 85 (empty -> .)
    MAIN            reduce using rule 85 (empty -> .)
    LCURLY          reduce using rule 85 (empty -> .)

    multid                         shift and go to state 28
    empty                          shift and go to state 29

state 24

    (7) multivd -> empty .
    COMMA           reduce using rule 7 (multivd -> empty .)
    FUNC            reduce using rule 7 (multivd -> empty .)
    MAIN            reduce using rule 7 (multivd -> empty .)
    LCURLY          reduce using rule 7 (multivd -> empty .)


state 25

    (8) multivd -> tipo . prog4 COLON ID prog5 arr multid SEMICLN multivd
    (9) prog4 -> .
    COLON           reduce using rule 9 (prog4 -> .)

    prog4                          shift and go to state 31

state 26

    (27) main -> MAIN LPAREN . RPAREN stmnt
    RPAREN          shift and go to state 32


state 27

    (20) funcdecl -> FUNC tipofunc ID . LPAREN param RPAREN varsdecl LCURLY stmnt RCURLY
    LPAREN          shift and go to state 33


state 28

    (5) varsdecl -> VARS prog3 multivd multid .
    FUNC            reduce using rule 5 (varsdecl -> VARS prog3 multivd multid .)
    MAIN            reduce using rule 5 (varsdecl -> VARS prog3 multivd multid .)
    LCURLY          reduce using rule 5 (varsdecl -> VARS prog3 multivd multid .)


state 29

    (11) multid -> empty .
    FUNC            reduce using rule 11 (multid -> empty .)
    MAIN            reduce using rule 11 (multid -> empty .)
    LCURLY          reduce using rule 11 (multid -> empty .)
    RPAREN          reduce using rule 11 (multid -> empty .)
    SEMICLN         reduce using rule 11 (multid -> empty .)


state 30

    (12) multid -> COMMA . ID prog5 arr multid
    ID              shift and go to state 34


state 31

    (8) multivd -> tipo prog4 . COLON ID prog5 arr multid SEMICLN multivd
    COLON           shift and go to state 35


state 32

    (27) main -> MAIN LPAREN RPAREN . stmnt
    (28) stmnt -> . empty
    (29) stmnt -> . while_stmnt stmnt
    (30) stmnt -> . if_stmnt stmnt
    (31) stmnt -> . write_stmnt stmnt
    (32) stmnt -> . read_stmnt stmnt
    (33) stmnt -> . ret_stmnt stmnt
    (34) stmnt -> . func_stmnt stmnt
    (35) stmnt -> . ass_stmnt stmnt
    (85) empty -> .
    (84) while_stmnt -> . WHILE LPAREN logic RPAREN stmnt END
    (81) if_stmnt -> . IF LPAREN logic RPAREN else_stmnt END
    (45) write_stmnt -> . WRITE LPAREN ID multid RPAREN SEMICLN
    (44) read_stmnt -> . READ LPAREN ID multid RPAREN SEMICLN
    (43) ret_stmnt -> . RETURN LPAREN logic RPAREN SEMICLN
    (38) func_stmnt -> . ID LPAREN arg RPAREN SEMICLN
    (36) ass_stmnt -> . ID arr ASS func_stmnt SEMICLN
    (37) ass_stmnt -> . ID arr ASS logic SEMICLN
    $end            reduce using rule 85 (empty -> .)
    WHILE           shift and go to state 45
    IF              shift and go to state 46
    WRITE           shift and go to state 47
    READ            shift and go to state 49
    RETURN          shift and go to state 50
    ID              shift and go to state 48

    stmnt                          shift and go to state 36
    empty                          shift and go to state 37
    while_stmnt                    shift and go to state 38
    if_stmnt                       shift and go to state 39
    write_stmnt                    shift and go to state 40
    read_stmnt                     shift and go to state 41
    ret_stmnt                      shift and go to state 42
    func_stmnt                     shift and go to state 43
    ass_stmnt                      shift and go to state 44

state 33

    (20) funcdecl -> FUNC tipofunc ID LPAREN . param RPAREN varsdecl LCURLY stmnt RCURLY
    (23) param -> . empty
    (24) param -> . tipo COLON ID multiparam
    (85) empty -> .
    (13) tipo -> . BOOL
    (14) tipo -> . CHAR
    (15) tipo -> . FLOAT
    (16) tipo -> . INT
    RPAREN          reduce using rule 85 (empty -> .)
    BOOL            shift and go to state 19
    CHAR            shift and go to state 20
    FLOAT           shift and go to state 21
    INT             shift and go to state 22

    param                          shift and go to state 51
    empty                          shift and go to state 52
    tipo                           shift and go to state 53

state 34

    (12) multid -> COMMA ID . prog5 arr multid
    (10) prog5 -> .
    LSQUARE         reduce using rule 10 (prog5 -> .)
    COMMA           reduce using rule 10 (prog5 -> .)
    FUNC            reduce using rule 10 (prog5 -> .)
    MAIN            reduce using rule 10 (prog5 -> .)
    LCURLY          reduce using rule 10 (prog5 -> .)
    RPAREN          reduce using rule 10 (prog5 -> .)
    SEMICLN         reduce using rule 10 (prog5 -> .)

    prog5                          shift and go to state 54

state 35

    (8) multivd -> tipo prog4 COLON . ID prog5 arr multid SEMICLN multivd
    ID              shift and go to state 55


state 36

    (27) main -> MAIN LPAREN RPAREN stmnt .
    $end            reduce using rule 27 (main -> MAIN LPAREN RPAREN stmnt .)


state 37

    (28) stmnt -> empty .
    $end            reduce using rule 28 (stmnt -> empty .)
    END             reduce using rule 28 (stmnt -> empty .)
    RCURLY          reduce using rule 28 (stmnt -> empty .)


state 38

    (29) stmnt -> while_stmnt . stmnt
    (28) stmnt -> . empty
    (29) stmnt -> . while_stmnt stmnt
    (30) stmnt -> . if_stmnt stmnt
    (31) stmnt -> . write_stmnt stmnt
    (32) stmnt -> . read_stmnt stmnt
    (33) stmnt -> . ret_stmnt stmnt
    (34) stmnt -> . func_stmnt stmnt
    (35) stmnt -> . ass_stmnt stmnt
    (85) empty -> .
    (84) while_stmnt -> . WHILE LPAREN logic RPAREN stmnt END
    (81) if_stmnt -> . IF LPAREN logic RPAREN else_stmnt END
    (45) write_stmnt -> . WRITE LPAREN ID multid RPAREN SEMICLN
    (44) read_stmnt -> . READ LPAREN ID multid RPAREN SEMICLN
    (43) ret_stmnt -> . RETURN LPAREN logic RPAREN SEMICLN
    (38) func_stmnt -> . ID LPAREN arg RPAREN SEMICLN
    (36) ass_stmnt -> . ID arr ASS func_stmnt SEMICLN
    (37) ass_stmnt -> . ID arr ASS logic SEMICLN
    $end            reduce using rule 85 (empty -> .)
    END             reduce using rule 85 (empty -> .)
    RCURLY          reduce using rule 85 (empty -> .)
    WHILE           shift and go to state 45
    IF              shift and go to state 46
    WRITE           shift and go to state 47
    READ            shift and go to state 49
    RETURN          shift and go to state 50
    ID              shift and go to state 48

    while_stmnt                    shift and go to state 38
    stmnt                          shift and go to state 56
    empty                          shift and go to state 37
    if_stmnt                       shift and go to state 39
    write_stmnt                    shift and go to state 40
    read_stmnt                     shift and go to state 41
    ret_stmnt                      shift and go to state 42
    func_stmnt                     shift and go to state 43
    ass_stmnt                      shift and go to state 44

state 39

    (30) stmnt -> if_stmnt . stmnt
    (28) stmnt -> . empty
    (29) stmnt -> . while_stmnt stmnt
    (30) stmnt -> . if_stmnt stmnt
    (31) stmnt -> . write_stmnt stmnt
    (32) stmnt -> . read_stmnt stmnt
    (33) stmnt -> . ret_stmnt stmnt
    (34) stmnt -> . func_stmnt stmnt
    (35) stmnt -> . ass_stmnt stmnt
    (85) empty -> .
    (84) while_stmnt -> . WHILE LPAREN logic RPAREN stmnt END
    (81) if_stmnt -> . IF LPAREN logic RPAREN else_stmnt END
    (45) write_stmnt -> . WRITE LPAREN ID multid RPAREN SEMICLN
    (44) read_stmnt -> . READ LPAREN ID multid RPAREN SEMICLN
    (43) ret_stmnt -> . RETURN LPAREN logic RPAREN SEMICLN
    (38) func_stmnt -> . ID LPAREN arg RPAREN SEMICLN
    (36) ass_stmnt -> . ID arr ASS func_stmnt SEMICLN
    (37) ass_stmnt -> . ID arr ASS logic SEMICLN
    $end            reduce using rule 85 (empty -> .)
    END             reduce using rule 85 (empty -> .)
    RCURLY          reduce using rule 85 (empty -> .)
    WHILE           shift and go to state 45
    IF              shift and go to state 46
    WRITE           shift and go to state 47
    READ            shift and go to state 49
    RETURN          shift and go to state 50
    ID              shift and go to state 48

    if_stmnt                       shift and go to state 39
    stmnt                          shift and go to state 57
    empty                          shift and go to state 37
    while_stmnt                    shift and go to state 38
    write_stmnt                    shift and go to state 40
    read_stmnt                     shift and go to state 41
    ret_stmnt                      shift and go to state 42
    func_stmnt                     shift and go to state 43
    ass_stmnt                      shift and go to state 44

state 40

    (31) stmnt -> write_stmnt . stmnt
    (28) stmnt -> . empty
    (29) stmnt -> . while_stmnt stmnt
    (30) stmnt -> . if_stmnt stmnt
    (31) stmnt -> . write_stmnt stmnt
    (32) stmnt -> . read_stmnt stmnt
    (33) stmnt -> . ret_stmnt stmnt
    (34) stmnt -> . func_stmnt stmnt
    (35) stmnt -> . ass_stmnt stmnt
    (85) empty -> .
    (84) while_stmnt -> . WHILE LPAREN logic RPAREN stmnt END
    (81) if_stmnt -> . IF LPAREN logic RPAREN else_stmnt END
    (45) write_stmnt -> . WRITE LPAREN ID multid RPAREN SEMICLN
    (44) read_stmnt -> . READ LPAREN ID multid RPAREN SEMICLN
    (43) ret_stmnt -> . RETURN LPAREN logic RPAREN SEMICLN
    (38) func_stmnt -> . ID LPAREN arg RPAREN SEMICLN
    (36) ass_stmnt -> . ID arr ASS func_stmnt SEMICLN
    (37) ass_stmnt -> . ID arr ASS logic SEMICLN
    $end            reduce using rule 85 (empty -> .)
    END             reduce using rule 85 (empty -> .)
    RCURLY          reduce using rule 85 (empty -> .)
    WHILE           shift and go to state 45
    IF              shift and go to state 46
    WRITE           shift and go to state 47
    READ            shift and go to state 49
    RETURN          shift and go to state 50
    ID              shift and go to state 48

    write_stmnt                    shift and go to state 40
    stmnt                          shift and go to state 58
    empty                          shift and go to state 37
    while_stmnt                    shift and go to state 38
    if_stmnt                       shift and go to state 39
    read_stmnt                     shift and go to state 41
    ret_stmnt                      shift and go to state 42
    func_stmnt                     shift and go to state 43
    ass_stmnt                      shift and go to state 44

state 41

    (32) stmnt -> read_stmnt . stmnt
    (28) stmnt -> . empty
    (29) stmnt -> . while_stmnt stmnt
    (30) stmnt -> . if_stmnt stmnt
    (31) stmnt -> . write_stmnt stmnt
    (32) stmnt -> . read_stmnt stmnt
    (33) stmnt -> . ret_stmnt stmnt
    (34) stmnt -> . func_stmnt stmnt
    (35) stmnt -> . ass_stmnt stmnt
    (85) empty -> .
    (84) while_stmnt -> . WHILE LPAREN logic RPAREN stmnt END
    (81) if_stmnt -> . IF LPAREN logic RPAREN else_stmnt END
    (45) write_stmnt -> . WRITE LPAREN ID multid RPAREN SEMICLN
    (44) read_stmnt -> . READ LPAREN ID multid RPAREN SEMICLN
    (43) ret_stmnt -> . RETURN LPAREN logic RPAREN SEMICLN
    (38) func_stmnt -> . ID LPAREN arg RPAREN SEMICLN
    (36) ass_stmnt -> . ID arr ASS func_stmnt SEMICLN
    (37) ass_stmnt -> . ID arr ASS logic SEMICLN
    $end            reduce using rule 85 (empty -> .)
    END             reduce using rule 85 (empty -> .)
    RCURLY          reduce using rule 85 (empty -> .)
    WHILE           shift and go to state 45
    IF              shift and go to state 46
    WRITE           shift and go to state 47
    READ            shift and go to state 49
    RETURN          shift and go to state 50
    ID              shift and go to state 48

    read_stmnt                     shift and go to state 41
    stmnt                          shift and go to state 59
    empty                          shift and go to state 37
    while_stmnt                    shift and go to state 38
    if_stmnt                       shift and go to state 39
    write_stmnt                    shift and go to state 40
    ret_stmnt                      shift and go to state 42
    func_stmnt                     shift and go to state 43
    ass_stmnt                      shift and go to state 44

state 42

    (33) stmnt -> ret_stmnt . stmnt
    (28) stmnt -> . empty
    (29) stmnt -> . while_stmnt stmnt
    (30) stmnt -> . if_stmnt stmnt
    (31) stmnt -> . write_stmnt stmnt
    (32) stmnt -> . read_stmnt stmnt
    (33) stmnt -> . ret_stmnt stmnt
    (34) stmnt -> . func_stmnt stmnt
    (35) stmnt -> . ass_stmnt stmnt
    (85) empty -> .
    (84) while_stmnt -> . WHILE LPAREN logic RPAREN stmnt END
    (81) if_stmnt -> . IF LPAREN logic RPAREN else_stmnt END
    (45) write_stmnt -> . WRITE LPAREN ID multid RPAREN SEMICLN
    (44) read_stmnt -> . READ LPAREN ID multid RPAREN SEMICLN
    (43) ret_stmnt -> . RETURN LPAREN logic RPAREN SEMICLN
    (38) func_stmnt -> . ID LPAREN arg RPAREN SEMICLN
    (36) ass_stmnt -> . ID arr ASS func_stmnt SEMICLN
    (37) ass_stmnt -> . ID arr ASS logic SEMICLN
    $end            reduce using rule 85 (empty -> .)
    END             reduce using rule 85 (empty -> .)
    RCURLY          reduce using rule 85 (empty -> .)
    WHILE           shift and go to state 45
    IF              shift and go to state 46
    WRITE           shift and go to state 47
    READ            shift and go to state 49
    RETURN          shift and go to state 50
    ID              shift and go to state 48

    ret_stmnt                      shift and go to state 42
    stmnt                          shift and go to state 60
    empty                          shift and go to state 37
    while_stmnt                    shift and go to state 38
    if_stmnt                       shift and go to state 39
    write_stmnt                    shift and go to state 40
    read_stmnt                     shift and go to state 41
    func_stmnt                     shift and go to state 43
    ass_stmnt                      shift and go to state 44

state 43

    (34) stmnt -> func_stmnt . stmnt
    (28) stmnt -> . empty
    (29) stmnt -> . while_stmnt stmnt
    (30) stmnt -> . if_stmnt stmnt
    (31) stmnt -> . write_stmnt stmnt
    (32) stmnt -> . read_stmnt stmnt
    (33) stmnt -> . ret_stmnt stmnt
    (34) stmnt -> . func_stmnt stmnt
    (35) stmnt -> . ass_stmnt stmnt
    (85) empty -> .
    (84) while_stmnt -> . WHILE LPAREN logic RPAREN stmnt END
    (81) if_stmnt -> . IF LPAREN logic RPAREN else_stmnt END
    (45) write_stmnt -> . WRITE LPAREN ID multid RPAREN SEMICLN
    (44) read_stmnt -> . READ LPAREN ID multid RPAREN SEMICLN
    (43) ret_stmnt -> . RETURN LPAREN logic RPAREN SEMICLN
    (38) func_stmnt -> . ID LPAREN arg RPAREN SEMICLN
    (36) ass_stmnt -> . ID arr ASS func_stmnt SEMICLN
    (37) ass_stmnt -> . ID arr ASS logic SEMICLN
    $end            reduce using rule 85 (empty -> .)
    END             reduce using rule 85 (empty -> .)
    RCURLY          reduce using rule 85 (empty -> .)
    WHILE           shift and go to state 45
    IF              shift and go to state 46
    WRITE           shift and go to state 47
    READ            shift and go to state 49
    RETURN          shift and go to state 50
    ID              shift and go to state 48

    func_stmnt                     shift and go to state 43
    stmnt                          shift and go to state 61
    empty                          shift and go to state 37
    while_stmnt                    shift and go to state 38
    if_stmnt                       shift and go to state 39
    write_stmnt                    shift and go to state 40
    read_stmnt                     shift and go to state 41
    ret_stmnt                      shift and go to state 42
    ass_stmnt                      shift and go to state 44

state 44

    (35) stmnt -> ass_stmnt . stmnt
    (28) stmnt -> . empty
    (29) stmnt -> . while_stmnt stmnt
    (30) stmnt -> . if_stmnt stmnt
    (31) stmnt -> . write_stmnt stmnt
    (32) stmnt -> . read_stmnt stmnt
    (33) stmnt -> . ret_stmnt stmnt
    (34) stmnt -> . func_stmnt stmnt
    (35) stmnt -> . ass_stmnt stmnt
    (85) empty -> .
    (84) while_stmnt -> . WHILE LPAREN logic RPAREN stmnt END
    (81) if_stmnt -> . IF LPAREN logic RPAREN else_stmnt END
    (45) write_stmnt -> . WRITE LPAREN ID multid RPAREN SEMICLN
    (44) read_stmnt -> . READ LPAREN ID multid RPAREN SEMICLN
    (43) ret_stmnt -> . RETURN LPAREN logic RPAREN SEMICLN
    (38) func_stmnt -> . ID LPAREN arg RPAREN SEMICLN
    (36) ass_stmnt -> . ID arr ASS func_stmnt SEMICLN
    (37) ass_stmnt -> . ID arr ASS logic SEMICLN
    $end            reduce using rule 85 (empty -> .)
    END             reduce using rule 85 (empty -> .)
    RCURLY          reduce using rule 85 (empty -> .)
    WHILE           shift and go to state 45
    IF              shift and go to state 46
    WRITE           shift and go to state 47
    READ            shift and go to state 49
    RETURN          shift and go to state 50
    ID              shift and go to state 48

    ass_stmnt                      shift and go to state 44
    stmnt                          shift and go to state 62
    empty                          shift and go to state 37
    while_stmnt                    shift and go to state 38
    if_stmnt                       shift and go to state 39
    write_stmnt                    shift and go to state 40
    read_stmnt                     shift and go to state 41
    ret_stmnt                      shift and go to state 42
    func_stmnt                     shift and go to state 43

state 45

    (84) while_stmnt -> WHILE . LPAREN logic RPAREN stmnt END
    LPAREN          shift and go to state 63


state 46

    (81) if_stmnt -> IF . LPAREN logic RPAREN else_stmnt END
    LPAREN          shift and go to state 64


state 47

    (45) write_stmnt -> WRITE . LPAREN ID multid RPAREN SEMICLN
    LPAREN          shift and go to state 65


state 48

    (38) func_stmnt -> ID . LPAREN arg RPAREN SEMICLN
    (36) ass_stmnt -> ID . arr ASS func_stmnt SEMICLN
    (37) ass_stmnt -> ID . arr ASS logic SEMICLN
    (17) arr -> . empty
    (18) arr -> . LSQUARE exp RSQUARE
    (85) empty -> .
    LPAREN          shift and go to state 66
    LSQUARE         shift and go to state 69
    ASS             reduce using rule 85 (empty -> .)

    arr                            shift and go to state 67
    empty                          shift and go to state 68

state 49

    (44) read_stmnt -> READ . LPAREN ID multid RPAREN SEMICLN
    LPAREN          shift and go to state 70


state 50

    (43) ret_stmnt -> RETURN . LPAREN logic RPAREN SEMICLN
    LPAREN          shift and go to state 71


state 51

    (20) funcdecl -> FUNC tipofunc ID LPAREN param . RPAREN varsdecl LCURLY stmnt RCURLY
    RPAREN          shift and go to state 72


state 52

    (23) param -> empty .
    RPAREN          reduce using rule 23 (param -> empty .)


state 53

    (24) param -> tipo . COLON ID multiparam
    COLON           shift and go to state 73


state 54

    (12) multid -> COMMA ID prog5 . arr multid
    (17) arr -> . empty
    (18) arr -> . LSQUARE exp RSQUARE
    (85) empty -> .
    LSQUARE         shift and go to state 69
    COMMA           reduce using rule 85 (empty -> .)
    FUNC            reduce using rule 85 (empty -> .)
    MAIN            reduce using rule 85 (empty -> .)
    LCURLY          reduce using rule 85 (empty -> .)
    RPAREN          reduce using rule 85 (empty -> .)
    SEMICLN         reduce using rule 85 (empty -> .)

    arr                            shift and go to state 74
    empty                          shift and go to state 68

state 55

    (8) multivd -> tipo prog4 COLON ID . prog5 arr multid SEMICLN multivd
    (10) prog5 -> .
    LSQUARE         reduce using rule 10 (prog5 -> .)
    COMMA           reduce using rule 10 (prog5 -> .)
    SEMICLN         reduce using rule 10 (prog5 -> .)

    prog5                          shift and go to state 75

state 56

    (29) stmnt -> while_stmnt stmnt .
    $end            reduce using rule 29 (stmnt -> while_stmnt stmnt .)
    END             reduce using rule 29 (stmnt -> while_stmnt stmnt .)
    RCURLY          reduce using rule 29 (stmnt -> while_stmnt stmnt .)


state 57

    (30) stmnt -> if_stmnt stmnt .
    $end            reduce using rule 30 (stmnt -> if_stmnt stmnt .)
    END             reduce using rule 30 (stmnt -> if_stmnt stmnt .)
    RCURLY          reduce using rule 30 (stmnt -> if_stmnt stmnt .)


state 58

    (31) stmnt -> write_stmnt stmnt .
    $end            reduce using rule 31 (stmnt -> write_stmnt stmnt .)
    END             reduce using rule 31 (stmnt -> write_stmnt stmnt .)
    RCURLY          reduce using rule 31 (stmnt -> write_stmnt stmnt .)


state 59

    (32) stmnt -> read_stmnt stmnt .
    $end            reduce using rule 32 (stmnt -> read_stmnt stmnt .)
    END             reduce using rule 32 (stmnt -> read_stmnt stmnt .)
    RCURLY          reduce using rule 32 (stmnt -> read_stmnt stmnt .)


state 60

    (33) stmnt -> ret_stmnt stmnt .
    $end            reduce using rule 33 (stmnt -> ret_stmnt stmnt .)
    END             reduce using rule 33 (stmnt -> ret_stmnt stmnt .)
    RCURLY          reduce using rule 33 (stmnt -> ret_stmnt stmnt .)


state 61

    (34) stmnt -> func_stmnt stmnt .
    $end            reduce using rule 34 (stmnt -> func_stmnt stmnt .)
    END             reduce using rule 34 (stmnt -> func_stmnt stmnt .)
    RCURLY          reduce using rule 34 (stmnt -> func_stmnt stmnt .)


state 62

    (35) stmnt -> ass_stmnt stmnt .
    $end            reduce using rule 35 (stmnt -> ass_stmnt stmnt .)
    END             reduce using rule 35 (stmnt -> ass_stmnt stmnt .)
    RCURLY          reduce using rule 35 (stmnt -> ass_stmnt stmnt .)


state 63

    (84) while_stmnt -> WHILE LPAREN . logic RPAREN stmnt END
    (46) logic -> . rel log2 OR log1 logic
    (47) logic -> . rel log2 AND log1 logic
    (48) logic -> . rel log2
    (57) rel -> . exp rel2 relop rel1 rel
    (58) rel -> . exp rel2
    (61) exp -> . term exp2 SUB exp1 exp
    (62) exp -> . term exp2 SUM exp1 exp
    (63) exp -> . term exp2
    (66) term -> . factor term2 DIV term1 term
    (67) term -> . factor term2 MULT term1 term
    (68) term -> . factor term2
    (71) factor -> . FALSE fact1
    (72) factor -> . TRUE fact1
    (73) factor -> . CTE_STR fact1
    (74) factor -> . CTE_FLT fact1
    (75) factor -> . CTE_NUM fact1
    (76) factor -> . ID fact1 LPAREN logic multiexp RPAREN
    (77) factor -> . ID fact1 arr
    FALSE           shift and go to state 81
    TRUE            shift and go to state 82
    CTE_STR         shift and go to state 83
    CTE_FLT         shift and go to state 84
    CTE_NUM         shift and go to state 85
    ID              shift and go to state 86

    logic                          shift and go to state 76
    rel                            shift and go to state 77
    exp                            shift and go to state 78
    term                           shift and go to state 79
    factor                         shift and go to state 80

state 64

    (81) if_stmnt -> IF LPAREN . logic RPAREN else_stmnt END
    (46) logic -> . rel log2 OR log1 logic
    (47) logic -> . rel log2 AND log1 logic
    (48) logic -> . rel log2
    (57) rel -> . exp rel2 relop rel1 rel
    (58) rel -> . exp rel2
    (61) exp -> . term exp2 SUB exp1 exp
    (62) exp -> . term exp2 SUM exp1 exp
    (63) exp -> . term exp2
    (66) term -> . factor term2 DIV term1 term
    (67) term -> . factor term2 MULT term1 term
    (68) term -> . factor term2
    (71) factor -> . FALSE fact1
    (72) factor -> . TRUE fact1
    (73) factor -> . CTE_STR fact1
    (74) factor -> . CTE_FLT fact1
    (75) factor -> . CTE_NUM fact1
    (76) factor -> . ID fact1 LPAREN logic multiexp RPAREN
    (77) factor -> . ID fact1 arr
    FALSE           shift and go to state 81
    TRUE            shift and go to state 82
    CTE_STR         shift and go to state 83
    CTE_FLT         shift and go to state 84
    CTE_NUM         shift and go to state 85
    ID              shift and go to state 86

    logic                          shift and go to state 87
    rel                            shift and go to state 77
    exp                            shift and go to state 78
    term                           shift and go to state 79
    factor                         shift and go to state 80

state 65

    (45) write_stmnt -> WRITE LPAREN . ID multid RPAREN SEMICLN
    ID              shift and go to state 88


state 66

    (38) func_stmnt -> ID LPAREN . arg RPAREN SEMICLN
    (39) arg -> . empty
    (40) arg -> . logic multiarg
    (85) empty -> .
    (46) logic -> . rel log2 OR log1 logic
    (47) logic -> . rel log2 AND log1 logic
    (48) logic -> . rel log2
    (57) rel -> . exp rel2 relop rel1 rel
    (58) rel -> . exp rel2
    (61) exp -> . term exp2 SUB exp1 exp
    (62) exp -> . term exp2 SUM exp1 exp
    (63) exp -> . term exp2
    (66) term -> . factor term2 DIV term1 term
    (67) term -> . factor term2 MULT term1 term
    (68) term -> . factor term2
    (71) factor -> . FALSE fact1
    (72) factor -> . TRUE fact1
    (73) factor -> . CTE_STR fact1
    (74) factor -> . CTE_FLT fact1
    (75) factor -> . CTE_NUM fact1
    (76) factor -> . ID fact1 LPAREN logic multiexp RPAREN
    (77) factor -> . ID fact1 arr
    RPAREN          reduce using rule 85 (empty -> .)
    FALSE           shift and go to state 81
    TRUE            shift and go to state 82
    CTE_STR         shift and go to state 83
    CTE_FLT         shift and go to state 84
    CTE_NUM         shift and go to state 85
    ID              shift and go to state 86

    arg                            shift and go to state 89
    empty                          shift and go to state 90
    logic                          shift and go to state 91
    rel                            shift and go to state 77
    exp                            shift and go to state 78
    term                           shift and go to state 79
    factor                         shift and go to state 80

state 67

    (36) ass_stmnt -> ID arr . ASS func_stmnt SEMICLN
    (37) ass_stmnt -> ID arr . ASS logic SEMICLN
    ASS             shift and go to state 92


state 68

    (17) arr -> empty .
    ASS             reduce using rule 17 (arr -> empty .)
    COMMA           reduce using rule 17 (arr -> empty .)
    FUNC            reduce using rule 17 (arr -> empty .)
    MAIN            reduce using rule 17 (arr -> empty .)
    LCURLY          reduce using rule 17 (arr -> empty .)
    RPAREN          reduce using rule 17 (arr -> empty .)
    SEMICLN         reduce using rule 17 (arr -> empty .)
    DIV             reduce using rule 17 (arr -> empty .)
    MULT            reduce using rule 17 (arr -> empty .)
    SUB             reduce using rule 17 (arr -> empty .)
    SUM             reduce using rule 17 (arr -> empty .)
    EQUAL_TO        reduce using rule 17 (arr -> empty .)
    DIFFERENT_TO    reduce using rule 17 (arr -> empty .)
    LESS_OR_EQ_THAN reduce using rule 17 (arr -> empty .)
    MORE_OR_EQ_THAN reduce using rule 17 (arr -> empty .)
    LESS_THAN       reduce using rule 17 (arr -> empty .)
    MORE_THAN       reduce using rule 17 (arr -> empty .)
    OR              reduce using rule 17 (arr -> empty .)
    AND             reduce using rule 17 (arr -> empty .)
    RSQUARE         reduce using rule 17 (arr -> empty .)


state 69

    (18) arr -> LSQUARE . exp RSQUARE
    (61) exp -> . term exp2 SUB exp1 exp
    (62) exp -> . term exp2 SUM exp1 exp
    (63) exp -> . term exp2
    (66) term -> . factor term2 DIV term1 term
    (67) term -> . factor term2 MULT term1 term
    (68) term -> . factor term2
    (71) factor -> . FALSE fact1
    (72) factor -> . TRUE fact1
    (73) factor -> . CTE_STR fact1
    (74) factor -> . CTE_FLT fact1
    (75) factor -> . CTE_NUM fact1
    (76) factor -> . ID fact1 LPAREN logic multiexp RPAREN
    (77) factor -> . ID fact1 arr
    FALSE           shift and go to state 81
    TRUE            shift and go to state 82
    CTE_STR         shift and go to state 83
    CTE_FLT         shift and go to state 84
    CTE_NUM         shift and go to state 85
    ID              shift and go to state 86

    exp                            shift and go to state 93
    term                           shift and go to state 79
    factor                         shift and go to state 80

state 70

    (44) read_stmnt -> READ LPAREN . ID multid RPAREN SEMICLN
    ID              shift and go to state 94


state 71

    (43) ret_stmnt -> RETURN LPAREN . logic RPAREN SEMICLN
    (46) logic -> . rel log2 OR log1 logic
    (47) logic -> . rel log2 AND log1 logic
    (48) logic -> . rel log2
    (57) rel -> . exp rel2 relop rel1 rel
    (58) rel -> . exp rel2
    (61) exp -> . term exp2 SUB exp1 exp
    (62) exp -> . term exp2 SUM exp1 exp
    (63) exp -> . term exp2
    (66) term -> . factor term2 DIV term1 term
    (67) term -> . factor term2 MULT term1 term
    (68) term -> . factor term2
    (71) factor -> . FALSE fact1
    (72) factor -> . TRUE fact1
    (73) factor -> . CTE_STR fact1
    (74) factor -> . CTE_FLT fact1
    (75) factor -> . CTE_NUM fact1
    (76) factor -> . ID fact1 LPAREN logic multiexp RPAREN
    (77) factor -> . ID fact1 arr
    FALSE           shift and go to state 81
    TRUE            shift and go to state 82
    CTE_STR         shift and go to state 83
    CTE_FLT         shift and go to state 84
    CTE_NUM         shift and go to state 85
    ID              shift and go to state 86

    logic                          shift and go to state 95
    rel                            shift and go to state 77
    exp                            shift and go to state 78
    term                           shift and go to state 79
    factor                         shift and go to state 80

state 72

    (20) funcdecl -> FUNC tipofunc ID LPAREN param RPAREN . varsdecl LCURLY stmnt RCURLY
    (4) varsdecl -> . empty
    (5) varsdecl -> . VARS prog3 multivd multid
    (85) empty -> .
    VARS            shift and go to state 9
    LCURLY          reduce using rule 85 (empty -> .)

    varsdecl                       shift and go to state 96
    empty                          shift and go to state 8

state 73

    (24) param -> tipo COLON . ID multiparam
    ID              shift and go to state 97


state 74

    (12) multid -> COMMA ID prog5 arr . multid
    (11) multid -> . empty
    (12) multid -> . COMMA ID prog5 arr multid
    (85) empty -> .
    COMMA           shift and go to state 30
    FUNC            reduce using rule 85 (empty -> .)
    MAIN            reduce using rule 85 (empty -> .)
    LCURLY          reduce using rule 85 (empty -> .)
    RPAREN          reduce using rule 85 (empty -> .)
    SEMICLN         reduce using rule 85 (empty -> .)

    multid                         shift and go to state 98
    empty                          shift and go to state 29

state 75

    (8) multivd -> tipo prog4 COLON ID prog5 . arr multid SEMICLN multivd
    (17) arr -> . empty
    (18) arr -> . LSQUARE exp RSQUARE
    (85) empty -> .
    LSQUARE         shift and go to state 69
    COMMA           reduce using rule 85 (empty -> .)
    SEMICLN         reduce using rule 85 (empty -> .)

    arr                            shift and go to state 99
    empty                          shift and go to state 68

state 76

    (84) while_stmnt -> WHILE LPAREN logic . RPAREN stmnt END
    RPAREN          shift and go to state 100


state 77

    (46) logic -> rel . log2 OR log1 logic
    (47) logic -> rel . log2 AND log1 logic
    (48) logic -> rel . log2
    (50) log2 -> .
    OR              reduce using rule 50 (log2 -> .)
    AND             reduce using rule 50 (log2 -> .)
    RPAREN          reduce using rule 50 (log2 -> .)
    COMMA           reduce using rule 50 (log2 -> .)
    SEMICLN         reduce using rule 50 (log2 -> .)

    log2                           shift and go to state 101

state 78

    (57) rel -> exp . rel2 relop rel1 rel
    (58) rel -> exp . rel2
    (60) rel2 -> .
    EQUAL_TO        reduce using rule 60 (rel2 -> .)
    DIFFERENT_TO    reduce using rule 60 (rel2 -> .)
    LESS_OR_EQ_THAN reduce using rule 60 (rel2 -> .)
    MORE_OR_EQ_THAN reduce using rule 60 (rel2 -> .)
    LESS_THAN       reduce using rule 60 (rel2 -> .)
    MORE_THAN       reduce using rule 60 (rel2 -> .)
    OR              reduce using rule 60 (rel2 -> .)
    AND             reduce using rule 60 (rel2 -> .)
    RPAREN          reduce using rule 60 (rel2 -> .)
    COMMA           reduce using rule 60 (rel2 -> .)
    SEMICLN         reduce using rule 60 (rel2 -> .)

    rel2                           shift and go to state 102

state 79

    (61) exp -> term . exp2 SUB exp1 exp
    (62) exp -> term . exp2 SUM exp1 exp
    (63) exp -> term . exp2
    (64) exp2 -> .
    SUB             reduce using rule 64 (exp2 -> .)
    SUM             reduce using rule 64 (exp2 -> .)
    EQUAL_TO        reduce using rule 64 (exp2 -> .)
    DIFFERENT_TO    reduce using rule 64 (exp2 -> .)
    LESS_OR_EQ_THAN reduce using rule 64 (exp2 -> .)
    MORE_OR_EQ_THAN reduce using rule 64 (exp2 -> .)
    LESS_THAN       reduce using rule 64 (exp2 -> .)
    MORE_THAN       reduce using rule 64 (exp2 -> .)
    OR              reduce using rule 64 (exp2 -> .)
    AND             reduce using rule 64 (exp2 -> .)
    RPAREN          reduce using rule 64 (exp2 -> .)
    COMMA           reduce using rule 64 (exp2 -> .)
    RSQUARE         reduce using rule 64 (exp2 -> .)
    SEMICLN         reduce using rule 64 (exp2 -> .)

    exp2                           shift and go to state 103

state 80

    (66) term -> factor . term2 DIV term1 term
    (67) term -> factor . term2 MULT term1 term
    (68) term -> factor . term2
    (70) term2 -> .
    DIV             reduce using rule 70 (term2 -> .)
    MULT            reduce using rule 70 (term2 -> .)
    SUB             reduce using rule 70 (term2 -> .)
    SUM             reduce using rule 70 (term2 -> .)
    EQUAL_TO        reduce using rule 70 (term2 -> .)
    DIFFERENT_TO    reduce using rule 70 (term2 -> .)
    LESS_OR_EQ_THAN reduce using rule 70 (term2 -> .)
    MORE_OR_EQ_THAN reduce using rule 70 (term2 -> .)
    LESS_THAN       reduce using rule 70 (term2 -> .)
    MORE_THAN       reduce using rule 70 (term2 -> .)
    OR              reduce using rule 70 (term2 -> .)
    AND             reduce using rule 70 (term2 -> .)
    RPAREN          reduce using rule 70 (term2 -> .)
    COMMA           reduce using rule 70 (term2 -> .)
    RSQUARE         reduce using rule 70 (term2 -> .)
    SEMICLN         reduce using rule 70 (term2 -> .)

    term2                          shift and go to state 104

state 81

    (71) factor -> FALSE . fact1
    (78) fact1 -> .
    DIV             reduce using rule 78 (fact1 -> .)
    MULT            reduce using rule 78 (fact1 -> .)
    SUB             reduce using rule 78 (fact1 -> .)
    SUM             reduce using rule 78 (fact1 -> .)
    EQUAL_TO        reduce using rule 78 (fact1 -> .)
    DIFFERENT_TO    reduce using rule 78 (fact1 -> .)
    LESS_OR_EQ_THAN reduce using rule 78 (fact1 -> .)
    MORE_OR_EQ_THAN reduce using rule 78 (fact1 -> .)
    LESS_THAN       reduce using rule 78 (fact1 -> .)
    MORE_THAN       reduce using rule 78 (fact1 -> .)
    OR              reduce using rule 78 (fact1 -> .)
    AND             reduce using rule 78 (fact1 -> .)
    RPAREN          reduce using rule 78 (fact1 -> .)
    COMMA           reduce using rule 78 (fact1 -> .)
    RSQUARE         reduce using rule 78 (fact1 -> .)
    SEMICLN         reduce using rule 78 (fact1 -> .)

    fact1                          shift and go to state 105

state 82

    (72) factor -> TRUE . fact1
    (78) fact1 -> .
    DIV             reduce using rule 78 (fact1 -> .)
    MULT            reduce using rule 78 (fact1 -> .)
    SUB             reduce using rule 78 (fact1 -> .)
    SUM             reduce using rule 78 (fact1 -> .)
    EQUAL_TO        reduce using rule 78 (fact1 -> .)
    DIFFERENT_TO    reduce using rule 78 (fact1 -> .)
    LESS_OR_EQ_THAN reduce using rule 78 (fact1 -> .)
    MORE_OR_EQ_THAN reduce using rule 78 (fact1 -> .)
    LESS_THAN       reduce using rule 78 (fact1 -> .)
    MORE_THAN       reduce using rule 78 (fact1 -> .)
    OR              reduce using rule 78 (fact1 -> .)
    AND             reduce using rule 78 (fact1 -> .)
    RPAREN          reduce using rule 78 (fact1 -> .)
    COMMA           reduce using rule 78 (fact1 -> .)
    RSQUARE         reduce using rule 78 (fact1 -> .)
    SEMICLN         reduce using rule 78 (fact1 -> .)

    fact1                          shift and go to state 106

state 83

    (73) factor -> CTE_STR . fact1
    (78) fact1 -> .
    DIV             reduce using rule 78 (fact1 -> .)
    MULT            reduce using rule 78 (fact1 -> .)
    SUB             reduce using rule 78 (fact1 -> .)
    SUM             reduce using rule 78 (fact1 -> .)
    EQUAL_TO        reduce using rule 78 (fact1 -> .)
    DIFFERENT_TO    reduce using rule 78 (fact1 -> .)
    LESS_OR_EQ_THAN reduce using rule 78 (fact1 -> .)
    MORE_OR_EQ_THAN reduce using rule 78 (fact1 -> .)
    LESS_THAN       reduce using rule 78 (fact1 -> .)
    MORE_THAN       reduce using rule 78 (fact1 -> .)
    OR              reduce using rule 78 (fact1 -> .)
    AND             reduce using rule 78 (fact1 -> .)
    RPAREN          reduce using rule 78 (fact1 -> .)
    COMMA           reduce using rule 78 (fact1 -> .)
    RSQUARE         reduce using rule 78 (fact1 -> .)
    SEMICLN         reduce using rule 78 (fact1 -> .)

    fact1                          shift and go to state 107

state 84

    (74) factor -> CTE_FLT . fact1
    (78) fact1 -> .
    DIV             reduce using rule 78 (fact1 -> .)
    MULT            reduce using rule 78 (fact1 -> .)
    SUB             reduce using rule 78 (fact1 -> .)
    SUM             reduce using rule 78 (fact1 -> .)
    EQUAL_TO        reduce using rule 78 (fact1 -> .)
    DIFFERENT_TO    reduce using rule 78 (fact1 -> .)
    LESS_OR_EQ_THAN reduce using rule 78 (fact1 -> .)
    MORE_OR_EQ_THAN reduce using rule 78 (fact1 -> .)
    LESS_THAN       reduce using rule 78 (fact1 -> .)
    MORE_THAN       reduce using rule 78 (fact1 -> .)
    OR              reduce using rule 78 (fact1 -> .)
    AND             reduce using rule 78 (fact1 -> .)
    RPAREN          reduce using rule 78 (fact1 -> .)
    COMMA           reduce using rule 78 (fact1 -> .)
    RSQUARE         reduce using rule 78 (fact1 -> .)
    SEMICLN         reduce using rule 78 (fact1 -> .)

    fact1                          shift and go to state 108

state 85

    (75) factor -> CTE_NUM . fact1
    (78) fact1 -> .
    DIV             reduce using rule 78 (fact1 -> .)
    MULT            reduce using rule 78 (fact1 -> .)
    SUB             reduce using rule 78 (fact1 -> .)
    SUM             reduce using rule 78 (fact1 -> .)
    EQUAL_TO        reduce using rule 78 (fact1 -> .)
    DIFFERENT_TO    reduce using rule 78 (fact1 -> .)
    LESS_OR_EQ_THAN reduce using rule 78 (fact1 -> .)
    MORE_OR_EQ_THAN reduce using rule 78 (fact1 -> .)
    LESS_THAN       reduce using rule 78 (fact1 -> .)
    MORE_THAN       reduce using rule 78 (fact1 -> .)
    OR              reduce using rule 78 (fact1 -> .)
    AND             reduce using rule 78 (fact1 -> .)
    RPAREN          reduce using rule 78 (fact1 -> .)
    COMMA           reduce using rule 78 (fact1 -> .)
    RSQUARE         reduce using rule 78 (fact1 -> .)
    SEMICLN         reduce using rule 78 (fact1 -> .)

    fact1                          shift and go to state 109

state 86

    (76) factor -> ID . fact1 LPAREN logic multiexp RPAREN
    (77) factor -> ID . fact1 arr
    (78) fact1 -> .
    LPAREN          reduce using rule 78 (fact1 -> .)
    LSQUARE         reduce using rule 78 (fact1 -> .)
    DIV             reduce using rule 78 (fact1 -> .)
    MULT            reduce using rule 78 (fact1 -> .)
    SUB             reduce using rule 78 (fact1 -> .)
    SUM             reduce using rule 78 (fact1 -> .)
    EQUAL_TO        reduce using rule 78 (fact1 -> .)
    DIFFERENT_TO    reduce using rule 78 (fact1 -> .)
    LESS_OR_EQ_THAN reduce using rule 78 (fact1 -> .)
    MORE_OR_EQ_THAN reduce using rule 78 (fact1 -> .)
    LESS_THAN       reduce using rule 78 (fact1 -> .)
    MORE_THAN       reduce using rule 78 (fact1 -> .)
    OR              reduce using rule 78 (fact1 -> .)
    AND             reduce using rule 78 (fact1 -> .)
    RPAREN          reduce using rule 78 (fact1 -> .)
    COMMA           reduce using rule 78 (fact1 -> .)
    RSQUARE         reduce using rule 78 (fact1 -> .)
    SEMICLN         reduce using rule 78 (fact1 -> .)

    fact1                          shift and go to state 110

state 87

    (81) if_stmnt -> IF LPAREN logic . RPAREN else_stmnt END
    RPAREN          shift and go to state 111


state 88

    (45) write_stmnt -> WRITE LPAREN ID . multid RPAREN SEMICLN
    (11) multid -> . empty
    (12) multid -> . COMMA ID prog5 arr multid
    (85) empty -> .
    COMMA           shift and go to state 30
    RPAREN          reduce using rule 85 (empty -> .)

    multid                         shift and go to state 112
    empty                          shift and go to state 29

state 89

    (38) func_stmnt -> ID LPAREN arg . RPAREN SEMICLN
    RPAREN          shift and go to state 113


state 90

    (39) arg -> empty .
    RPAREN          reduce using rule 39 (arg -> empty .)
    COMMA           reduce using rule 39 (arg -> empty .)


state 91

    (40) arg -> logic . multiarg
    (41) multiarg -> . empty
    (42) multiarg -> . COMMA arg multiarg
    (85) empty -> .
  ! shift/reduce conflict for COMMA resolved as shift
    COMMA           shift and go to state 116
    RPAREN          reduce using rule 85 (empty -> .)

    multiarg                       shift and go to state 114
    empty                          shift and go to state 115

state 92

    (36) ass_stmnt -> ID arr ASS . func_stmnt SEMICLN
    (37) ass_stmnt -> ID arr ASS . logic SEMICLN
    (38) func_stmnt -> . ID LPAREN arg RPAREN SEMICLN
    (46) logic -> . rel log2 OR log1 logic
    (47) logic -> . rel log2 AND log1 logic
    (48) logic -> . rel log2
    (57) rel -> . exp rel2 relop rel1 rel
    (58) rel -> . exp rel2
    (61) exp -> . term exp2 SUB exp1 exp
    (62) exp -> . term exp2 SUM exp1 exp
    (63) exp -> . term exp2
    (66) term -> . factor term2 DIV term1 term
    (67) term -> . factor term2 MULT term1 term
    (68) term -> . factor term2
    (71) factor -> . FALSE fact1
    (72) factor -> . TRUE fact1
    (73) factor -> . CTE_STR fact1
    (74) factor -> . CTE_FLT fact1
    (75) factor -> . CTE_NUM fact1
    (76) factor -> . ID fact1 LPAREN logic multiexp RPAREN
    (77) factor -> . ID fact1 arr
    ID              shift and go to state 117
    FALSE           shift and go to state 81
    TRUE            shift and go to state 82
    CTE_STR         shift and go to state 83
    CTE_FLT         shift and go to state 84
    CTE_NUM         shift and go to state 85

    func_stmnt                     shift and go to state 118
    logic                          shift and go to state 119
    rel                            shift and go to state 77
    exp                            shift and go to state 78
    term                           shift and go to state 79
    factor                         shift and go to state 80

state 93

    (18) arr -> LSQUARE exp . RSQUARE
    RSQUARE         shift and go to state 120


state 94

    (44) read_stmnt -> READ LPAREN ID . multid RPAREN SEMICLN
    (11) multid -> . empty
    (12) multid -> . COMMA ID prog5 arr multid
    (85) empty -> .
    COMMA           shift and go to state 30
    RPAREN          reduce using rule 85 (empty -> .)

    multid                         shift and go to state 121
    empty                          shift and go to state 29

state 95

    (43) ret_stmnt -> RETURN LPAREN logic . RPAREN SEMICLN
    RPAREN          shift and go to state 122


state 96

    (20) funcdecl -> FUNC tipofunc ID LPAREN param RPAREN varsdecl . LCURLY stmnt RCURLY
    LCURLY          shift and go to state 123


state 97

    (24) param -> tipo COLON ID . multiparam
    (25) multiparam -> . empty
    (26) multiparam -> . COMMA param
    (85) empty -> .
    COMMA           shift and go to state 126
    RPAREN          reduce using rule 85 (empty -> .)

    multiparam                     shift and go to state 124
    empty                          shift and go to state 125

state 98

    (12) multid -> COMMA ID prog5 arr multid .
    FUNC            reduce using rule 12 (multid -> COMMA ID prog5 arr multid .)
    MAIN            reduce using rule 12 (multid -> COMMA ID prog5 arr multid .)
    LCURLY          reduce using rule 12 (multid -> COMMA ID prog5 arr multid .)
    RPAREN          reduce using rule 12 (multid -> COMMA ID prog5 arr multid .)
    SEMICLN         reduce using rule 12 (multid -> COMMA ID prog5 arr multid .)


state 99

    (8) multivd -> tipo prog4 COLON ID prog5 arr . multid SEMICLN multivd
    (11) multid -> . empty
    (12) multid -> . COMMA ID prog5 arr multid
    (85) empty -> .
    COMMA           shift and go to state 30
    SEMICLN         reduce using rule 85 (empty -> .)

    multid                         shift and go to state 127
    empty                          shift and go to state 29

state 100

    (84) while_stmnt -> WHILE LPAREN logic RPAREN . stmnt END
    (28) stmnt -> . empty
    (29) stmnt -> . while_stmnt stmnt
    (30) stmnt -> . if_stmnt stmnt
    (31) stmnt -> . write_stmnt stmnt
    (32) stmnt -> . read_stmnt stmnt
    (33) stmnt -> . ret_stmnt stmnt
    (34) stmnt -> . func_stmnt stmnt
    (35) stmnt -> . ass_stmnt stmnt
    (85) empty -> .
    (84) while_stmnt -> . WHILE LPAREN logic RPAREN stmnt END
    (81) if_stmnt -> . IF LPAREN logic RPAREN else_stmnt END
    (45) write_stmnt -> . WRITE LPAREN ID multid RPAREN SEMICLN
    (44) read_stmnt -> . READ LPAREN ID multid RPAREN SEMICLN
    (43) ret_stmnt -> . RETURN LPAREN logic RPAREN SEMICLN
    (38) func_stmnt -> . ID LPAREN arg RPAREN SEMICLN
    (36) ass_stmnt -> . ID arr ASS func_stmnt SEMICLN
    (37) ass_stmnt -> . ID arr ASS logic SEMICLN
    END             reduce using rule 85 (empty -> .)
    WHILE           shift and go to state 45
    IF              shift and go to state 46
    WRITE           shift and go to state 47
    READ            shift and go to state 49
    RETURN          shift and go to state 50
    ID              shift and go to state 48

    stmnt                          shift and go to state 128
    empty                          shift and go to state 37
    while_stmnt                    shift and go to state 38
    if_stmnt                       shift and go to state 39
    write_stmnt                    shift and go to state 40
    read_stmnt                     shift and go to state 41
    ret_stmnt                      shift and go to state 42
    func_stmnt                     shift and go to state 43
    ass_stmnt                      shift and go to state 44

state 101

    (46) logic -> rel log2 . OR log1 logic
    (47) logic -> rel log2 . AND log1 logic
    (48) logic -> rel log2 .
    OR              shift and go to state 129
    AND             shift and go to state 130
    RPAREN          reduce using rule 48 (logic -> rel log2 .)
    COMMA           reduce using rule 48 (logic -> rel log2 .)
    SEMICLN         reduce using rule 48 (logic -> rel log2 .)


state 102

    (57) rel -> exp rel2 . relop rel1 rel
    (58) rel -> exp rel2 .
    (51) relop -> . EQUAL_TO
    (52) relop -> . DIFFERENT_TO
    (53) relop -> . LESS_OR_EQ_THAN
    (54) relop -> . MORE_OR_EQ_THAN
    (55) relop -> . LESS_THAN
    (56) relop -> . MORE_THAN
    OR              reduce using rule 58 (rel -> exp rel2 .)
    AND             reduce using rule 58 (rel -> exp rel2 .)
    RPAREN          reduce using rule 58 (rel -> exp rel2 .)
    COMMA           reduce using rule 58 (rel -> exp rel2 .)
    SEMICLN         reduce using rule 58 (rel -> exp rel2 .)
    EQUAL_TO        shift and go to state 132
    DIFFERENT_TO    shift and go to state 133
    LESS_OR_EQ_THAN shift and go to state 134
    MORE_OR_EQ_THAN shift and go to state 135
    LESS_THAN       shift and go to state 136
    MORE_THAN       shift and go to state 137

    relop                          shift and go to state 131

state 103

    (61) exp -> term exp2 . SUB exp1 exp
    (62) exp -> term exp2 . SUM exp1 exp
    (63) exp -> term exp2 .
    SUB             shift and go to state 138
    SUM             shift and go to state 139
    EQUAL_TO        reduce using rule 63 (exp -> term exp2 .)
    DIFFERENT_TO    reduce using rule 63 (exp -> term exp2 .)
    LESS_OR_EQ_THAN reduce using rule 63 (exp -> term exp2 .)
    MORE_OR_EQ_THAN reduce using rule 63 (exp -> term exp2 .)
    LESS_THAN       reduce using rule 63 (exp -> term exp2 .)
    MORE_THAN       reduce using rule 63 (exp -> term exp2 .)
    OR              reduce using rule 63 (exp -> term exp2 .)
    AND             reduce using rule 63 (exp -> term exp2 .)
    RPAREN          reduce using rule 63 (exp -> term exp2 .)
    COMMA           reduce using rule 63 (exp -> term exp2 .)
    RSQUARE         reduce using rule 63 (exp -> term exp2 .)
    SEMICLN         reduce using rule 63 (exp -> term exp2 .)


state 104

    (66) term -> factor term2 . DIV term1 term
    (67) term -> factor term2 . MULT term1 term
    (68) term -> factor term2 .
    DIV             shift and go to state 140
    MULT            shift and go to state 141
    SUB             reduce using rule 68 (term -> factor term2 .)
    SUM             reduce using rule 68 (term -> factor term2 .)
    EQUAL_TO        reduce using rule 68 (term -> factor term2 .)
    DIFFERENT_TO    reduce using rule 68 (term -> factor term2 .)
    LESS_OR_EQ_THAN reduce using rule 68 (term -> factor term2 .)
    MORE_OR_EQ_THAN reduce using rule 68 (term -> factor term2 .)
    LESS_THAN       reduce using rule 68 (term -> factor term2 .)
    MORE_THAN       reduce using rule 68 (term -> factor term2 .)
    OR              reduce using rule 68 (term -> factor term2 .)
    AND             reduce using rule 68 (term -> factor term2 .)
    RPAREN          reduce using rule 68 (term -> factor term2 .)
    COMMA           reduce using rule 68 (term -> factor term2 .)
    RSQUARE         reduce using rule 68 (term -> factor term2 .)
    SEMICLN         reduce using rule 68 (term -> factor term2 .)


state 105

    (71) factor -> FALSE fact1 .
    DIV             reduce using rule 71 (factor -> FALSE fact1 .)
    MULT            reduce using rule 71 (factor -> FALSE fact1 .)
    SUB             reduce using rule 71 (factor -> FALSE fact1 .)
    SUM             reduce using rule 71 (factor -> FALSE fact1 .)
    EQUAL_TO        reduce using rule 71 (factor -> FALSE fact1 .)
    DIFFERENT_TO    reduce using rule 71 (factor -> FALSE fact1 .)
    LESS_OR_EQ_THAN reduce using rule 71 (factor -> FALSE fact1 .)
    MORE_OR_EQ_THAN reduce using rule 71 (factor -> FALSE fact1 .)
    LESS_THAN       reduce using rule 71 (factor -> FALSE fact1 .)
    MORE_THAN       reduce using rule 71 (factor -> FALSE fact1 .)
    OR              reduce using rule 71 (factor -> FALSE fact1 .)
    AND             reduce using rule 71 (factor -> FALSE fact1 .)
    RPAREN          reduce using rule 71 (factor -> FALSE fact1 .)
    COMMA           reduce using rule 71 (factor -> FALSE fact1 .)
    RSQUARE         reduce using rule 71 (factor -> FALSE fact1 .)
    SEMICLN         reduce using rule 71 (factor -> FALSE fact1 .)


state 106

    (72) factor -> TRUE fact1 .
    DIV             reduce using rule 72 (factor -> TRUE fact1 .)
    MULT            reduce using rule 72 (factor -> TRUE fact1 .)
    SUB             reduce using rule 72 (factor -> TRUE fact1 .)
    SUM             reduce using rule 72 (factor -> TRUE fact1 .)
    EQUAL_TO        reduce using rule 72 (factor -> TRUE fact1 .)
    DIFFERENT_TO    reduce using rule 72 (factor -> TRUE fact1 .)
    LESS_OR_EQ_THAN reduce using rule 72 (factor -> TRUE fact1 .)
    MORE_OR_EQ_THAN reduce using rule 72 (factor -> TRUE fact1 .)
    LESS_THAN       reduce using rule 72 (factor -> TRUE fact1 .)
    MORE_THAN       reduce using rule 72 (factor -> TRUE fact1 .)
    OR              reduce using rule 72 (factor -> TRUE fact1 .)
    AND             reduce using rule 72 (factor -> TRUE fact1 .)
    RPAREN          reduce using rule 72 (factor -> TRUE fact1 .)
    COMMA           reduce using rule 72 (factor -> TRUE fact1 .)
    RSQUARE         reduce using rule 72 (factor -> TRUE fact1 .)
    SEMICLN         reduce using rule 72 (factor -> TRUE fact1 .)


state 107

    (73) factor -> CTE_STR fact1 .
    DIV             reduce using rule 73 (factor -> CTE_STR fact1 .)
    MULT            reduce using rule 73 (factor -> CTE_STR fact1 .)
    SUB             reduce using rule 73 (factor -> CTE_STR fact1 .)
    SUM             reduce using rule 73 (factor -> CTE_STR fact1 .)
    EQUAL_TO        reduce using rule 73 (factor -> CTE_STR fact1 .)
    DIFFERENT_TO    reduce using rule 73 (factor -> CTE_STR fact1 .)
    LESS_OR_EQ_THAN reduce using rule 73 (factor -> CTE_STR fact1 .)
    MORE_OR_EQ_THAN reduce using rule 73 (factor -> CTE_STR fact1 .)
    LESS_THAN       reduce using rule 73 (factor -> CTE_STR fact1 .)
    MORE_THAN       reduce using rule 73 (factor -> CTE_STR fact1 .)
    OR              reduce using rule 73 (factor -> CTE_STR fact1 .)
    AND             reduce using rule 73 (factor -> CTE_STR fact1 .)
    RPAREN          reduce using rule 73 (factor -> CTE_STR fact1 .)
    COMMA           reduce using rule 73 (factor -> CTE_STR fact1 .)
    RSQUARE         reduce using rule 73 (factor -> CTE_STR fact1 .)
    SEMICLN         reduce using rule 73 (factor -> CTE_STR fact1 .)


state 108

    (74) factor -> CTE_FLT fact1 .
    DIV             reduce using rule 74 (factor -> CTE_FLT fact1 .)
    MULT            reduce using rule 74 (factor -> CTE_FLT fact1 .)
    SUB             reduce using rule 74 (factor -> CTE_FLT fact1 .)
    SUM             reduce using rule 74 (factor -> CTE_FLT fact1 .)
    EQUAL_TO        reduce using rule 74 (factor -> CTE_FLT fact1 .)
    DIFFERENT_TO    reduce using rule 74 (factor -> CTE_FLT fact1 .)
    LESS_OR_EQ_THAN reduce using rule 74 (factor -> CTE_FLT fact1 .)
    MORE_OR_EQ_THAN reduce using rule 74 (factor -> CTE_FLT fact1 .)
    LESS_THAN       reduce using rule 74 (factor -> CTE_FLT fact1 .)
    MORE_THAN       reduce using rule 74 (factor -> CTE_FLT fact1 .)
    OR              reduce using rule 74 (factor -> CTE_FLT fact1 .)
    AND             reduce using rule 74 (factor -> CTE_FLT fact1 .)
    RPAREN          reduce using rule 74 (factor -> CTE_FLT fact1 .)
    COMMA           reduce using rule 74 (factor -> CTE_FLT fact1 .)
    RSQUARE         reduce using rule 74 (factor -> CTE_FLT fact1 .)
    SEMICLN         reduce using rule 74 (factor -> CTE_FLT fact1 .)


state 109

    (75) factor -> CTE_NUM fact1 .
    DIV             reduce using rule 75 (factor -> CTE_NUM fact1 .)
    MULT            reduce using rule 75 (factor -> CTE_NUM fact1 .)
    SUB             reduce using rule 75 (factor -> CTE_NUM fact1 .)
    SUM             reduce using rule 75 (factor -> CTE_NUM fact1 .)
    EQUAL_TO        reduce using rule 75 (factor -> CTE_NUM fact1 .)
    DIFFERENT_TO    reduce using rule 75 (factor -> CTE_NUM fact1 .)
    LESS_OR_EQ_THAN reduce using rule 75 (factor -> CTE_NUM fact1 .)
    MORE_OR_EQ_THAN reduce using rule 75 (factor -> CTE_NUM fact1 .)
    LESS_THAN       reduce using rule 75 (factor -> CTE_NUM fact1 .)
    MORE_THAN       reduce using rule 75 (factor -> CTE_NUM fact1 .)
    OR              reduce using rule 75 (factor -> CTE_NUM fact1 .)
    AND             reduce using rule 75 (factor -> CTE_NUM fact1 .)
    RPAREN          reduce using rule 75 (factor -> CTE_NUM fact1 .)
    COMMA           reduce using rule 75 (factor -> CTE_NUM fact1 .)
    RSQUARE         reduce using rule 75 (factor -> CTE_NUM fact1 .)
    SEMICLN         reduce using rule 75 (factor -> CTE_NUM fact1 .)


state 110

    (76) factor -> ID fact1 . LPAREN logic multiexp RPAREN
    (77) factor -> ID fact1 . arr
    (17) arr -> . empty
    (18) arr -> . LSQUARE exp RSQUARE
    (85) empty -> .
    LPAREN          shift and go to state 142
    LSQUARE         shift and go to state 69
    DIV             reduce using rule 85 (empty -> .)
    MULT            reduce using rule 85 (empty -> .)
    SUB             reduce using rule 85 (empty -> .)
    SUM             reduce using rule 85 (empty -> .)
    EQUAL_TO        reduce using rule 85 (empty -> .)
    DIFFERENT_TO    reduce using rule 85 (empty -> .)
    LESS_OR_EQ_THAN reduce using rule 85 (empty -> .)
    MORE_OR_EQ_THAN reduce using rule 85 (empty -> .)
    LESS_THAN       reduce using rule 85 (empty -> .)
    MORE_THAN       reduce using rule 85 (empty -> .)
    OR              reduce using rule 85 (empty -> .)
    AND             reduce using rule 85 (empty -> .)
    RPAREN          reduce using rule 85 (empty -> .)
    COMMA           reduce using rule 85 (empty -> .)
    RSQUARE         reduce using rule 85 (empty -> .)
    SEMICLN         reduce using rule 85 (empty -> .)

    arr                            shift and go to state 143
    empty                          shift and go to state 68

state 111

    (81) if_stmnt -> IF LPAREN logic RPAREN . else_stmnt END
    (82) else_stmnt -> . empty
    (83) else_stmnt -> . ELSE stmnt
    (85) empty -> .
    ELSE            shift and go to state 146
    END             reduce using rule 85 (empty -> .)

    else_stmnt                     shift and go to state 144
    empty                          shift and go to state 145

state 112

    (45) write_stmnt -> WRITE LPAREN ID multid . RPAREN SEMICLN
    RPAREN          shift and go to state 147


state 113

    (38) func_stmnt -> ID LPAREN arg RPAREN . SEMICLN
    SEMICLN         shift and go to state 148


state 114

    (40) arg -> logic multiarg .
    RPAREN          reduce using rule 40 (arg -> logic multiarg .)
    COMMA           reduce using rule 40 (arg -> logic multiarg .)


state 115

    (41) multiarg -> empty .
    COMMA           reduce using rule 41 (multiarg -> empty .)
    RPAREN          reduce using rule 41 (multiarg -> empty .)


state 116

    (42) multiarg -> COMMA . arg multiarg
    (39) arg -> . empty
    (40) arg -> . logic multiarg
    (85) empty -> .
    (46) logic -> . rel log2 OR log1 logic
    (47) logic -> . rel log2 AND log1 logic
    (48) logic -> . rel log2
    (57) rel -> . exp rel2 relop rel1 rel
    (58) rel -> . exp rel2
    (61) exp -> . term exp2 SUB exp1 exp
    (62) exp -> . term exp2 SUM exp1 exp
    (63) exp -> . term exp2
    (66) term -> . factor term2 DIV term1 term
    (67) term -> . factor term2 MULT term1 term
    (68) term -> . factor term2
    (71) factor -> . FALSE fact1
    (72) factor -> . TRUE fact1
    (73) factor -> . CTE_STR fact1
    (74) factor -> . CTE_FLT fact1
    (75) factor -> . CTE_NUM fact1
    (76) factor -> . ID fact1 LPAREN logic multiexp RPAREN
    (77) factor -> . ID fact1 arr
    COMMA           reduce using rule 85 (empty -> .)
    RPAREN          reduce using rule 85 (empty -> .)
    FALSE           shift and go to state 81
    TRUE            shift and go to state 82
    CTE_STR         shift and go to state 83
    CTE_FLT         shift and go to state 84
    CTE_NUM         shift and go to state 85
    ID              shift and go to state 86

    arg                            shift and go to state 149
    empty                          shift and go to state 90
    logic                          shift and go to state 91
    rel                            shift and go to state 77
    exp                            shift and go to state 78
    term                           shift and go to state 79
    factor                         shift and go to state 80

state 117

    (38) func_stmnt -> ID . LPAREN arg RPAREN SEMICLN
    (76) factor -> ID . fact1 LPAREN logic multiexp RPAREN
    (77) factor -> ID . fact1 arr
    (78) fact1 -> .
  ! shift/reduce conflict for LPAREN resolved as shift
    LPAREN          shift and go to state 66
    LSQUARE         reduce using rule 78 (fact1 -> .)
    DIV             reduce using rule 78 (fact1 -> .)
    MULT            reduce using rule 78 (fact1 -> .)
    SUB             reduce using rule 78 (fact1 -> .)
    SUM             reduce using rule 78 (fact1 -> .)
    EQUAL_TO        reduce using rule 78 (fact1 -> .)
    DIFFERENT_TO    reduce using rule 78 (fact1 -> .)
    LESS_OR_EQ_THAN reduce using rule 78 (fact1 -> .)
    MORE_OR_EQ_THAN reduce using rule 78 (fact1 -> .)
    LESS_THAN       reduce using rule 78 (fact1 -> .)
    MORE_THAN       reduce using rule 78 (fact1 -> .)
    OR              reduce using rule 78 (fact1 -> .)
    AND             reduce using rule 78 (fact1 -> .)
    SEMICLN         reduce using rule 78 (fact1 -> .)

    fact1                          shift and go to state 110

state 118

    (36) ass_stmnt -> ID arr ASS func_stmnt . SEMICLN
    SEMICLN         shift and go to state 150


state 119

    (37) ass_stmnt -> ID arr ASS logic . SEMICLN
    SEMICLN         shift and go to state 151


state 120

    (18) arr -> LSQUARE exp RSQUARE .
    ASS             reduce using rule 18 (arr -> LSQUARE exp RSQUARE .)
    COMMA           reduce using rule 18 (arr -> LSQUARE exp RSQUARE .)
    FUNC            reduce using rule 18 (arr -> LSQUARE exp RSQUARE .)
    MAIN            reduce using rule 18 (arr -> LSQUARE exp RSQUARE .)
    LCURLY          reduce using rule 18 (arr -> LSQUARE exp RSQUARE .)
    RPAREN          reduce using rule 18 (arr -> LSQUARE exp RSQUARE .)
    SEMICLN         reduce using rule 18 (arr -> LSQUARE exp RSQUARE .)
    DIV             reduce using rule 18 (arr -> LSQUARE exp RSQUARE .)
    MULT            reduce using rule 18 (arr -> LSQUARE exp RSQUARE .)
    SUB             reduce using rule 18 (arr -> LSQUARE exp RSQUARE .)
    SUM             reduce using rule 18 (arr -> LSQUARE exp RSQUARE .)
    EQUAL_TO        reduce using rule 18 (arr -> LSQUARE exp RSQUARE .)
    DIFFERENT_TO    reduce using rule 18 (arr -> LSQUARE exp RSQUARE .)
    LESS_OR_EQ_THAN reduce using rule 18 (arr -> LSQUARE exp RSQUARE .)
    MORE_OR_EQ_THAN reduce using rule 18 (arr -> LSQUARE exp RSQUARE .)
    LESS_THAN       reduce using rule 18 (arr -> LSQUARE exp RSQUARE .)
    MORE_THAN       reduce using rule 18 (arr -> LSQUARE exp RSQUARE .)
    OR              reduce using rule 18 (arr -> LSQUARE exp RSQUARE .)
    AND             reduce using rule 18 (arr -> LSQUARE exp RSQUARE .)
    RSQUARE         reduce using rule 18 (arr -> LSQUARE exp RSQUARE .)


state 121

    (44) read_stmnt -> READ LPAREN ID multid . RPAREN SEMICLN
    RPAREN          shift and go to state 152


state 122

    (43) ret_stmnt -> RETURN LPAREN logic RPAREN . SEMICLN
    SEMICLN         shift and go to state 153


state 123

    (20) funcdecl -> FUNC tipofunc ID LPAREN param RPAREN varsdecl LCURLY . stmnt RCURLY
    (28) stmnt -> . empty
    (29) stmnt -> . while_stmnt stmnt
    (30) stmnt -> . if_stmnt stmnt
    (31) stmnt -> . write_stmnt stmnt
    (32) stmnt -> . read_stmnt stmnt
    (33) stmnt -> . ret_stmnt stmnt
    (34) stmnt -> . func_stmnt stmnt
    (35) stmnt -> . ass_stmnt stmnt
    (85) empty -> .
    (84) while_stmnt -> . WHILE LPAREN logic RPAREN stmnt END
    (81) if_stmnt -> . IF LPAREN logic RPAREN else_stmnt END
    (45) write_stmnt -> . WRITE LPAREN ID multid RPAREN SEMICLN
    (44) read_stmnt -> . READ LPAREN ID multid RPAREN SEMICLN
    (43) ret_stmnt -> . RETURN LPAREN logic RPAREN SEMICLN
    (38) func_stmnt -> . ID LPAREN arg RPAREN SEMICLN
    (36) ass_stmnt -> . ID arr ASS func_stmnt SEMICLN
    (37) ass_stmnt -> . ID arr ASS logic SEMICLN
    RCURLY          reduce using rule 85 (empty -> .)
    WHILE           shift and go to state 45
    IF              shift and go to state 46
    WRITE           shift and go to state 47
    READ            shift and go to state 49
    RETURN          shift and go to state 50
    ID              shift and go to state 48

    stmnt                          shift and go to state 154
    empty                          shift and go to state 37
    while_stmnt                    shift and go to state 38
    if_stmnt                       shift and go to state 39
    write_stmnt                    shift and go to state 40
    read_stmnt                     shift and go to state 41
    ret_stmnt                      shift and go to state 42
    func_stmnt                     shift and go to state 43
    ass_stmnt                      shift and go to state 44

state 124

    (24) param -> tipo COLON ID multiparam .
    RPAREN          reduce using rule 24 (param -> tipo COLON ID multiparam .)


state 125

    (25) multiparam -> empty .
    RPAREN          reduce using rule 25 (multiparam -> empty .)


state 126

    (26) multiparam -> COMMA . param
    (23) param -> . empty
    (24) param -> . tipo COLON ID multiparam
    (85) empty -> .
    (13) tipo -> . BOOL
    (14) tipo -> . CHAR
    (15) tipo -> . FLOAT
    (16) tipo -> . INT
    RPAREN          reduce using rule 85 (empty -> .)
    BOOL            shift and go to state 19
    CHAR            shift and go to state 20
    FLOAT           shift and go to state 21
    INT             shift and go to state 22

    param                          shift and go to state 155
    empty                          shift and go to state 52
    tipo                           shift and go to state 53

state 127

    (8) multivd -> tipo prog4 COLON ID prog5 arr multid . SEMICLN multivd
    SEMICLN         shift and go to state 156


state 128

    (84) while_stmnt -> WHILE LPAREN logic RPAREN stmnt . END
    END             shift and go to state 157


state 129

    (46) logic -> rel log2 OR . log1 logic
    (49) log1 -> .
    FALSE           reduce using rule 49 (log1 -> .)
    TRUE            reduce using rule 49 (log1 -> .)
    CTE_STR         reduce using rule 49 (log1 -> .)
    CTE_FLT         reduce using rule 49 (log1 -> .)
    CTE_NUM         reduce using rule 49 (log1 -> .)
    ID              reduce using rule 49 (log1 -> .)

    log1                           shift and go to state 158

state 130

    (47) logic -> rel log2 AND . log1 logic
    (49) log1 -> .
    FALSE           reduce using rule 49 (log1 -> .)
    TRUE            reduce using rule 49 (log1 -> .)
    CTE_STR         reduce using rule 49 (log1 -> .)
    CTE_FLT         reduce using rule 49 (log1 -> .)
    CTE_NUM         reduce using rule 49 (log1 -> .)
    ID              reduce using rule 49 (log1 -> .)

    log1                           shift and go to state 159

state 131

    (57) rel -> exp rel2 relop . rel1 rel
    (59) rel1 -> .
    FALSE           reduce using rule 59 (rel1 -> .)
    TRUE            reduce using rule 59 (rel1 -> .)
    CTE_STR         reduce using rule 59 (rel1 -> .)
    CTE_FLT         reduce using rule 59 (rel1 -> .)
    CTE_NUM         reduce using rule 59 (rel1 -> .)
    ID              reduce using rule 59 (rel1 -> .)

    rel1                           shift and go to state 160

state 132

    (51) relop -> EQUAL_TO .
    FALSE           reduce using rule 51 (relop -> EQUAL_TO .)
    TRUE            reduce using rule 51 (relop -> EQUAL_TO .)
    CTE_STR         reduce using rule 51 (relop -> EQUAL_TO .)
    CTE_FLT         reduce using rule 51 (relop -> EQUAL_TO .)
    CTE_NUM         reduce using rule 51 (relop -> EQUAL_TO .)
    ID              reduce using rule 51 (relop -> EQUAL_TO .)


state 133

    (52) relop -> DIFFERENT_TO .
    FALSE           reduce using rule 52 (relop -> DIFFERENT_TO .)
    TRUE            reduce using rule 52 (relop -> DIFFERENT_TO .)
    CTE_STR         reduce using rule 52 (relop -> DIFFERENT_TO .)
    CTE_FLT         reduce using rule 52 (relop -> DIFFERENT_TO .)
    CTE_NUM         reduce using rule 52 (relop -> DIFFERENT_TO .)
    ID              reduce using rule 52 (relop -> DIFFERENT_TO .)


state 134

    (53) relop -> LESS_OR_EQ_THAN .
    FALSE           reduce using rule 53 (relop -> LESS_OR_EQ_THAN .)
    TRUE            reduce using rule 53 (relop -> LESS_OR_EQ_THAN .)
    CTE_STR         reduce using rule 53 (relop -> LESS_OR_EQ_THAN .)
    CTE_FLT         reduce using rule 53 (relop -> LESS_OR_EQ_THAN .)
    CTE_NUM         reduce using rule 53 (relop -> LESS_OR_EQ_THAN .)
    ID              reduce using rule 53 (relop -> LESS_OR_EQ_THAN .)


state 135

    (54) relop -> MORE_OR_EQ_THAN .
    FALSE           reduce using rule 54 (relop -> MORE_OR_EQ_THAN .)
    TRUE            reduce using rule 54 (relop -> MORE_OR_EQ_THAN .)
    CTE_STR         reduce using rule 54 (relop -> MORE_OR_EQ_THAN .)
    CTE_FLT         reduce using rule 54 (relop -> MORE_OR_EQ_THAN .)
    CTE_NUM         reduce using rule 54 (relop -> MORE_OR_EQ_THAN .)
    ID              reduce using rule 54 (relop -> MORE_OR_EQ_THAN .)


state 136

    (55) relop -> LESS_THAN .
    FALSE           reduce using rule 55 (relop -> LESS_THAN .)
    TRUE            reduce using rule 55 (relop -> LESS_THAN .)
    CTE_STR         reduce using rule 55 (relop -> LESS_THAN .)
    CTE_FLT         reduce using rule 55 (relop -> LESS_THAN .)
    CTE_NUM         reduce using rule 55 (relop -> LESS_THAN .)
    ID              reduce using rule 55 (relop -> LESS_THAN .)


state 137

    (56) relop -> MORE_THAN .
    FALSE           reduce using rule 56 (relop -> MORE_THAN .)
    TRUE            reduce using rule 56 (relop -> MORE_THAN .)
    CTE_STR         reduce using rule 56 (relop -> MORE_THAN .)
    CTE_FLT         reduce using rule 56 (relop -> MORE_THAN .)
    CTE_NUM         reduce using rule 56 (relop -> MORE_THAN .)
    ID              reduce using rule 56 (relop -> MORE_THAN .)


state 138

    (61) exp -> term exp2 SUB . exp1 exp
    (65) exp1 -> .
    FALSE           reduce using rule 65 (exp1 -> .)
    TRUE            reduce using rule 65 (exp1 -> .)
    CTE_STR         reduce using rule 65 (exp1 -> .)
    CTE_FLT         reduce using rule 65 (exp1 -> .)
    CTE_NUM         reduce using rule 65 (exp1 -> .)
    ID              reduce using rule 65 (exp1 -> .)

    exp1                           shift and go to state 161

state 139

    (62) exp -> term exp2 SUM . exp1 exp
    (65) exp1 -> .
    FALSE           reduce using rule 65 (exp1 -> .)
    TRUE            reduce using rule 65 (exp1 -> .)
    CTE_STR         reduce using rule 65 (exp1 -> .)
    CTE_FLT         reduce using rule 65 (exp1 -> .)
    CTE_NUM         reduce using rule 65 (exp1 -> .)
    ID              reduce using rule 65 (exp1 -> .)

    exp1                           shift and go to state 162

state 140

    (66) term -> factor term2 DIV . term1 term
    (69) term1 -> .
    FALSE           reduce using rule 69 (term1 -> .)
    TRUE            reduce using rule 69 (term1 -> .)
    CTE_STR         reduce using rule 69 (term1 -> .)
    CTE_FLT         reduce using rule 69 (term1 -> .)
    CTE_NUM         reduce using rule 69 (term1 -> .)
    ID              reduce using rule 69 (term1 -> .)

    term1                          shift and go to state 163

state 141

    (67) term -> factor term2 MULT . term1 term
    (69) term1 -> .
    FALSE           reduce using rule 69 (term1 -> .)
    TRUE            reduce using rule 69 (term1 -> .)
    CTE_STR         reduce using rule 69 (term1 -> .)
    CTE_FLT         reduce using rule 69 (term1 -> .)
    CTE_NUM         reduce using rule 69 (term1 -> .)
    ID              reduce using rule 69 (term1 -> .)

    term1                          shift and go to state 164

state 142

    (76) factor -> ID fact1 LPAREN . logic multiexp RPAREN
    (46) logic -> . rel log2 OR log1 logic
    (47) logic -> . rel log2 AND log1 logic
    (48) logic -> . rel log2
    (57) rel -> . exp rel2 relop rel1 rel
    (58) rel -> . exp rel2
    (61) exp -> . term exp2 SUB exp1 exp
    (62) exp -> . term exp2 SUM exp1 exp
    (63) exp -> . term exp2
    (66) term -> . factor term2 DIV term1 term
    (67) term -> . factor term2 MULT term1 term
    (68) term -> . factor term2
    (71) factor -> . FALSE fact1
    (72) factor -> . TRUE fact1
    (73) factor -> . CTE_STR fact1
    (74) factor -> . CTE_FLT fact1
    (75) factor -> . CTE_NUM fact1
    (76) factor -> . ID fact1 LPAREN logic multiexp RPAREN
    (77) factor -> . ID fact1 arr
    FALSE           shift and go to state 81
    TRUE            shift and go to state 82
    CTE_STR         shift and go to state 83
    CTE_FLT         shift and go to state 84
    CTE_NUM         shift and go to state 85
    ID              shift and go to state 86

    logic                          shift and go to state 165
    rel                            shift and go to state 77
    exp                            shift and go to state 78
    term                           shift and go to state 79
    factor                         shift and go to state 80

state 143

    (77) factor -> ID fact1 arr .
    DIV             reduce using rule 77 (factor -> ID fact1 arr .)
    MULT            reduce using rule 77 (factor -> ID fact1 arr .)
    SUB             reduce using rule 77 (factor -> ID fact1 arr .)
    SUM             reduce using rule 77 (factor -> ID fact1 arr .)
    EQUAL_TO        reduce using rule 77 (factor -> ID fact1 arr .)
    DIFFERENT_TO    reduce using rule 77 (factor -> ID fact1 arr .)
    LESS_OR_EQ_THAN reduce using rule 77 (factor -> ID fact1 arr .)
    MORE_OR_EQ_THAN reduce using rule 77 (factor -> ID fact1 arr .)
    LESS_THAN       reduce using rule 77 (factor -> ID fact1 arr .)
    MORE_THAN       reduce using rule 77 (factor -> ID fact1 arr .)
    OR              reduce using rule 77 (factor -> ID fact1 arr .)
    AND             reduce using rule 77 (factor -> ID fact1 arr .)
    RPAREN          reduce using rule 77 (factor -> ID fact1 arr .)
    COMMA           reduce using rule 77 (factor -> ID fact1 arr .)
    RSQUARE         reduce using rule 77 (factor -> ID fact1 arr .)
    SEMICLN         reduce using rule 77 (factor -> ID fact1 arr .)


state 144

    (81) if_stmnt -> IF LPAREN logic RPAREN else_stmnt . END
    END             shift and go to state 166


state 145

    (82) else_stmnt -> empty .
    END             reduce using rule 82 (else_stmnt -> empty .)


state 146

    (83) else_stmnt -> ELSE . stmnt
    (28) stmnt -> . empty
    (29) stmnt -> . while_stmnt stmnt
    (30) stmnt -> . if_stmnt stmnt
    (31) stmnt -> . write_stmnt stmnt
    (32) stmnt -> . read_stmnt stmnt
    (33) stmnt -> . ret_stmnt stmnt
    (34) stmnt -> . func_stmnt stmnt
    (35) stmnt -> . ass_stmnt stmnt
    (85) empty -> .
    (84) while_stmnt -> . WHILE LPAREN logic RPAREN stmnt END
    (81) if_stmnt -> . IF LPAREN logic RPAREN else_stmnt END
    (45) write_stmnt -> . WRITE LPAREN ID multid RPAREN SEMICLN
    (44) read_stmnt -> . READ LPAREN ID multid RPAREN SEMICLN
    (43) ret_stmnt -> . RETURN LPAREN logic RPAREN SEMICLN
    (38) func_stmnt -> . ID LPAREN arg RPAREN SEMICLN
    (36) ass_stmnt -> . ID arr ASS func_stmnt SEMICLN
    (37) ass_stmnt -> . ID arr ASS logic SEMICLN
    END             reduce using rule 85 (empty -> .)
    WHILE           shift and go to state 45
    IF              shift and go to state 46
    WRITE           shift and go to state 47
    READ            shift and go to state 49
    RETURN          shift and go to state 50
    ID              shift and go to state 48

    stmnt                          shift and go to state 167
    empty                          shift and go to state 37
    while_stmnt                    shift and go to state 38
    if_stmnt                       shift and go to state 39
    write_stmnt                    shift and go to state 40
    read_stmnt                     shift and go to state 41
    ret_stmnt                      shift and go to state 42
    func_stmnt                     shift and go to state 43
    ass_stmnt                      shift and go to state 44

state 147

    (45) write_stmnt -> WRITE LPAREN ID multid RPAREN . SEMICLN
    SEMICLN         shift and go to state 168


state 148

    (38) func_stmnt -> ID LPAREN arg RPAREN SEMICLN .
    WHILE           reduce using rule 38 (func_stmnt -> ID LPAREN arg RPAREN SEMICLN .)
    IF              reduce using rule 38 (func_stmnt -> ID LPAREN arg RPAREN SEMICLN .)
    WRITE           reduce using rule 38 (func_stmnt -> ID LPAREN arg RPAREN SEMICLN .)
    READ            reduce using rule 38 (func_stmnt -> ID LPAREN arg RPAREN SEMICLN .)
    RETURN          reduce using rule 38 (func_stmnt -> ID LPAREN arg RPAREN SEMICLN .)
    ID              reduce using rule 38 (func_stmnt -> ID LPAREN arg RPAREN SEMICLN .)
    $end            reduce using rule 38 (func_stmnt -> ID LPAREN arg RPAREN SEMICLN .)
    END             reduce using rule 38 (func_stmnt -> ID LPAREN arg RPAREN SEMICLN .)
    RCURLY          reduce using rule 38 (func_stmnt -> ID LPAREN arg RPAREN SEMICLN .)
    SEMICLN         reduce using rule 38 (func_stmnt -> ID LPAREN arg RPAREN SEMICLN .)


state 149

    (42) multiarg -> COMMA arg . multiarg
    (41) multiarg -> . empty
    (42) multiarg -> . COMMA arg multiarg
    (85) empty -> .
  ! shift/reduce conflict for COMMA resolved as shift
    COMMA           shift and go to state 116
    RPAREN          reduce using rule 85 (empty -> .)

    multiarg                       shift and go to state 169
    empty                          shift and go to state 115

state 150

    (36) ass_stmnt -> ID arr ASS func_stmnt SEMICLN .
    WHILE           reduce using rule 36 (ass_stmnt -> ID arr ASS func_stmnt SEMICLN .)
    IF              reduce using rule 36 (ass_stmnt -> ID arr ASS func_stmnt SEMICLN .)
    WRITE           reduce using rule 36 (ass_stmnt -> ID arr ASS func_stmnt SEMICLN .)
    READ            reduce using rule 36 (ass_stmnt -> ID arr ASS func_stmnt SEMICLN .)
    RETURN          reduce using rule 36 (ass_stmnt -> ID arr ASS func_stmnt SEMICLN .)
    ID              reduce using rule 36 (ass_stmnt -> ID arr ASS func_stmnt SEMICLN .)
    $end            reduce using rule 36 (ass_stmnt -> ID arr ASS func_stmnt SEMICLN .)
    END             reduce using rule 36 (ass_stmnt -> ID arr ASS func_stmnt SEMICLN .)
    RCURLY          reduce using rule 36 (ass_stmnt -> ID arr ASS func_stmnt SEMICLN .)


state 151

    (37) ass_stmnt -> ID arr ASS logic SEMICLN .
    WHILE           reduce using rule 37 (ass_stmnt -> ID arr ASS logic SEMICLN .)
    IF              reduce using rule 37 (ass_stmnt -> ID arr ASS logic SEMICLN .)
    WRITE           reduce using rule 37 (ass_stmnt -> ID arr ASS logic SEMICLN .)
    READ            reduce using rule 37 (ass_stmnt -> ID arr ASS logic SEMICLN .)
    RETURN          reduce using rule 37 (ass_stmnt -> ID arr ASS logic SEMICLN .)
    ID              reduce using rule 37 (ass_stmnt -> ID arr ASS logic SEMICLN .)
    $end            reduce using rule 37 (ass_stmnt -> ID arr ASS logic SEMICLN .)
    END             reduce using rule 37 (ass_stmnt -> ID arr ASS logic SEMICLN .)
    RCURLY          reduce using rule 37 (ass_stmnt -> ID arr ASS logic SEMICLN .)


state 152

    (44) read_stmnt -> READ LPAREN ID multid RPAREN . SEMICLN
    SEMICLN         shift and go to state 170


state 153

    (43) ret_stmnt -> RETURN LPAREN logic RPAREN SEMICLN .
    WHILE           reduce using rule 43 (ret_stmnt -> RETURN LPAREN logic RPAREN SEMICLN .)
    IF              reduce using rule 43 (ret_stmnt -> RETURN LPAREN logic RPAREN SEMICLN .)
    WRITE           reduce using rule 43 (ret_stmnt -> RETURN LPAREN logic RPAREN SEMICLN .)
    READ            reduce using rule 43 (ret_stmnt -> RETURN LPAREN logic RPAREN SEMICLN .)
    RETURN          reduce using rule 43 (ret_stmnt -> RETURN LPAREN logic RPAREN SEMICLN .)
    ID              reduce using rule 43 (ret_stmnt -> RETURN LPAREN logic RPAREN SEMICLN .)
    $end            reduce using rule 43 (ret_stmnt -> RETURN LPAREN logic RPAREN SEMICLN .)
    END             reduce using rule 43 (ret_stmnt -> RETURN LPAREN logic RPAREN SEMICLN .)
    RCURLY          reduce using rule 43 (ret_stmnt -> RETURN LPAREN logic RPAREN SEMICLN .)


state 154

    (20) funcdecl -> FUNC tipofunc ID LPAREN param RPAREN varsdecl LCURLY stmnt . RCURLY
    RCURLY          shift and go to state 171


state 155

    (26) multiparam -> COMMA param .
    RPAREN          reduce using rule 26 (multiparam -> COMMA param .)


state 156

    (8) multivd -> tipo prog4 COLON ID prog5 arr multid SEMICLN . multivd
    (7) multivd -> . empty
    (8) multivd -> . tipo prog4 COLON ID prog5 arr multid SEMICLN multivd
    (85) empty -> .
    (13) tipo -> . BOOL
    (14) tipo -> . CHAR
    (15) tipo -> . FLOAT
    (16) tipo -> . INT
    COMMA           reduce using rule 85 (empty -> .)
    FUNC            reduce using rule 85 (empty -> .)
    MAIN            reduce using rule 85 (empty -> .)
    LCURLY          reduce using rule 85 (empty -> .)
    BOOL            shift and go to state 19
    CHAR            shift and go to state 20
    FLOAT           shift and go to state 21
    INT             shift and go to state 22

    tipo                           shift and go to state 25
    multivd                        shift and go to state 172
    empty                          shift and go to state 24

state 157

    (84) while_stmnt -> WHILE LPAREN logic RPAREN stmnt END .
    WHILE           reduce using rule 84 (while_stmnt -> WHILE LPAREN logic RPAREN stmnt END .)
    IF              reduce using rule 84 (while_stmnt -> WHILE LPAREN logic RPAREN stmnt END .)
    WRITE           reduce using rule 84 (while_stmnt -> WHILE LPAREN logic RPAREN stmnt END .)
    READ            reduce using rule 84 (while_stmnt -> WHILE LPAREN logic RPAREN stmnt END .)
    RETURN          reduce using rule 84 (while_stmnt -> WHILE LPAREN logic RPAREN stmnt END .)
    ID              reduce using rule 84 (while_stmnt -> WHILE LPAREN logic RPAREN stmnt END .)
    $end            reduce using rule 84 (while_stmnt -> WHILE LPAREN logic RPAREN stmnt END .)
    END             reduce using rule 84 (while_stmnt -> WHILE LPAREN logic RPAREN stmnt END .)
    RCURLY          reduce using rule 84 (while_stmnt -> WHILE LPAREN logic RPAREN stmnt END .)


state 158

    (46) logic -> rel log2 OR log1 . logic
    (46) logic -> . rel log2 OR log1 logic
    (47) logic -> . rel log2 AND log1 logic
    (48) logic -> . rel log2
    (57) rel -> . exp rel2 relop rel1 rel
    (58) rel -> . exp rel2
    (61) exp -> . term exp2 SUB exp1 exp
    (62) exp -> . term exp2 SUM exp1 exp
    (63) exp -> . term exp2
    (66) term -> . factor term2 DIV term1 term
    (67) term -> . factor term2 MULT term1 term
    (68) term -> . factor term2
    (71) factor -> . FALSE fact1
    (72) factor -> . TRUE fact1
    (73) factor -> . CTE_STR fact1
    (74) factor -> . CTE_FLT fact1
    (75) factor -> . CTE_NUM fact1
    (76) factor -> . ID fact1 LPAREN logic multiexp RPAREN
    (77) factor -> . ID fact1 arr
    FALSE           shift and go to state 81
    TRUE            shift and go to state 82
    CTE_STR         shift and go to state 83
    CTE_FLT         shift and go to state 84
    CTE_NUM         shift and go to state 85
    ID              shift and go to state 86

    rel                            shift and go to state 77
    logic                          shift and go to state 173
    exp                            shift and go to state 78
    term                           shift and go to state 79
    factor                         shift and go to state 80

state 159

    (47) logic -> rel log2 AND log1 . logic
    (46) logic -> . rel log2 OR log1 logic
    (47) logic -> . rel log2 AND log1 logic
    (48) logic -> . rel log2
    (57) rel -> . exp rel2 relop rel1 rel
    (58) rel -> . exp rel2
    (61) exp -> . term exp2 SUB exp1 exp
    (62) exp -> . term exp2 SUM exp1 exp
    (63) exp -> . term exp2
    (66) term -> . factor term2 DIV term1 term
    (67) term -> . factor term2 MULT term1 term
    (68) term -> . factor term2
    (71) factor -> . FALSE fact1
    (72) factor -> . TRUE fact1
    (73) factor -> . CTE_STR fact1
    (74) factor -> . CTE_FLT fact1
    (75) factor -> . CTE_NUM fact1
    (76) factor -> . ID fact1 LPAREN logic multiexp RPAREN
    (77) factor -> . ID fact1 arr
    FALSE           shift and go to state 81
    TRUE            shift and go to state 82
    CTE_STR         shift and go to state 83
    CTE_FLT         shift and go to state 84
    CTE_NUM         shift and go to state 85
    ID              shift and go to state 86

    rel                            shift and go to state 77
    logic                          shift and go to state 174
    exp                            shift and go to state 78
    term                           shift and go to state 79
    factor                         shift and go to state 80

state 160

    (57) rel -> exp rel2 relop rel1 . rel
    (57) rel -> . exp rel2 relop rel1 rel
    (58) rel -> . exp rel2
    (61) exp -> . term exp2 SUB exp1 exp
    (62) exp -> . term exp2 SUM exp1 exp
    (63) exp -> . term exp2
    (66) term -> . factor term2 DIV term1 term
    (67) term -> . factor term2 MULT term1 term
    (68) term -> . factor term2
    (71) factor -> . FALSE fact1
    (72) factor -> . TRUE fact1
    (73) factor -> . CTE_STR fact1
    (74) factor -> . CTE_FLT fact1
    (75) factor -> . CTE_NUM fact1
    (76) factor -> . ID fact1 LPAREN logic multiexp RPAREN
    (77) factor -> . ID fact1 arr
    FALSE           shift and go to state 81
    TRUE            shift and go to state 82
    CTE_STR         shift and go to state 83
    CTE_FLT         shift and go to state 84
    CTE_NUM         shift and go to state 85
    ID              shift and go to state 86

    exp                            shift and go to state 78
    rel                            shift and go to state 175
    term                           shift and go to state 79
    factor                         shift and go to state 80

state 161

    (61) exp -> term exp2 SUB exp1 . exp
    (61) exp -> . term exp2 SUB exp1 exp
    (62) exp -> . term exp2 SUM exp1 exp
    (63) exp -> . term exp2
    (66) term -> . factor term2 DIV term1 term
    (67) term -> . factor term2 MULT term1 term
    (68) term -> . factor term2
    (71) factor -> . FALSE fact1
    (72) factor -> . TRUE fact1
    (73) factor -> . CTE_STR fact1
    (74) factor -> . CTE_FLT fact1
    (75) factor -> . CTE_NUM fact1
    (76) factor -> . ID fact1 LPAREN logic multiexp RPAREN
    (77) factor -> . ID fact1 arr
    FALSE           shift and go to state 81
    TRUE            shift and go to state 82
    CTE_STR         shift and go to state 83
    CTE_FLT         shift and go to state 84
    CTE_NUM         shift and go to state 85
    ID              shift and go to state 86

    term                           shift and go to state 79
    exp                            shift and go to state 176
    factor                         shift and go to state 80

state 162

    (62) exp -> term exp2 SUM exp1 . exp
    (61) exp -> . term exp2 SUB exp1 exp
    (62) exp -> . term exp2 SUM exp1 exp
    (63) exp -> . term exp2
    (66) term -> . factor term2 DIV term1 term
    (67) term -> . factor term2 MULT term1 term
    (68) term -> . factor term2
    (71) factor -> . FALSE fact1
    (72) factor -> . TRUE fact1
    (73) factor -> . CTE_STR fact1
    (74) factor -> . CTE_FLT fact1
    (75) factor -> . CTE_NUM fact1
    (76) factor -> . ID fact1 LPAREN logic multiexp RPAREN
    (77) factor -> . ID fact1 arr
    FALSE           shift and go to state 81
    TRUE            shift and go to state 82
    CTE_STR         shift and go to state 83
    CTE_FLT         shift and go to state 84
    CTE_NUM         shift and go to state 85
    ID              shift and go to state 86

    term                           shift and go to state 79
    exp                            shift and go to state 177
    factor                         shift and go to state 80

state 163

    (66) term -> factor term2 DIV term1 . term
    (66) term -> . factor term2 DIV term1 term
    (67) term -> . factor term2 MULT term1 term
    (68) term -> . factor term2
    (71) factor -> . FALSE fact1
    (72) factor -> . TRUE fact1
    (73) factor -> . CTE_STR fact1
    (74) factor -> . CTE_FLT fact1
    (75) factor -> . CTE_NUM fact1
    (76) factor -> . ID fact1 LPAREN logic multiexp RPAREN
    (77) factor -> . ID fact1 arr
    FALSE           shift and go to state 81
    TRUE            shift and go to state 82
    CTE_STR         shift and go to state 83
    CTE_FLT         shift and go to state 84
    CTE_NUM         shift and go to state 85
    ID              shift and go to state 86

    factor                         shift and go to state 80
    term                           shift and go to state 178

state 164

    (67) term -> factor term2 MULT term1 . term
    (66) term -> . factor term2 DIV term1 term
    (67) term -> . factor term2 MULT term1 term
    (68) term -> . factor term2
    (71) factor -> . FALSE fact1
    (72) factor -> . TRUE fact1
    (73) factor -> . CTE_STR fact1
    (74) factor -> . CTE_FLT fact1
    (75) factor -> . CTE_NUM fact1
    (76) factor -> . ID fact1 LPAREN logic multiexp RPAREN
    (77) factor -> . ID fact1 arr
    FALSE           shift and go to state 81
    TRUE            shift and go to state 82
    CTE_STR         shift and go to state 83
    CTE_FLT         shift and go to state 84
    CTE_NUM         shift and go to state 85
    ID              shift and go to state 86

    factor                         shift and go to state 80
    term                           shift and go to state 179

state 165

    (76) factor -> ID fact1 LPAREN logic . multiexp RPAREN
    (79) multiexp -> . empty
    (80) multiexp -> . COMMA logic multiexp
    (85) empty -> .
    COMMA           shift and go to state 182
    RPAREN          reduce using rule 85 (empty -> .)

    multiexp                       shift and go to state 180
    empty                          shift and go to state 181

state 166

    (81) if_stmnt -> IF LPAREN logic RPAREN else_stmnt END .
    WHILE           reduce using rule 81 (if_stmnt -> IF LPAREN logic RPAREN else_stmnt END .)
    IF              reduce using rule 81 (if_stmnt -> IF LPAREN logic RPAREN else_stmnt END .)
    WRITE           reduce using rule 81 (if_stmnt -> IF LPAREN logic RPAREN else_stmnt END .)
    READ            reduce using rule 81 (if_stmnt -> IF LPAREN logic RPAREN else_stmnt END .)
    RETURN          reduce using rule 81 (if_stmnt -> IF LPAREN logic RPAREN else_stmnt END .)
    ID              reduce using rule 81 (if_stmnt -> IF LPAREN logic RPAREN else_stmnt END .)
    $end            reduce using rule 81 (if_stmnt -> IF LPAREN logic RPAREN else_stmnt END .)
    END             reduce using rule 81 (if_stmnt -> IF LPAREN logic RPAREN else_stmnt END .)
    RCURLY          reduce using rule 81 (if_stmnt -> IF LPAREN logic RPAREN else_stmnt END .)


state 167

    (83) else_stmnt -> ELSE stmnt .
    END             reduce using rule 83 (else_stmnt -> ELSE stmnt .)


state 168

    (45) write_stmnt -> WRITE LPAREN ID multid RPAREN SEMICLN .
    WHILE           reduce using rule 45 (write_stmnt -> WRITE LPAREN ID multid RPAREN SEMICLN .)
    IF              reduce using rule 45 (write_stmnt -> WRITE LPAREN ID multid RPAREN SEMICLN .)
    WRITE           reduce using rule 45 (write_stmnt -> WRITE LPAREN ID multid RPAREN SEMICLN .)
    READ            reduce using rule 45 (write_stmnt -> WRITE LPAREN ID multid RPAREN SEMICLN .)
    RETURN          reduce using rule 45 (write_stmnt -> WRITE LPAREN ID multid RPAREN SEMICLN .)
    ID              reduce using rule 45 (write_stmnt -> WRITE LPAREN ID multid RPAREN SEMICLN .)
    $end            reduce using rule 45 (write_stmnt -> WRITE LPAREN ID multid RPAREN SEMICLN .)
    END             reduce using rule 45 (write_stmnt -> WRITE LPAREN ID multid RPAREN SEMICLN .)
    RCURLY          reduce using rule 45 (write_stmnt -> WRITE LPAREN ID multid RPAREN SEMICLN .)


state 169

    (42) multiarg -> COMMA arg multiarg .
    COMMA           reduce using rule 42 (multiarg -> COMMA arg multiarg .)
    RPAREN          reduce using rule 42 (multiarg -> COMMA arg multiarg .)


state 170

    (44) read_stmnt -> READ LPAREN ID multid RPAREN SEMICLN .
    WHILE           reduce using rule 44 (read_stmnt -> READ LPAREN ID multid RPAREN SEMICLN .)
    IF              reduce using rule 44 (read_stmnt -> READ LPAREN ID multid RPAREN SEMICLN .)
    WRITE           reduce using rule 44 (read_stmnt -> READ LPAREN ID multid RPAREN SEMICLN .)
    READ            reduce using rule 44 (read_stmnt -> READ LPAREN ID multid RPAREN SEMICLN .)
    RETURN          reduce using rule 44 (read_stmnt -> READ LPAREN ID multid RPAREN SEMICLN .)
    ID              reduce using rule 44 (read_stmnt -> READ LPAREN ID multid RPAREN SEMICLN .)
    $end            reduce using rule 44 (read_stmnt -> READ LPAREN ID multid RPAREN SEMICLN .)
    END             reduce using rule 44 (read_stmnt -> READ LPAREN ID multid RPAREN SEMICLN .)
    RCURLY          reduce using rule 44 (read_stmnt -> READ LPAREN ID multid RPAREN SEMICLN .)


state 171

    (20) funcdecl -> FUNC tipofunc ID LPAREN param RPAREN varsdecl LCURLY stmnt RCURLY .
    MAIN            reduce using rule 20 (funcdecl -> FUNC tipofunc ID LPAREN param RPAREN varsdecl LCURLY stmnt RCURLY .)


state 172

    (8) multivd -> tipo prog4 COLON ID prog5 arr multid SEMICLN multivd .
    COMMA           reduce using rule 8 (multivd -> tipo prog4 COLON ID prog5 arr multid SEMICLN multivd .)
    FUNC            reduce using rule 8 (multivd -> tipo prog4 COLON ID prog5 arr multid SEMICLN multivd .)
    MAIN            reduce using rule 8 (multivd -> tipo prog4 COLON ID prog5 arr multid SEMICLN multivd .)
    LCURLY          reduce using rule 8 (multivd -> tipo prog4 COLON ID prog5 arr multid SEMICLN multivd .)


state 173

    (46) logic -> rel log2 OR log1 logic .
    RPAREN          reduce using rule 46 (logic -> rel log2 OR log1 logic .)
    COMMA           reduce using rule 46 (logic -> rel log2 OR log1 logic .)
    SEMICLN         reduce using rule 46 (logic -> rel log2 OR log1 logic .)


state 174

    (47) logic -> rel log2 AND log1 logic .
    RPAREN          reduce using rule 47 (logic -> rel log2 AND log1 logic .)
    COMMA           reduce using rule 47 (logic -> rel log2 AND log1 logic .)
    SEMICLN         reduce using rule 47 (logic -> rel log2 AND log1 logic .)


state 175

    (57) rel -> exp rel2 relop rel1 rel .
    OR              reduce using rule 57 (rel -> exp rel2 relop rel1 rel .)
    AND             reduce using rule 57 (rel -> exp rel2 relop rel1 rel .)
    RPAREN          reduce using rule 57 (rel -> exp rel2 relop rel1 rel .)
    COMMA           reduce using rule 57 (rel -> exp rel2 relop rel1 rel .)
    SEMICLN         reduce using rule 57 (rel -> exp rel2 relop rel1 rel .)


state 176

    (61) exp -> term exp2 SUB exp1 exp .
    EQUAL_TO        reduce using rule 61 (exp -> term exp2 SUB exp1 exp .)
    DIFFERENT_TO    reduce using rule 61 (exp -> term exp2 SUB exp1 exp .)
    LESS_OR_EQ_THAN reduce using rule 61 (exp -> term exp2 SUB exp1 exp .)
    MORE_OR_EQ_THAN reduce using rule 61 (exp -> term exp2 SUB exp1 exp .)
    LESS_THAN       reduce using rule 61 (exp -> term exp2 SUB exp1 exp .)
    MORE_THAN       reduce using rule 61 (exp -> term exp2 SUB exp1 exp .)
    OR              reduce using rule 61 (exp -> term exp2 SUB exp1 exp .)
    AND             reduce using rule 61 (exp -> term exp2 SUB exp1 exp .)
    RPAREN          reduce using rule 61 (exp -> term exp2 SUB exp1 exp .)
    COMMA           reduce using rule 61 (exp -> term exp2 SUB exp1 exp .)
    RSQUARE         reduce using rule 61 (exp -> term exp2 SUB exp1 exp .)
    SEMICLN         reduce using rule 61 (exp -> term exp2 SUB exp1 exp .)


state 177

    (62) exp -> term exp2 SUM exp1 exp .
    EQUAL_TO        reduce using rule 62 (exp -> term exp2 SUM exp1 exp .)
    DIFFERENT_TO    reduce using rule 62 (exp -> term exp2 SUM exp1 exp .)
    LESS_OR_EQ_THAN reduce using rule 62 (exp -> term exp2 SUM exp1 exp .)
    MORE_OR_EQ_THAN reduce using rule 62 (exp -> term exp2 SUM exp1 exp .)
    LESS_THAN       reduce using rule 62 (exp -> term exp2 SUM exp1 exp .)
    MORE_THAN       reduce using rule 62 (exp -> term exp2 SUM exp1 exp .)
    OR              reduce using rule 62 (exp -> term exp2 SUM exp1 exp .)
    AND             reduce using rule 62 (exp -> term exp2 SUM exp1 exp .)
    RPAREN          reduce using rule 62 (exp -> term exp2 SUM exp1 exp .)
    COMMA           reduce using rule 62 (exp -> term exp2 SUM exp1 exp .)
    RSQUARE         reduce using rule 62 (exp -> term exp2 SUM exp1 exp .)
    SEMICLN         reduce using rule 62 (exp -> term exp2 SUM exp1 exp .)


state 178

    (66) term -> factor term2 DIV term1 term .
    SUB             reduce using rule 66 (term -> factor term2 DIV term1 term .)
    SUM             reduce using rule 66 (term -> factor term2 DIV term1 term .)
    EQUAL_TO        reduce using rule 66 (term -> factor term2 DIV term1 term .)
    DIFFERENT_TO    reduce using rule 66 (term -> factor term2 DIV term1 term .)
    LESS_OR_EQ_THAN reduce using rule 66 (term -> factor term2 DIV term1 term .)
    MORE_OR_EQ_THAN reduce using rule 66 (term -> factor term2 DIV term1 term .)
    LESS_THAN       reduce using rule 66 (term -> factor term2 DIV term1 term .)
    MORE_THAN       reduce using rule 66 (term -> factor term2 DIV term1 term .)
    OR              reduce using rule 66 (term -> factor term2 DIV term1 term .)
    AND             reduce using rule 66 (term -> factor term2 DIV term1 term .)
    RPAREN          reduce using rule 66 (term -> factor term2 DIV term1 term .)
    COMMA           reduce using rule 66 (term -> factor term2 DIV term1 term .)
    RSQUARE         reduce using rule 66 (term -> factor term2 DIV term1 term .)
    SEMICLN         reduce using rule 66 (term -> factor term2 DIV term1 term .)


state 179

    (67) term -> factor term2 MULT term1 term .
    SUB             reduce using rule 67 (term -> factor term2 MULT term1 term .)
    SUM             reduce using rule 67 (term -> factor term2 MULT term1 term .)
    EQUAL_TO        reduce using rule 67 (term -> factor term2 MULT term1 term .)
    DIFFERENT_TO    reduce using rule 67 (term -> factor term2 MULT term1 term .)
    LESS_OR_EQ_THAN reduce using rule 67 (term -> factor term2 MULT term1 term .)
    MORE_OR_EQ_THAN reduce using rule 67 (term -> factor term2 MULT term1 term .)
    LESS_THAN       reduce using rule 67 (term -> factor term2 MULT term1 term .)
    MORE_THAN       reduce using rule 67 (term -> factor term2 MULT term1 term .)
    OR              reduce using rule 67 (term -> factor term2 MULT term1 term .)
    AND             reduce using rule 67 (term -> factor term2 MULT term1 term .)
    RPAREN          reduce using rule 67 (term -> factor term2 MULT term1 term .)
    COMMA           reduce using rule 67 (term -> factor term2 MULT term1 term .)
    RSQUARE         reduce using rule 67 (term -> factor term2 MULT term1 term .)
    SEMICLN         reduce using rule 67 (term -> factor term2 MULT term1 term .)


state 180

    (76) factor -> ID fact1 LPAREN logic multiexp . RPAREN
    RPAREN          shift and go to state 183


state 181

    (79) multiexp -> empty .
    RPAREN          reduce using rule 79 (multiexp -> empty .)


state 182

    (80) multiexp -> COMMA . logic multiexp
    (46) logic -> . rel log2 OR log1 logic
    (47) logic -> . rel log2 AND log1 logic
    (48) logic -> . rel log2
    (57) rel -> . exp rel2 relop rel1 rel
    (58) rel -> . exp rel2
    (61) exp -> . term exp2 SUB exp1 exp
    (62) exp -> . term exp2 SUM exp1 exp
    (63) exp -> . term exp2
    (66) term -> . factor term2 DIV term1 term
    (67) term -> . factor term2 MULT term1 term
    (68) term -> . factor term2
    (71) factor -> . FALSE fact1
    (72) factor -> . TRUE fact1
    (73) factor -> . CTE_STR fact1
    (74) factor -> . CTE_FLT fact1
    (75) factor -> . CTE_NUM fact1
    (76) factor -> . ID fact1 LPAREN logic multiexp RPAREN
    (77) factor -> . ID fact1 arr
    FALSE           shift and go to state 81
    TRUE            shift and go to state 82
    CTE_STR         shift and go to state 83
    CTE_FLT         shift and go to state 84
    CTE_NUM         shift and go to state 85
    ID              shift and go to state 86

    logic                          shift and go to state 184
    rel                            shift and go to state 77
    exp                            shift and go to state 78
    term                           shift and go to state 79
    factor                         shift and go to state 80

state 183

    (76) factor -> ID fact1 LPAREN logic multiexp RPAREN .
    DIV             reduce using rule 76 (factor -> ID fact1 LPAREN logic multiexp RPAREN .)
    MULT            reduce using rule 76 (factor -> ID fact1 LPAREN logic multiexp RPAREN .)
    SUB             reduce using rule 76 (factor -> ID fact1 LPAREN logic multiexp RPAREN .)
    SUM             reduce using rule 76 (factor -> ID fact1 LPAREN logic multiexp RPAREN .)
    EQUAL_TO        reduce using rule 76 (factor -> ID fact1 LPAREN logic multiexp RPAREN .)
    DIFFERENT_TO    reduce using rule 76 (factor -> ID fact1 LPAREN logic multiexp RPAREN .)
    LESS_OR_EQ_THAN reduce using rule 76 (factor -> ID fact1 LPAREN logic multiexp RPAREN .)
    MORE_OR_EQ_THAN reduce using rule 76 (factor -> ID fact1 LPAREN logic multiexp RPAREN .)
    LESS_THAN       reduce using rule 76 (factor -> ID fact1 LPAREN logic multiexp RPAREN .)
    MORE_THAN       reduce using rule 76 (factor -> ID fact1 LPAREN logic multiexp RPAREN .)
    OR              reduce using rule 76 (factor -> ID fact1 LPAREN logic multiexp RPAREN .)
    AND             reduce using rule 76 (factor -> ID fact1 LPAREN logic multiexp RPAREN .)
    RPAREN          reduce using rule 76 (factor -> ID fact1 LPAREN logic multiexp RPAREN .)
    COMMA           reduce using rule 76 (factor -> ID fact1 LPAREN logic multiexp RPAREN .)
    RSQUARE         reduce using rule 76 (factor -> ID fact1 LPAREN logic multiexp RPAREN .)
    SEMICLN         reduce using rule 76 (factor -> ID fact1 LPAREN logic multiexp RPAREN .)


state 184

    (80) multiexp -> COMMA logic . multiexp
    (79) multiexp -> . empty
    (80) multiexp -> . COMMA logic multiexp
    (85) empty -> .
    COMMA           shift and go to state 182
    RPAREN          reduce using rule 85 (empty -> .)

    multiexp                       shift and go to state 185
    empty                          shift and go to state 181

state 185

    (80) multiexp -> COMMA logic multiexp .
    RPAREN          reduce using rule 80 (multiexp -> COMMA logic multiexp .)


Conflicts:

shift/reduce conflict for COMMA in state 91 resolved as shift
shift/reduce conflict for LPAREN in state 117 resolved as shift
shift/reduce conflict for COMMA in state 149 resolved as shift