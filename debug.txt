Grammar:

Rule 0     S' -> program
Rule 1     program -> PROGRAM prog1 ID prog2 SEMICLN varsdecl funcdecl main
Rule 2     prog1 -> <empty>
Rule 3     prog2 -> <empty>
Rule 4     varsdecl -> empty
Rule 5     varsdecl -> VARS prog3 multivd multid
Rule 6     prog3 -> <empty>
Rule 7     multivd -> empty
Rule 8     multivd -> tipo prog4 COLON ID prog5 arr multid SEMICLN multivd
Rule 9     prog4 -> <empty>
Rule 10    prog5 -> <empty>
Rule 11    multid -> empty
Rule 12    multid -> COMMA ID prog5 arr multid
Rule 13    tipo -> BOOL
Rule 14    tipo -> CHAR
Rule 15    tipo -> FLOAT
Rule 16    tipo -> INT
Rule 17    arr -> empty
Rule 18    arr -> LSQUARE exp RSQUARE
Rule 19    funcdecl -> empty
Rule 20    funcdecl -> FUNC tipofunc ID LPAREN param RPAREN varsdecl LCURLY stmnt RCURLY
Rule 21    tipofunc -> tipo
Rule 22    tipofunc -> VOID
Rule 23    param -> empty
Rule 24    param -> tipo COLON ID multiparam
Rule 25    multiparam -> empty
Rule 26    multiparam -> COMMA param
Rule 27    main -> MAIN LPAREN RPAREN stmnt
Rule 28    stmnt -> empty
Rule 29    stmnt -> while_stmnt stmnt
Rule 30    stmnt -> if_stmnt stmnt
Rule 31    stmnt -> write_stmnt stmnt
Rule 32    stmnt -> read_stmnt stmnt
Rule 33    stmnt -> ret_stmnt stmnt
Rule 34    stmnt -> func_stmnt stmnt
Rule 35    stmnt -> ass_stmnt stmnt
Rule 36    ass_stmnt -> ID arr ASS func_stmnt SEMICLN
Rule 37    ass_stmnt -> ID ass1 arr ASS logic SEMICLN
Rule 38    ass1 -> <empty>
Rule 39    func_stmnt -> ID LPAREN arg RPAREN SEMICLN
Rule 40    arg -> empty
Rule 41    arg -> logic multiarg
Rule 42    multiarg -> empty
Rule 43    multiarg -> COMMA arg multiarg
Rule 44    ret_stmnt -> RETURN LPAREN logic RPAREN SEMICLN
Rule 45    read_stmnt -> READ linear1 LPAREN logic linear2 RPAREN linear3 SEMICLN
Rule 46    write_stmnt -> WRITE linear1 LPAREN logic linear2 RPAREN linear3 SEMICLN
Rule 47    linear1 -> <empty>
Rule 48    linear2 -> <empty>
Rule 49    linear3 -> <empty>
Rule 50    logic -> rel log2 OR log1 logic
Rule 51    logic -> rel log2 AND log1 logic
Rule 52    logic -> rel log2
Rule 53    log1 -> <empty>
Rule 54    log2 -> <empty>
Rule 55    relop -> EQUAL_TO
Rule 56    relop -> DIFFERENT_TO
Rule 57    relop -> LESS_OR_EQ_THAN
Rule 58    relop -> MORE_OR_EQ_THAN
Rule 59    relop -> LESS_THAN
Rule 60    relop -> MORE_THAN
Rule 61    rel -> exp rel2 relop rel1 rel
Rule 62    rel -> exp rel2
Rule 63    rel1 -> <empty>
Rule 64    rel2 -> <empty>
Rule 65    exp -> term exp2 SUB exp1 exp
Rule 66    exp -> term exp2 SUM exp1 exp
Rule 67    exp -> term exp2
Rule 68    exp2 -> <empty>
Rule 69    exp1 -> <empty>
Rule 70    term -> factor term2 DIV term1 term
Rule 71    term -> factor term2 MULT term1 term
Rule 72    term -> factor term2
Rule 73    term1 -> <empty>
Rule 74    term2 -> <empty>
Rule 75    factor -> FALSE ctes4
Rule 76    factor -> TRUE ctes4
Rule 77    factor -> CTE_STR ctes3
Rule 78    factor -> CTE_FLT ctes2
Rule 79    factor -> CTE_NUM ctes1
Rule 80    factor -> ID fact1 LPAREN logic multiexp RPAREN
Rule 81    factor -> ID fact1 arr
Rule 82    ctes1 -> <empty>
Rule 83    ctes2 -> <empty>
Rule 84    ctes3 -> <empty>
Rule 85    ctes4 -> <empty>
Rule 86    fact1 -> <empty>
Rule 87    multiexp -> empty
Rule 88    multiexp -> COMMA logic multiexp
Rule 89    if_stmnt -> IF LPAREN logic RPAREN else_stmnt END
Rule 90    else_stmnt -> empty
Rule 91    else_stmnt -> ELSE stmnt
Rule 92    while_stmnt -> WHILE LPAREN logic RPAREN stmnt END
Rule 93    empty -> <empty>

Terminals, with rules where they appear:

AND                  : 51
ASS                  : 36 37
BOOL                 : 13
CHAR                 : 14
COLON                : 8 24
COMMA                : 12 26 43 88
CTE_FLT              : 78
CTE_NUM              : 79
CTE_STR              : 77
DIFFERENT_TO         : 56
DIV                  : 70
ELSE                 : 91
END                  : 89 92
EQUAL_TO             : 55
FALSE                : 75
FLOAT                : 15
FUNC                 : 20
ID                   : 1 8 12 20 24 36 37 39 80 81
IF                   : 89
INT                  : 16
LCURLY               : 20
LESS_OR_EQ_THAN      : 57
LESS_THAN            : 59
LPAREN               : 20 27 39 44 45 46 80 89 92
LSQUARE              : 18
MAIN                 : 27
MORE_OR_EQ_THAN      : 58
MORE_THAN            : 60
MULT                 : 71
OR                   : 50
PROGRAM              : 1
RCURLY               : 20
READ                 : 45
RETURN               : 44
RPAREN               : 20 27 39 44 45 46 80 89 92
RSQUARE              : 18
SEMICLN              : 1 8 36 37 39 44 45 46
SUB                  : 65
SUM                  : 66
TRUE                 : 76
VARS                 : 5
VOID                 : 22
WHILE                : 92
WRITE                : 46
error                : 

Nonterminals, with rules where they appear:

arg                  : 39 43
arr                  : 8 12 36 37 81
ass1                 : 37
ass_stmnt            : 35
ctes1                : 79
ctes2                : 78
ctes3                : 77
ctes4                : 75 76
else_stmnt           : 89
empty                : 4 7 11 17 19 23 25 28 40 42 87 90
exp                  : 18 61 62 65 66
exp1                 : 65 66
exp2                 : 65 66 67
fact1                : 80 81
factor               : 70 71 72
func_stmnt           : 34 36
funcdecl             : 1
if_stmnt             : 30
linear1              : 45 46
linear2              : 45 46
linear3              : 45 46
log1                 : 50 51
log2                 : 50 51 52
logic                : 37 41 44 45 46 50 51 80 88 89 92
main                 : 1
multiarg             : 41 43
multid               : 5 8 12
multiexp             : 80 88
multiparam           : 24
multivd              : 5 8
param                : 20 26
prog1                : 1
prog2                : 1
prog3                : 5
prog4                : 8
prog5                : 8 12
program              : 0
read_stmnt           : 32
rel                  : 50 51 52 61
rel1                 : 61
rel2                 : 61 62
relop                : 61
ret_stmnt            : 33
stmnt                : 20 27 29 30 31 32 33 34 35 91 92
term                 : 65 66 67 70 71
term1                : 70 71
term2                : 70 71 72
tipo                 : 8 21 24
tipofunc             : 20
varsdecl             : 1 20
while_stmnt          : 29
write_stmnt          : 31


state 0

    (0) S' -> . program
    (1) program -> . PROGRAM prog1 ID prog2 SEMICLN varsdecl funcdecl main
    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .


state 2

    (1) program -> PROGRAM . prog1 ID prog2 SEMICLN varsdecl funcdecl main
    (2) prog1 -> .
    ID              reduce using rule 2 (prog1 -> .)

    prog1                          shift and go to state 3

state 3

    (1) program -> PROGRAM prog1 . ID prog2 SEMICLN varsdecl funcdecl main
    ID              shift and go to state 4


state 4

    (1) program -> PROGRAM prog1 ID . prog2 SEMICLN varsdecl funcdecl main
    (3) prog2 -> .
    SEMICLN         reduce using rule 3 (prog2 -> .)

    prog2                          shift and go to state 5

state 5

    (1) program -> PROGRAM prog1 ID prog2 . SEMICLN varsdecl funcdecl main
    SEMICLN         shift and go to state 6


state 6

    (1) program -> PROGRAM prog1 ID prog2 SEMICLN . varsdecl funcdecl main
    (4) varsdecl -> . empty
    (5) varsdecl -> . VARS prog3 multivd multid
    (93) empty -> .
    VARS            shift and go to state 9
    FUNC            reduce using rule 93 (empty -> .)
    MAIN            reduce using rule 93 (empty -> .)

    varsdecl                       shift and go to state 7
    empty                          shift and go to state 8

state 7

    (1) program -> PROGRAM prog1 ID prog2 SEMICLN varsdecl . funcdecl main
    (19) funcdecl -> . empty
    (20) funcdecl -> . FUNC tipofunc ID LPAREN param RPAREN varsdecl LCURLY stmnt RCURLY
    (93) empty -> .
    FUNC            shift and go to state 12
    MAIN            reduce using rule 93 (empty -> .)

    funcdecl                       shift and go to state 10
    empty                          shift and go to state 11

state 8

    (4) varsdecl -> empty .
    FUNC            reduce using rule 4 (varsdecl -> empty .)
    MAIN            reduce using rule 4 (varsdecl -> empty .)
    LCURLY          reduce using rule 4 (varsdecl -> empty .)


state 9

    (5) varsdecl -> VARS . prog3 multivd multid
    (6) prog3 -> .
    BOOL            reduce using rule 6 (prog3 -> .)
    CHAR            reduce using rule 6 (prog3 -> .)
    FLOAT           reduce using rule 6 (prog3 -> .)
    INT             reduce using rule 6 (prog3 -> .)
    COMMA           reduce using rule 6 (prog3 -> .)
    FUNC            reduce using rule 6 (prog3 -> .)
    MAIN            reduce using rule 6 (prog3 -> .)
    LCURLY          reduce using rule 6 (prog3 -> .)

    prog3                          shift and go to state 13

state 10

    (1) program -> PROGRAM prog1 ID prog2 SEMICLN varsdecl funcdecl . main
    (27) main -> . MAIN LPAREN RPAREN stmnt
    MAIN            shift and go to state 15

    main                           shift and go to state 14

state 11

    (19) funcdecl -> empty .
    MAIN            reduce using rule 19 (funcdecl -> empty .)


state 12

    (20) funcdecl -> FUNC . tipofunc ID LPAREN param RPAREN varsdecl LCURLY stmnt RCURLY
    (21) tipofunc -> . tipo
    (22) tipofunc -> . VOID
    (13) tipo -> . BOOL
    (14) tipo -> . CHAR
    (15) tipo -> . FLOAT
    (16) tipo -> . INT
    VOID            shift and go to state 18
    BOOL            shift and go to state 19
    CHAR            shift and go to state 20
    FLOAT           shift and go to state 21
    INT             shift and go to state 22

    tipofunc                       shift and go to state 16
    tipo                           shift and go to state 17

state 13

    (5) varsdecl -> VARS prog3 . multivd multid
    (7) multivd -> . empty
    (8) multivd -> . tipo prog4 COLON ID prog5 arr multid SEMICLN multivd
    (93) empty -> .
    (13) tipo -> . BOOL
    (14) tipo -> . CHAR
    (15) tipo -> . FLOAT
    (16) tipo -> . INT
    COMMA           reduce using rule 93 (empty -> .)
    FUNC            reduce using rule 93 (empty -> .)
    MAIN            reduce using rule 93 (empty -> .)
    LCURLY          reduce using rule 93 (empty -> .)
    BOOL            shift and go to state 19
    CHAR            shift and go to state 20
    FLOAT           shift and go to state 21
    INT             shift and go to state 22

    multivd                        shift and go to state 23
    empty                          shift and go to state 24
    tipo                           shift and go to state 25

state 14

    (1) program -> PROGRAM prog1 ID prog2 SEMICLN varsdecl funcdecl main .
    $end            reduce using rule 1 (program -> PROGRAM prog1 ID prog2 SEMICLN varsdecl funcdecl main .)


state 15

    (27) main -> MAIN . LPAREN RPAREN stmnt
    LPAREN          shift and go to state 26


state 16

    (20) funcdecl -> FUNC tipofunc . ID LPAREN param RPAREN varsdecl LCURLY stmnt RCURLY
    ID              shift and go to state 27


state 17

    (21) tipofunc -> tipo .
    ID              reduce using rule 21 (tipofunc -> tipo .)


state 18

    (22) tipofunc -> VOID .
    ID              reduce using rule 22 (tipofunc -> VOID .)


state 19

    (13) tipo -> BOOL .
    ID              reduce using rule 13 (tipo -> BOOL .)
    COLON           reduce using rule 13 (tipo -> BOOL .)


state 20

    (14) tipo -> CHAR .
    ID              reduce using rule 14 (tipo -> CHAR .)
    COLON           reduce using rule 14 (tipo -> CHAR .)


state 21

    (15) tipo -> FLOAT .
    ID              reduce using rule 15 (tipo -> FLOAT .)
    COLON           reduce using rule 15 (tipo -> FLOAT .)


state 22

    (16) tipo -> INT .
    ID              reduce using rule 16 (tipo -> INT .)
    COLON           reduce using rule 16 (tipo -> INT .)


state 23

    (5) varsdecl -> VARS prog3 multivd . multid
    (11) multid -> . empty
    (12) multid -> . COMMA ID prog5 arr multid
    (93) empty -> .
    COMMA           shift and go to state 30
    FUNC            reduce using rule 93 (empty -> .)
    MAIN            reduce using rule 93 (empty -> .)
    LCURLY          reduce using rule 93 (empty -> .)

    multid                         shift and go to state 28
    empty                          shift and go to state 29

state 24

    (7) multivd -> empty .
    COMMA           reduce using rule 7 (multivd -> empty .)
    FUNC            reduce using rule 7 (multivd -> empty .)
    MAIN            reduce using rule 7 (multivd -> empty .)
    LCURLY          reduce using rule 7 (multivd -> empty .)


state 25

    (8) multivd -> tipo . prog4 COLON ID prog5 arr multid SEMICLN multivd
    (9) prog4 -> .
    COLON           reduce using rule 9 (prog4 -> .)

    prog4                          shift and go to state 31

state 26

    (27) main -> MAIN LPAREN . RPAREN stmnt
    RPAREN          shift and go to state 32


state 27

    (20) funcdecl -> FUNC tipofunc ID . LPAREN param RPAREN varsdecl LCURLY stmnt RCURLY
    LPAREN          shift and go to state 33


state 28

    (5) varsdecl -> VARS prog3 multivd multid .
    FUNC            reduce using rule 5 (varsdecl -> VARS prog3 multivd multid .)
    MAIN            reduce using rule 5 (varsdecl -> VARS prog3 multivd multid .)
    LCURLY          reduce using rule 5 (varsdecl -> VARS prog3 multivd multid .)


state 29

    (11) multid -> empty .
    FUNC            reduce using rule 11 (multid -> empty .)
    MAIN            reduce using rule 11 (multid -> empty .)
    LCURLY          reduce using rule 11 (multid -> empty .)
    SEMICLN         reduce using rule 11 (multid -> empty .)


state 30

    (12) multid -> COMMA . ID prog5 arr multid
    ID              shift and go to state 34


state 31

    (8) multivd -> tipo prog4 . COLON ID prog5 arr multid SEMICLN multivd
    COLON           shift and go to state 35


state 32

    (27) main -> MAIN LPAREN RPAREN . stmnt
    (28) stmnt -> . empty
    (29) stmnt -> . while_stmnt stmnt
    (30) stmnt -> . if_stmnt stmnt
    (31) stmnt -> . write_stmnt stmnt
    (32) stmnt -> . read_stmnt stmnt
    (33) stmnt -> . ret_stmnt stmnt
    (34) stmnt -> . func_stmnt stmnt
    (35) stmnt -> . ass_stmnt stmnt
    (93) empty -> .
    (92) while_stmnt -> . WHILE LPAREN logic RPAREN stmnt END
    (89) if_stmnt -> . IF LPAREN logic RPAREN else_stmnt END
    (46) write_stmnt -> . WRITE linear1 LPAREN logic linear2 RPAREN linear3 SEMICLN
    (45) read_stmnt -> . READ linear1 LPAREN logic linear2 RPAREN linear3 SEMICLN
    (44) ret_stmnt -> . RETURN LPAREN logic RPAREN SEMICLN
    (39) func_stmnt -> . ID LPAREN arg RPAREN SEMICLN
    (36) ass_stmnt -> . ID arr ASS func_stmnt SEMICLN
    (37) ass_stmnt -> . ID ass1 arr ASS logic SEMICLN
    $end            reduce using rule 93 (empty -> .)
    WHILE           shift and go to state 45
    IF              shift and go to state 46
    WRITE           shift and go to state 47
    READ            shift and go to state 48
    RETURN          shift and go to state 49
    ID              shift and go to state 50

    stmnt                          shift and go to state 36
    empty                          shift and go to state 37
    while_stmnt                    shift and go to state 38
    if_stmnt                       shift and go to state 39
    write_stmnt                    shift and go to state 40
    read_stmnt                     shift and go to state 41
    ret_stmnt                      shift and go to state 42
    func_stmnt                     shift and go to state 43
    ass_stmnt                      shift and go to state 44

state 33

    (20) funcdecl -> FUNC tipofunc ID LPAREN . param RPAREN varsdecl LCURLY stmnt RCURLY
    (23) param -> . empty
    (24) param -> . tipo COLON ID multiparam
    (93) empty -> .
    (13) tipo -> . BOOL
    (14) tipo -> . CHAR
    (15) tipo -> . FLOAT
    (16) tipo -> . INT
    RPAREN          reduce using rule 93 (empty -> .)
    BOOL            shift and go to state 19
    CHAR            shift and go to state 20
    FLOAT           shift and go to state 21
    INT             shift and go to state 22

    param                          shift and go to state 51
    empty                          shift and go to state 52
    tipo                           shift and go to state 53

state 34

    (12) multid -> COMMA ID . prog5 arr multid
    (10) prog5 -> .
    LSQUARE         reduce using rule 10 (prog5 -> .)
    COMMA           reduce using rule 10 (prog5 -> .)
    FUNC            reduce using rule 10 (prog5 -> .)
    MAIN            reduce using rule 10 (prog5 -> .)
    LCURLY          reduce using rule 10 (prog5 -> .)
    SEMICLN         reduce using rule 10 (prog5 -> .)

    prog5                          shift and go to state 54

state 35

    (8) multivd -> tipo prog4 COLON . ID prog5 arr multid SEMICLN multivd
    ID              shift and go to state 55


state 36

    (27) main -> MAIN LPAREN RPAREN stmnt .
    $end            reduce using rule 27 (main -> MAIN LPAREN RPAREN stmnt .)


state 37

    (28) stmnt -> empty .
    $end            reduce using rule 28 (stmnt -> empty .)
    END             reduce using rule 28 (stmnt -> empty .)
    RCURLY          reduce using rule 28 (stmnt -> empty .)


state 38

    (29) stmnt -> while_stmnt . stmnt
    (28) stmnt -> . empty
    (29) stmnt -> . while_stmnt stmnt
    (30) stmnt -> . if_stmnt stmnt
    (31) stmnt -> . write_stmnt stmnt
    (32) stmnt -> . read_stmnt stmnt
    (33) stmnt -> . ret_stmnt stmnt
    (34) stmnt -> . func_stmnt stmnt
    (35) stmnt -> . ass_stmnt stmnt
    (93) empty -> .
    (92) while_stmnt -> . WHILE LPAREN logic RPAREN stmnt END
    (89) if_stmnt -> . IF LPAREN logic RPAREN else_stmnt END
    (46) write_stmnt -> . WRITE linear1 LPAREN logic linear2 RPAREN linear3 SEMICLN
    (45) read_stmnt -> . READ linear1 LPAREN logic linear2 RPAREN linear3 SEMICLN
    (44) ret_stmnt -> . RETURN LPAREN logic RPAREN SEMICLN
    (39) func_stmnt -> . ID LPAREN arg RPAREN SEMICLN
    (36) ass_stmnt -> . ID arr ASS func_stmnt SEMICLN
    (37) ass_stmnt -> . ID ass1 arr ASS logic SEMICLN
    $end            reduce using rule 93 (empty -> .)
    END             reduce using rule 93 (empty -> .)
    RCURLY          reduce using rule 93 (empty -> .)
    WHILE           shift and go to state 45
    IF              shift and go to state 46
    WRITE           shift and go to state 47
    READ            shift and go to state 48
    RETURN          shift and go to state 49
    ID              shift and go to state 50

    while_stmnt                    shift and go to state 38
    stmnt                          shift and go to state 56
    empty                          shift and go to state 37
    if_stmnt                       shift and go to state 39
    write_stmnt                    shift and go to state 40
    read_stmnt                     shift and go to state 41
    ret_stmnt                      shift and go to state 42
    func_stmnt                     shift and go to state 43
    ass_stmnt                      shift and go to state 44

state 39

    (30) stmnt -> if_stmnt . stmnt
    (28) stmnt -> . empty
    (29) stmnt -> . while_stmnt stmnt
    (30) stmnt -> . if_stmnt stmnt
    (31) stmnt -> . write_stmnt stmnt
    (32) stmnt -> . read_stmnt stmnt
    (33) stmnt -> . ret_stmnt stmnt
    (34) stmnt -> . func_stmnt stmnt
    (35) stmnt -> . ass_stmnt stmnt
    (93) empty -> .
    (92) while_stmnt -> . WHILE LPAREN logic RPAREN stmnt END
    (89) if_stmnt -> . IF LPAREN logic RPAREN else_stmnt END
    (46) write_stmnt -> . WRITE linear1 LPAREN logic linear2 RPAREN linear3 SEMICLN
    (45) read_stmnt -> . READ linear1 LPAREN logic linear2 RPAREN linear3 SEMICLN
    (44) ret_stmnt -> . RETURN LPAREN logic RPAREN SEMICLN
    (39) func_stmnt -> . ID LPAREN arg RPAREN SEMICLN
    (36) ass_stmnt -> . ID arr ASS func_stmnt SEMICLN
    (37) ass_stmnt -> . ID ass1 arr ASS logic SEMICLN
    $end            reduce using rule 93 (empty -> .)
    END             reduce using rule 93 (empty -> .)
    RCURLY          reduce using rule 93 (empty -> .)
    WHILE           shift and go to state 45
    IF              shift and go to state 46
    WRITE           shift and go to state 47
    READ            shift and go to state 48
    RETURN          shift and go to state 49
    ID              shift and go to state 50

    if_stmnt                       shift and go to state 39
    stmnt                          shift and go to state 57
    empty                          shift and go to state 37
    while_stmnt                    shift and go to state 38
    write_stmnt                    shift and go to state 40
    read_stmnt                     shift and go to state 41
    ret_stmnt                      shift and go to state 42
    func_stmnt                     shift and go to state 43
    ass_stmnt                      shift and go to state 44

state 40

    (31) stmnt -> write_stmnt . stmnt
    (28) stmnt -> . empty
    (29) stmnt -> . while_stmnt stmnt
    (30) stmnt -> . if_stmnt stmnt
    (31) stmnt -> . write_stmnt stmnt
    (32) stmnt -> . read_stmnt stmnt
    (33) stmnt -> . ret_stmnt stmnt
    (34) stmnt -> . func_stmnt stmnt
    (35) stmnt -> . ass_stmnt stmnt
    (93) empty -> .
    (92) while_stmnt -> . WHILE LPAREN logic RPAREN stmnt END
    (89) if_stmnt -> . IF LPAREN logic RPAREN else_stmnt END
    (46) write_stmnt -> . WRITE linear1 LPAREN logic linear2 RPAREN linear3 SEMICLN
    (45) read_stmnt -> . READ linear1 LPAREN logic linear2 RPAREN linear3 SEMICLN
    (44) ret_stmnt -> . RETURN LPAREN logic RPAREN SEMICLN
    (39) func_stmnt -> . ID LPAREN arg RPAREN SEMICLN
    (36) ass_stmnt -> . ID arr ASS func_stmnt SEMICLN
    (37) ass_stmnt -> . ID ass1 arr ASS logic SEMICLN
    $end            reduce using rule 93 (empty -> .)
    END             reduce using rule 93 (empty -> .)
    RCURLY          reduce using rule 93 (empty -> .)
    WHILE           shift and go to state 45
    IF              shift and go to state 46
    WRITE           shift and go to state 47
    READ            shift and go to state 48
    RETURN          shift and go to state 49
    ID              shift and go to state 50

    write_stmnt                    shift and go to state 40
    stmnt                          shift and go to state 58
    empty                          shift and go to state 37
    while_stmnt                    shift and go to state 38
    if_stmnt                       shift and go to state 39
    read_stmnt                     shift and go to state 41
    ret_stmnt                      shift and go to state 42
    func_stmnt                     shift and go to state 43
    ass_stmnt                      shift and go to state 44

state 41

    (32) stmnt -> read_stmnt . stmnt
    (28) stmnt -> . empty
    (29) stmnt -> . while_stmnt stmnt
    (30) stmnt -> . if_stmnt stmnt
    (31) stmnt -> . write_stmnt stmnt
    (32) stmnt -> . read_stmnt stmnt
    (33) stmnt -> . ret_stmnt stmnt
    (34) stmnt -> . func_stmnt stmnt
    (35) stmnt -> . ass_stmnt stmnt
    (93) empty -> .
    (92) while_stmnt -> . WHILE LPAREN logic RPAREN stmnt END
    (89) if_stmnt -> . IF LPAREN logic RPAREN else_stmnt END
    (46) write_stmnt -> . WRITE linear1 LPAREN logic linear2 RPAREN linear3 SEMICLN
    (45) read_stmnt -> . READ linear1 LPAREN logic linear2 RPAREN linear3 SEMICLN
    (44) ret_stmnt -> . RETURN LPAREN logic RPAREN SEMICLN
    (39) func_stmnt -> . ID LPAREN arg RPAREN SEMICLN
    (36) ass_stmnt -> . ID arr ASS func_stmnt SEMICLN
    (37) ass_stmnt -> . ID ass1 arr ASS logic SEMICLN
    $end            reduce using rule 93 (empty -> .)
    END             reduce using rule 93 (empty -> .)
    RCURLY          reduce using rule 93 (empty -> .)
    WHILE           shift and go to state 45
    IF              shift and go to state 46
    WRITE           shift and go to state 47
    READ            shift and go to state 48
    RETURN          shift and go to state 49
    ID              shift and go to state 50

    read_stmnt                     shift and go to state 41
    stmnt                          shift and go to state 59
    empty                          shift and go to state 37
    while_stmnt                    shift and go to state 38
    if_stmnt                       shift and go to state 39
    write_stmnt                    shift and go to state 40
    ret_stmnt                      shift and go to state 42
    func_stmnt                     shift and go to state 43
    ass_stmnt                      shift and go to state 44

state 42

    (33) stmnt -> ret_stmnt . stmnt
    (28) stmnt -> . empty
    (29) stmnt -> . while_stmnt stmnt
    (30) stmnt -> . if_stmnt stmnt
    (31) stmnt -> . write_stmnt stmnt
    (32) stmnt -> . read_stmnt stmnt
    (33) stmnt -> . ret_stmnt stmnt
    (34) stmnt -> . func_stmnt stmnt
    (35) stmnt -> . ass_stmnt stmnt
    (93) empty -> .
    (92) while_stmnt -> . WHILE LPAREN logic RPAREN stmnt END
    (89) if_stmnt -> . IF LPAREN logic RPAREN else_stmnt END
    (46) write_stmnt -> . WRITE linear1 LPAREN logic linear2 RPAREN linear3 SEMICLN
    (45) read_stmnt -> . READ linear1 LPAREN logic linear2 RPAREN linear3 SEMICLN
    (44) ret_stmnt -> . RETURN LPAREN logic RPAREN SEMICLN
    (39) func_stmnt -> . ID LPAREN arg RPAREN SEMICLN
    (36) ass_stmnt -> . ID arr ASS func_stmnt SEMICLN
    (37) ass_stmnt -> . ID ass1 arr ASS logic SEMICLN
    $end            reduce using rule 93 (empty -> .)
    END             reduce using rule 93 (empty -> .)
    RCURLY          reduce using rule 93 (empty -> .)
    WHILE           shift and go to state 45
    IF              shift and go to state 46
    WRITE           shift and go to state 47
    READ            shift and go to state 48
    RETURN          shift and go to state 49
    ID              shift and go to state 50

    ret_stmnt                      shift and go to state 42
    stmnt                          shift and go to state 60
    empty                          shift and go to state 37
    while_stmnt                    shift and go to state 38
    if_stmnt                       shift and go to state 39
    write_stmnt                    shift and go to state 40
    read_stmnt                     shift and go to state 41
    func_stmnt                     shift and go to state 43
    ass_stmnt                      shift and go to state 44

state 43

    (34) stmnt -> func_stmnt . stmnt
    (28) stmnt -> . empty
    (29) stmnt -> . while_stmnt stmnt
    (30) stmnt -> . if_stmnt stmnt
    (31) stmnt -> . write_stmnt stmnt
    (32) stmnt -> . read_stmnt stmnt
    (33) stmnt -> . ret_stmnt stmnt
    (34) stmnt -> . func_stmnt stmnt
    (35) stmnt -> . ass_stmnt stmnt
    (93) empty -> .
    (92) while_stmnt -> . WHILE LPAREN logic RPAREN stmnt END
    (89) if_stmnt -> . IF LPAREN logic RPAREN else_stmnt END
    (46) write_stmnt -> . WRITE linear1 LPAREN logic linear2 RPAREN linear3 SEMICLN
    (45) read_stmnt -> . READ linear1 LPAREN logic linear2 RPAREN linear3 SEMICLN
    (44) ret_stmnt -> . RETURN LPAREN logic RPAREN SEMICLN
    (39) func_stmnt -> . ID LPAREN arg RPAREN SEMICLN
    (36) ass_stmnt -> . ID arr ASS func_stmnt SEMICLN
    (37) ass_stmnt -> . ID ass1 arr ASS logic SEMICLN
    $end            reduce using rule 93 (empty -> .)
    END             reduce using rule 93 (empty -> .)
    RCURLY          reduce using rule 93 (empty -> .)
    WHILE           shift and go to state 45
    IF              shift and go to state 46
    WRITE           shift and go to state 47
    READ            shift and go to state 48
    RETURN          shift and go to state 49
    ID              shift and go to state 50

    func_stmnt                     shift and go to state 43
    stmnt                          shift and go to state 61
    empty                          shift and go to state 37
    while_stmnt                    shift and go to state 38
    if_stmnt                       shift and go to state 39
    write_stmnt                    shift and go to state 40
    read_stmnt                     shift and go to state 41
    ret_stmnt                      shift and go to state 42
    ass_stmnt                      shift and go to state 44

state 44

    (35) stmnt -> ass_stmnt . stmnt
    (28) stmnt -> . empty
    (29) stmnt -> . while_stmnt stmnt
    (30) stmnt -> . if_stmnt stmnt
    (31) stmnt -> . write_stmnt stmnt
    (32) stmnt -> . read_stmnt stmnt
    (33) stmnt -> . ret_stmnt stmnt
    (34) stmnt -> . func_stmnt stmnt
    (35) stmnt -> . ass_stmnt stmnt
    (93) empty -> .
    (92) while_stmnt -> . WHILE LPAREN logic RPAREN stmnt END
    (89) if_stmnt -> . IF LPAREN logic RPAREN else_stmnt END
    (46) write_stmnt -> . WRITE linear1 LPAREN logic linear2 RPAREN linear3 SEMICLN
    (45) read_stmnt -> . READ linear1 LPAREN logic linear2 RPAREN linear3 SEMICLN
    (44) ret_stmnt -> . RETURN LPAREN logic RPAREN SEMICLN
    (39) func_stmnt -> . ID LPAREN arg RPAREN SEMICLN
    (36) ass_stmnt -> . ID arr ASS func_stmnt SEMICLN
    (37) ass_stmnt -> . ID ass1 arr ASS logic SEMICLN
    $end            reduce using rule 93 (empty -> .)
    END             reduce using rule 93 (empty -> .)
    RCURLY          reduce using rule 93 (empty -> .)
    WHILE           shift and go to state 45
    IF              shift and go to state 46
    WRITE           shift and go to state 47
    READ            shift and go to state 48
    RETURN          shift and go to state 49
    ID              shift and go to state 50

    ass_stmnt                      shift and go to state 44
    stmnt                          shift and go to state 62
    empty                          shift and go to state 37
    while_stmnt                    shift and go to state 38
    if_stmnt                       shift and go to state 39
    write_stmnt                    shift and go to state 40
    read_stmnt                     shift and go to state 41
    ret_stmnt                      shift and go to state 42
    func_stmnt                     shift and go to state 43

state 45

    (92) while_stmnt -> WHILE . LPAREN logic RPAREN stmnt END
    LPAREN          shift and go to state 63


state 46

    (89) if_stmnt -> IF . LPAREN logic RPAREN else_stmnt END
    LPAREN          shift and go to state 64


state 47

    (46) write_stmnt -> WRITE . linear1 LPAREN logic linear2 RPAREN linear3 SEMICLN
    (47) linear1 -> .
    LPAREN          reduce using rule 47 (linear1 -> .)

    linear1                        shift and go to state 65

state 48

    (45) read_stmnt -> READ . linear1 LPAREN logic linear2 RPAREN linear3 SEMICLN
    (47) linear1 -> .
    LPAREN          reduce using rule 47 (linear1 -> .)

    linear1                        shift and go to state 66

state 49

    (44) ret_stmnt -> RETURN . LPAREN logic RPAREN SEMICLN
    LPAREN          shift and go to state 67


state 50

    (39) func_stmnt -> ID . LPAREN arg RPAREN SEMICLN
    (36) ass_stmnt -> ID . arr ASS func_stmnt SEMICLN
    (37) ass_stmnt -> ID . ass1 arr ASS logic SEMICLN
    (17) arr -> . empty
    (18) arr -> . LSQUARE exp RSQUARE
    (38) ass1 -> .
    (93) empty -> .
  ! shift/reduce conflict for LSQUARE resolved as shift
  ! reduce/reduce conflict for ASS resolved using rule 38 (ass1 -> .)
    LPAREN          shift and go to state 68
    LSQUARE         shift and go to state 72
    ASS             reduce using rule 38 (ass1 -> .)

    arr                            shift and go to state 69
    ass1                           shift and go to state 70
    empty                          shift and go to state 71

state 51

    (20) funcdecl -> FUNC tipofunc ID LPAREN param . RPAREN varsdecl LCURLY stmnt RCURLY
    RPAREN          shift and go to state 73


state 52

    (23) param -> empty .
    RPAREN          reduce using rule 23 (param -> empty .)


state 53

    (24) param -> tipo . COLON ID multiparam
    COLON           shift and go to state 74


state 54

    (12) multid -> COMMA ID prog5 . arr multid
    (17) arr -> . empty
    (18) arr -> . LSQUARE exp RSQUARE
    (93) empty -> .
    LSQUARE         shift and go to state 72
    COMMA           reduce using rule 93 (empty -> .)
    FUNC            reduce using rule 93 (empty -> .)
    MAIN            reduce using rule 93 (empty -> .)
    LCURLY          reduce using rule 93 (empty -> .)
    SEMICLN         reduce using rule 93 (empty -> .)

    arr                            shift and go to state 75
    empty                          shift and go to state 71

state 55

    (8) multivd -> tipo prog4 COLON ID . prog5 arr multid SEMICLN multivd
    (10) prog5 -> .
    LSQUARE         reduce using rule 10 (prog5 -> .)
    COMMA           reduce using rule 10 (prog5 -> .)
    SEMICLN         reduce using rule 10 (prog5 -> .)

    prog5                          shift and go to state 76

state 56

    (29) stmnt -> while_stmnt stmnt .
    $end            reduce using rule 29 (stmnt -> while_stmnt stmnt .)
    END             reduce using rule 29 (stmnt -> while_stmnt stmnt .)
    RCURLY          reduce using rule 29 (stmnt -> while_stmnt stmnt .)


state 57

    (30) stmnt -> if_stmnt stmnt .
    $end            reduce using rule 30 (stmnt -> if_stmnt stmnt .)
    END             reduce using rule 30 (stmnt -> if_stmnt stmnt .)
    RCURLY          reduce using rule 30 (stmnt -> if_stmnt stmnt .)


state 58

    (31) stmnt -> write_stmnt stmnt .
    $end            reduce using rule 31 (stmnt -> write_stmnt stmnt .)
    END             reduce using rule 31 (stmnt -> write_stmnt stmnt .)
    RCURLY          reduce using rule 31 (stmnt -> write_stmnt stmnt .)


state 59

    (32) stmnt -> read_stmnt stmnt .
    $end            reduce using rule 32 (stmnt -> read_stmnt stmnt .)
    END             reduce using rule 32 (stmnt -> read_stmnt stmnt .)
    RCURLY          reduce using rule 32 (stmnt -> read_stmnt stmnt .)


state 60

    (33) stmnt -> ret_stmnt stmnt .
    $end            reduce using rule 33 (stmnt -> ret_stmnt stmnt .)
    END             reduce using rule 33 (stmnt -> ret_stmnt stmnt .)
    RCURLY          reduce using rule 33 (stmnt -> ret_stmnt stmnt .)


state 61

    (34) stmnt -> func_stmnt stmnt .
    $end            reduce using rule 34 (stmnt -> func_stmnt stmnt .)
    END             reduce using rule 34 (stmnt -> func_stmnt stmnt .)
    RCURLY          reduce using rule 34 (stmnt -> func_stmnt stmnt .)


state 62

    (35) stmnt -> ass_stmnt stmnt .
    $end            reduce using rule 35 (stmnt -> ass_stmnt stmnt .)
    END             reduce using rule 35 (stmnt -> ass_stmnt stmnt .)
    RCURLY          reduce using rule 35 (stmnt -> ass_stmnt stmnt .)


state 63

    (92) while_stmnt -> WHILE LPAREN . logic RPAREN stmnt END
    (50) logic -> . rel log2 OR log1 logic
    (51) logic -> . rel log2 AND log1 logic
    (52) logic -> . rel log2
    (61) rel -> . exp rel2 relop rel1 rel
    (62) rel -> . exp rel2
    (65) exp -> . term exp2 SUB exp1 exp
    (66) exp -> . term exp2 SUM exp1 exp
    (67) exp -> . term exp2
    (70) term -> . factor term2 DIV term1 term
    (71) term -> . factor term2 MULT term1 term
    (72) term -> . factor term2
    (75) factor -> . FALSE ctes4
    (76) factor -> . TRUE ctes4
    (77) factor -> . CTE_STR ctes3
    (78) factor -> . CTE_FLT ctes2
    (79) factor -> . CTE_NUM ctes1
    (80) factor -> . ID fact1 LPAREN logic multiexp RPAREN
    (81) factor -> . ID fact1 arr
    FALSE           shift and go to state 82
    TRUE            shift and go to state 83
    CTE_STR         shift and go to state 84
    CTE_FLT         shift and go to state 85
    CTE_NUM         shift and go to state 86
    ID              shift and go to state 87

    logic                          shift and go to state 77
    rel                            shift and go to state 78
    exp                            shift and go to state 79
    term                           shift and go to state 80
    factor                         shift and go to state 81

state 64

    (89) if_stmnt -> IF LPAREN . logic RPAREN else_stmnt END
    (50) logic -> . rel log2 OR log1 logic
    (51) logic -> . rel log2 AND log1 logic
    (52) logic -> . rel log2
    (61) rel -> . exp rel2 relop rel1 rel
    (62) rel -> . exp rel2
    (65) exp -> . term exp2 SUB exp1 exp
    (66) exp -> . term exp2 SUM exp1 exp
    (67) exp -> . term exp2
    (70) term -> . factor term2 DIV term1 term
    (71) term -> . factor term2 MULT term1 term
    (72) term -> . factor term2
    (75) factor -> . FALSE ctes4
    (76) factor -> . TRUE ctes4
    (77) factor -> . CTE_STR ctes3
    (78) factor -> . CTE_FLT ctes2
    (79) factor -> . CTE_NUM ctes1
    (80) factor -> . ID fact1 LPAREN logic multiexp RPAREN
    (81) factor -> . ID fact1 arr
    FALSE           shift and go to state 82
    TRUE            shift and go to state 83
    CTE_STR         shift and go to state 84
    CTE_FLT         shift and go to state 85
    CTE_NUM         shift and go to state 86
    ID              shift and go to state 87

    logic                          shift and go to state 88
    rel                            shift and go to state 78
    exp                            shift and go to state 79
    term                           shift and go to state 80
    factor                         shift and go to state 81

state 65

    (46) write_stmnt -> WRITE linear1 . LPAREN logic linear2 RPAREN linear3 SEMICLN
    LPAREN          shift and go to state 89


state 66

    (45) read_stmnt -> READ linear1 . LPAREN logic linear2 RPAREN linear3 SEMICLN
    LPAREN          shift and go to state 90


state 67

    (44) ret_stmnt -> RETURN LPAREN . logic RPAREN SEMICLN
    (50) logic -> . rel log2 OR log1 logic
    (51) logic -> . rel log2 AND log1 logic
    (52) logic -> . rel log2
    (61) rel -> . exp rel2 relop rel1 rel
    (62) rel -> . exp rel2
    (65) exp -> . term exp2 SUB exp1 exp
    (66) exp -> . term exp2 SUM exp1 exp
    (67) exp -> . term exp2
    (70) term -> . factor term2 DIV term1 term
    (71) term -> . factor term2 MULT term1 term
    (72) term -> . factor term2
    (75) factor -> . FALSE ctes4
    (76) factor -> . TRUE ctes4
    (77) factor -> . CTE_STR ctes3
    (78) factor -> . CTE_FLT ctes2
    (79) factor -> . CTE_NUM ctes1
    (80) factor -> . ID fact1 LPAREN logic multiexp RPAREN
    (81) factor -> . ID fact1 arr
    FALSE           shift and go to state 82
    TRUE            shift and go to state 83
    CTE_STR         shift and go to state 84
    CTE_FLT         shift and go to state 85
    CTE_NUM         shift and go to state 86
    ID              shift and go to state 87

    logic                          shift and go to state 91
    rel                            shift and go to state 78
    exp                            shift and go to state 79
    term                           shift and go to state 80
    factor                         shift and go to state 81

state 68

    (39) func_stmnt -> ID LPAREN . arg RPAREN SEMICLN
    (40) arg -> . empty
    (41) arg -> . logic multiarg
    (93) empty -> .
    (50) logic -> . rel log2 OR log1 logic
    (51) logic -> . rel log2 AND log1 logic
    (52) logic -> . rel log2
    (61) rel -> . exp rel2 relop rel1 rel
    (62) rel -> . exp rel2
    (65) exp -> . term exp2 SUB exp1 exp
    (66) exp -> . term exp2 SUM exp1 exp
    (67) exp -> . term exp2
    (70) term -> . factor term2 DIV term1 term
    (71) term -> . factor term2 MULT term1 term
    (72) term -> . factor term2
    (75) factor -> . FALSE ctes4
    (76) factor -> . TRUE ctes4
    (77) factor -> . CTE_STR ctes3
    (78) factor -> . CTE_FLT ctes2
    (79) factor -> . CTE_NUM ctes1
    (80) factor -> . ID fact1 LPAREN logic multiexp RPAREN
    (81) factor -> . ID fact1 arr
    RPAREN          reduce using rule 93 (empty -> .)
    FALSE           shift and go to state 82
    TRUE            shift and go to state 83
    CTE_STR         shift and go to state 84
    CTE_FLT         shift and go to state 85
    CTE_NUM         shift and go to state 86
    ID              shift and go to state 87

    arg                            shift and go to state 92
    empty                          shift and go to state 93
    logic                          shift and go to state 94
    rel                            shift and go to state 78
    exp                            shift and go to state 79
    term                           shift and go to state 80
    factor                         shift and go to state 81

state 69

    (36) ass_stmnt -> ID arr . ASS func_stmnt SEMICLN
    ASS             shift and go to state 95


state 70

    (37) ass_stmnt -> ID ass1 . arr ASS logic SEMICLN
    (17) arr -> . empty
    (18) arr -> . LSQUARE exp RSQUARE
    (93) empty -> .
    LSQUARE         shift and go to state 72
    ASS             reduce using rule 93 (empty -> .)

    arr                            shift and go to state 96
    empty                          shift and go to state 71

state 71

    (17) arr -> empty .
    ASS             reduce using rule 17 (arr -> empty .)
    COMMA           reduce using rule 17 (arr -> empty .)
    FUNC            reduce using rule 17 (arr -> empty .)
    MAIN            reduce using rule 17 (arr -> empty .)
    LCURLY          reduce using rule 17 (arr -> empty .)
    SEMICLN         reduce using rule 17 (arr -> empty .)
    DIV             reduce using rule 17 (arr -> empty .)
    MULT            reduce using rule 17 (arr -> empty .)
    SUB             reduce using rule 17 (arr -> empty .)
    SUM             reduce using rule 17 (arr -> empty .)
    EQUAL_TO        reduce using rule 17 (arr -> empty .)
    DIFFERENT_TO    reduce using rule 17 (arr -> empty .)
    LESS_OR_EQ_THAN reduce using rule 17 (arr -> empty .)
    MORE_OR_EQ_THAN reduce using rule 17 (arr -> empty .)
    LESS_THAN       reduce using rule 17 (arr -> empty .)
    MORE_THAN       reduce using rule 17 (arr -> empty .)
    OR              reduce using rule 17 (arr -> empty .)
    AND             reduce using rule 17 (arr -> empty .)
    RPAREN          reduce using rule 17 (arr -> empty .)
    RSQUARE         reduce using rule 17 (arr -> empty .)


state 72

    (18) arr -> LSQUARE . exp RSQUARE
    (65) exp -> . term exp2 SUB exp1 exp
    (66) exp -> . term exp2 SUM exp1 exp
    (67) exp -> . term exp2
    (70) term -> . factor term2 DIV term1 term
    (71) term -> . factor term2 MULT term1 term
    (72) term -> . factor term2
    (75) factor -> . FALSE ctes4
    (76) factor -> . TRUE ctes4
    (77) factor -> . CTE_STR ctes3
    (78) factor -> . CTE_FLT ctes2
    (79) factor -> . CTE_NUM ctes1
    (80) factor -> . ID fact1 LPAREN logic multiexp RPAREN
    (81) factor -> . ID fact1 arr
    FALSE           shift and go to state 82
    TRUE            shift and go to state 83
    CTE_STR         shift and go to state 84
    CTE_FLT         shift and go to state 85
    CTE_NUM         shift and go to state 86
    ID              shift and go to state 87

    exp                            shift and go to state 97
    term                           shift and go to state 80
    factor                         shift and go to state 81

state 73

    (20) funcdecl -> FUNC tipofunc ID LPAREN param RPAREN . varsdecl LCURLY stmnt RCURLY
    (4) varsdecl -> . empty
    (5) varsdecl -> . VARS prog3 multivd multid
    (93) empty -> .
    VARS            shift and go to state 9
    LCURLY          reduce using rule 93 (empty -> .)

    varsdecl                       shift and go to state 98
    empty                          shift and go to state 8

state 74

    (24) param -> tipo COLON . ID multiparam
    ID              shift and go to state 99


state 75

    (12) multid -> COMMA ID prog5 arr . multid
    (11) multid -> . empty
    (12) multid -> . COMMA ID prog5 arr multid
    (93) empty -> .
    COMMA           shift and go to state 30
    FUNC            reduce using rule 93 (empty -> .)
    MAIN            reduce using rule 93 (empty -> .)
    LCURLY          reduce using rule 93 (empty -> .)
    SEMICLN         reduce using rule 93 (empty -> .)

    multid                         shift and go to state 100
    empty                          shift and go to state 29

state 76

    (8) multivd -> tipo prog4 COLON ID prog5 . arr multid SEMICLN multivd
    (17) arr -> . empty
    (18) arr -> . LSQUARE exp RSQUARE
    (93) empty -> .
    LSQUARE         shift and go to state 72
    COMMA           reduce using rule 93 (empty -> .)
    SEMICLN         reduce using rule 93 (empty -> .)

    arr                            shift and go to state 101
    empty                          shift and go to state 71

state 77

    (92) while_stmnt -> WHILE LPAREN logic . RPAREN stmnt END
    RPAREN          shift and go to state 102


state 78

    (50) logic -> rel . log2 OR log1 logic
    (51) logic -> rel . log2 AND log1 logic
    (52) logic -> rel . log2
    (54) log2 -> .
    OR              reduce using rule 54 (log2 -> .)
    AND             reduce using rule 54 (log2 -> .)
    RPAREN          reduce using rule 54 (log2 -> .)
    COMMA           reduce using rule 54 (log2 -> .)
    SEMICLN         reduce using rule 54 (log2 -> .)

    log2                           shift and go to state 103

state 79

    (61) rel -> exp . rel2 relop rel1 rel
    (62) rel -> exp . rel2
    (64) rel2 -> .
    EQUAL_TO        reduce using rule 64 (rel2 -> .)
    DIFFERENT_TO    reduce using rule 64 (rel2 -> .)
    LESS_OR_EQ_THAN reduce using rule 64 (rel2 -> .)
    MORE_OR_EQ_THAN reduce using rule 64 (rel2 -> .)
    LESS_THAN       reduce using rule 64 (rel2 -> .)
    MORE_THAN       reduce using rule 64 (rel2 -> .)
    OR              reduce using rule 64 (rel2 -> .)
    AND             reduce using rule 64 (rel2 -> .)
    RPAREN          reduce using rule 64 (rel2 -> .)
    COMMA           reduce using rule 64 (rel2 -> .)
    SEMICLN         reduce using rule 64 (rel2 -> .)

    rel2                           shift and go to state 104

state 80

    (65) exp -> term . exp2 SUB exp1 exp
    (66) exp -> term . exp2 SUM exp1 exp
    (67) exp -> term . exp2
    (68) exp2 -> .
    SUB             reduce using rule 68 (exp2 -> .)
    SUM             reduce using rule 68 (exp2 -> .)
    EQUAL_TO        reduce using rule 68 (exp2 -> .)
    DIFFERENT_TO    reduce using rule 68 (exp2 -> .)
    LESS_OR_EQ_THAN reduce using rule 68 (exp2 -> .)
    MORE_OR_EQ_THAN reduce using rule 68 (exp2 -> .)
    LESS_THAN       reduce using rule 68 (exp2 -> .)
    MORE_THAN       reduce using rule 68 (exp2 -> .)
    OR              reduce using rule 68 (exp2 -> .)
    AND             reduce using rule 68 (exp2 -> .)
    RPAREN          reduce using rule 68 (exp2 -> .)
    COMMA           reduce using rule 68 (exp2 -> .)
    RSQUARE         reduce using rule 68 (exp2 -> .)
    SEMICLN         reduce using rule 68 (exp2 -> .)

    exp2                           shift and go to state 105

state 81

    (70) term -> factor . term2 DIV term1 term
    (71) term -> factor . term2 MULT term1 term
    (72) term -> factor . term2
    (74) term2 -> .
    DIV             reduce using rule 74 (term2 -> .)
    MULT            reduce using rule 74 (term2 -> .)
    SUB             reduce using rule 74 (term2 -> .)
    SUM             reduce using rule 74 (term2 -> .)
    EQUAL_TO        reduce using rule 74 (term2 -> .)
    DIFFERENT_TO    reduce using rule 74 (term2 -> .)
    LESS_OR_EQ_THAN reduce using rule 74 (term2 -> .)
    MORE_OR_EQ_THAN reduce using rule 74 (term2 -> .)
    LESS_THAN       reduce using rule 74 (term2 -> .)
    MORE_THAN       reduce using rule 74 (term2 -> .)
    OR              reduce using rule 74 (term2 -> .)
    AND             reduce using rule 74 (term2 -> .)
    RPAREN          reduce using rule 74 (term2 -> .)
    COMMA           reduce using rule 74 (term2 -> .)
    RSQUARE         reduce using rule 74 (term2 -> .)
    SEMICLN         reduce using rule 74 (term2 -> .)

    term2                          shift and go to state 106

state 82

    (75) factor -> FALSE . ctes4
    (85) ctes4 -> .
    DIV             reduce using rule 85 (ctes4 -> .)
    MULT            reduce using rule 85 (ctes4 -> .)
    SUB             reduce using rule 85 (ctes4 -> .)
    SUM             reduce using rule 85 (ctes4 -> .)
    EQUAL_TO        reduce using rule 85 (ctes4 -> .)
    DIFFERENT_TO    reduce using rule 85 (ctes4 -> .)
    LESS_OR_EQ_THAN reduce using rule 85 (ctes4 -> .)
    MORE_OR_EQ_THAN reduce using rule 85 (ctes4 -> .)
    LESS_THAN       reduce using rule 85 (ctes4 -> .)
    MORE_THAN       reduce using rule 85 (ctes4 -> .)
    OR              reduce using rule 85 (ctes4 -> .)
    AND             reduce using rule 85 (ctes4 -> .)
    RPAREN          reduce using rule 85 (ctes4 -> .)
    COMMA           reduce using rule 85 (ctes4 -> .)
    RSQUARE         reduce using rule 85 (ctes4 -> .)
    SEMICLN         reduce using rule 85 (ctes4 -> .)

    ctes4                          shift and go to state 107

state 83

    (76) factor -> TRUE . ctes4
    (85) ctes4 -> .
    DIV             reduce using rule 85 (ctes4 -> .)
    MULT            reduce using rule 85 (ctes4 -> .)
    SUB             reduce using rule 85 (ctes4 -> .)
    SUM             reduce using rule 85 (ctes4 -> .)
    EQUAL_TO        reduce using rule 85 (ctes4 -> .)
    DIFFERENT_TO    reduce using rule 85 (ctes4 -> .)
    LESS_OR_EQ_THAN reduce using rule 85 (ctes4 -> .)
    MORE_OR_EQ_THAN reduce using rule 85 (ctes4 -> .)
    LESS_THAN       reduce using rule 85 (ctes4 -> .)
    MORE_THAN       reduce using rule 85 (ctes4 -> .)
    OR              reduce using rule 85 (ctes4 -> .)
    AND             reduce using rule 85 (ctes4 -> .)
    RPAREN          reduce using rule 85 (ctes4 -> .)
    COMMA           reduce using rule 85 (ctes4 -> .)
    RSQUARE         reduce using rule 85 (ctes4 -> .)
    SEMICLN         reduce using rule 85 (ctes4 -> .)

    ctes4                          shift and go to state 108

state 84

    (77) factor -> CTE_STR . ctes3
    (84) ctes3 -> .
    DIV             reduce using rule 84 (ctes3 -> .)
    MULT            reduce using rule 84 (ctes3 -> .)
    SUB             reduce using rule 84 (ctes3 -> .)
    SUM             reduce using rule 84 (ctes3 -> .)
    EQUAL_TO        reduce using rule 84 (ctes3 -> .)
    DIFFERENT_TO    reduce using rule 84 (ctes3 -> .)
    LESS_OR_EQ_THAN reduce using rule 84 (ctes3 -> .)
    MORE_OR_EQ_THAN reduce using rule 84 (ctes3 -> .)
    LESS_THAN       reduce using rule 84 (ctes3 -> .)
    MORE_THAN       reduce using rule 84 (ctes3 -> .)
    OR              reduce using rule 84 (ctes3 -> .)
    AND             reduce using rule 84 (ctes3 -> .)
    RPAREN          reduce using rule 84 (ctes3 -> .)
    COMMA           reduce using rule 84 (ctes3 -> .)
    RSQUARE         reduce using rule 84 (ctes3 -> .)
    SEMICLN         reduce using rule 84 (ctes3 -> .)

    ctes3                          shift and go to state 109

state 85

    (78) factor -> CTE_FLT . ctes2
    (83) ctes2 -> .
    DIV             reduce using rule 83 (ctes2 -> .)
    MULT            reduce using rule 83 (ctes2 -> .)
    SUB             reduce using rule 83 (ctes2 -> .)
    SUM             reduce using rule 83 (ctes2 -> .)
    EQUAL_TO        reduce using rule 83 (ctes2 -> .)
    DIFFERENT_TO    reduce using rule 83 (ctes2 -> .)
    LESS_OR_EQ_THAN reduce using rule 83 (ctes2 -> .)
    MORE_OR_EQ_THAN reduce using rule 83 (ctes2 -> .)
    LESS_THAN       reduce using rule 83 (ctes2 -> .)
    MORE_THAN       reduce using rule 83 (ctes2 -> .)
    OR              reduce using rule 83 (ctes2 -> .)
    AND             reduce using rule 83 (ctes2 -> .)
    RPAREN          reduce using rule 83 (ctes2 -> .)
    COMMA           reduce using rule 83 (ctes2 -> .)
    RSQUARE         reduce using rule 83 (ctes2 -> .)
    SEMICLN         reduce using rule 83 (ctes2 -> .)

    ctes2                          shift and go to state 110

state 86

    (79) factor -> CTE_NUM . ctes1
    (82) ctes1 -> .
    DIV             reduce using rule 82 (ctes1 -> .)
    MULT            reduce using rule 82 (ctes1 -> .)
    SUB             reduce using rule 82 (ctes1 -> .)
    SUM             reduce using rule 82 (ctes1 -> .)
    EQUAL_TO        reduce using rule 82 (ctes1 -> .)
    DIFFERENT_TO    reduce using rule 82 (ctes1 -> .)
    LESS_OR_EQ_THAN reduce using rule 82 (ctes1 -> .)
    MORE_OR_EQ_THAN reduce using rule 82 (ctes1 -> .)
    LESS_THAN       reduce using rule 82 (ctes1 -> .)
    MORE_THAN       reduce using rule 82 (ctes1 -> .)
    OR              reduce using rule 82 (ctes1 -> .)
    AND             reduce using rule 82 (ctes1 -> .)
    RPAREN          reduce using rule 82 (ctes1 -> .)
    COMMA           reduce using rule 82 (ctes1 -> .)
    RSQUARE         reduce using rule 82 (ctes1 -> .)
    SEMICLN         reduce using rule 82 (ctes1 -> .)

    ctes1                          shift and go to state 111

state 87

    (80) factor -> ID . fact1 LPAREN logic multiexp RPAREN
    (81) factor -> ID . fact1 arr
    (86) fact1 -> .
    LPAREN          reduce using rule 86 (fact1 -> .)
    LSQUARE         reduce using rule 86 (fact1 -> .)
    DIV             reduce using rule 86 (fact1 -> .)
    MULT            reduce using rule 86 (fact1 -> .)
    SUB             reduce using rule 86 (fact1 -> .)
    SUM             reduce using rule 86 (fact1 -> .)
    EQUAL_TO        reduce using rule 86 (fact1 -> .)
    DIFFERENT_TO    reduce using rule 86 (fact1 -> .)
    LESS_OR_EQ_THAN reduce using rule 86 (fact1 -> .)
    MORE_OR_EQ_THAN reduce using rule 86 (fact1 -> .)
    LESS_THAN       reduce using rule 86 (fact1 -> .)
    MORE_THAN       reduce using rule 86 (fact1 -> .)
    OR              reduce using rule 86 (fact1 -> .)
    AND             reduce using rule 86 (fact1 -> .)
    RPAREN          reduce using rule 86 (fact1 -> .)
    COMMA           reduce using rule 86 (fact1 -> .)
    RSQUARE         reduce using rule 86 (fact1 -> .)
    SEMICLN         reduce using rule 86 (fact1 -> .)

    fact1                          shift and go to state 112

state 88

    (89) if_stmnt -> IF LPAREN logic . RPAREN else_stmnt END
    RPAREN          shift and go to state 113


state 89

    (46) write_stmnt -> WRITE linear1 LPAREN . logic linear2 RPAREN linear3 SEMICLN
    (50) logic -> . rel log2 OR log1 logic
    (51) logic -> . rel log2 AND log1 logic
    (52) logic -> . rel log2
    (61) rel -> . exp rel2 relop rel1 rel
    (62) rel -> . exp rel2
    (65) exp -> . term exp2 SUB exp1 exp
    (66) exp -> . term exp2 SUM exp1 exp
    (67) exp -> . term exp2
    (70) term -> . factor term2 DIV term1 term
    (71) term -> . factor term2 MULT term1 term
    (72) term -> . factor term2
    (75) factor -> . FALSE ctes4
    (76) factor -> . TRUE ctes4
    (77) factor -> . CTE_STR ctes3
    (78) factor -> . CTE_FLT ctes2
    (79) factor -> . CTE_NUM ctes1
    (80) factor -> . ID fact1 LPAREN logic multiexp RPAREN
    (81) factor -> . ID fact1 arr
    FALSE           shift and go to state 82
    TRUE            shift and go to state 83
    CTE_STR         shift and go to state 84
    CTE_FLT         shift and go to state 85
    CTE_NUM         shift and go to state 86
    ID              shift and go to state 87

    logic                          shift and go to state 114
    rel                            shift and go to state 78
    exp                            shift and go to state 79
    term                           shift and go to state 80
    factor                         shift and go to state 81

state 90

    (45) read_stmnt -> READ linear1 LPAREN . logic linear2 RPAREN linear3 SEMICLN
    (50) logic -> . rel log2 OR log1 logic
    (51) logic -> . rel log2 AND log1 logic
    (52) logic -> . rel log2
    (61) rel -> . exp rel2 relop rel1 rel
    (62) rel -> . exp rel2
    (65) exp -> . term exp2 SUB exp1 exp
    (66) exp -> . term exp2 SUM exp1 exp
    (67) exp -> . term exp2
    (70) term -> . factor term2 DIV term1 term
    (71) term -> . factor term2 MULT term1 term
    (72) term -> . factor term2
    (75) factor -> . FALSE ctes4
    (76) factor -> . TRUE ctes4
    (77) factor -> . CTE_STR ctes3
    (78) factor -> . CTE_FLT ctes2
    (79) factor -> . CTE_NUM ctes1
    (80) factor -> . ID fact1 LPAREN logic multiexp RPAREN
    (81) factor -> . ID fact1 arr
    FALSE           shift and go to state 82
    TRUE            shift and go to state 83
    CTE_STR         shift and go to state 84
    CTE_FLT         shift and go to state 85
    CTE_NUM         shift and go to state 86
    ID              shift and go to state 87

    logic                          shift and go to state 115
    rel                            shift and go to state 78
    exp                            shift and go to state 79
    term                           shift and go to state 80
    factor                         shift and go to state 81

state 91

    (44) ret_stmnt -> RETURN LPAREN logic . RPAREN SEMICLN
    RPAREN          shift and go to state 116


state 92

    (39) func_stmnt -> ID LPAREN arg . RPAREN SEMICLN
    RPAREN          shift and go to state 117


state 93

    (40) arg -> empty .
    RPAREN          reduce using rule 40 (arg -> empty .)
    COMMA           reduce using rule 40 (arg -> empty .)


state 94

    (41) arg -> logic . multiarg
    (42) multiarg -> . empty
    (43) multiarg -> . COMMA arg multiarg
    (93) empty -> .
  ! shift/reduce conflict for COMMA resolved as shift
    COMMA           shift and go to state 120
    RPAREN          reduce using rule 93 (empty -> .)

    multiarg                       shift and go to state 118
    empty                          shift and go to state 119

state 95

    (36) ass_stmnt -> ID arr ASS . func_stmnt SEMICLN
    (39) func_stmnt -> . ID LPAREN arg RPAREN SEMICLN
    ID              shift and go to state 121

    func_stmnt                     shift and go to state 122

state 96

    (37) ass_stmnt -> ID ass1 arr . ASS logic SEMICLN
    ASS             shift and go to state 123


state 97

    (18) arr -> LSQUARE exp . RSQUARE
    RSQUARE         shift and go to state 124


state 98

    (20) funcdecl -> FUNC tipofunc ID LPAREN param RPAREN varsdecl . LCURLY stmnt RCURLY
    LCURLY          shift and go to state 125


state 99

    (24) param -> tipo COLON ID . multiparam
    (25) multiparam -> . empty
    (26) multiparam -> . COMMA param
    (93) empty -> .
    COMMA           shift and go to state 128
    RPAREN          reduce using rule 93 (empty -> .)

    multiparam                     shift and go to state 126
    empty                          shift and go to state 127

state 100

    (12) multid -> COMMA ID prog5 arr multid .
    FUNC            reduce using rule 12 (multid -> COMMA ID prog5 arr multid .)
    MAIN            reduce using rule 12 (multid -> COMMA ID prog5 arr multid .)
    LCURLY          reduce using rule 12 (multid -> COMMA ID prog5 arr multid .)
    SEMICLN         reduce using rule 12 (multid -> COMMA ID prog5 arr multid .)


state 101

    (8) multivd -> tipo prog4 COLON ID prog5 arr . multid SEMICLN multivd
    (11) multid -> . empty
    (12) multid -> . COMMA ID prog5 arr multid
    (93) empty -> .
    COMMA           shift and go to state 30
    SEMICLN         reduce using rule 93 (empty -> .)

    multid                         shift and go to state 129
    empty                          shift and go to state 29

state 102

    (92) while_stmnt -> WHILE LPAREN logic RPAREN . stmnt END
    (28) stmnt -> . empty
    (29) stmnt -> . while_stmnt stmnt
    (30) stmnt -> . if_stmnt stmnt
    (31) stmnt -> . write_stmnt stmnt
    (32) stmnt -> . read_stmnt stmnt
    (33) stmnt -> . ret_stmnt stmnt
    (34) stmnt -> . func_stmnt stmnt
    (35) stmnt -> . ass_stmnt stmnt
    (93) empty -> .
    (92) while_stmnt -> . WHILE LPAREN logic RPAREN stmnt END
    (89) if_stmnt -> . IF LPAREN logic RPAREN else_stmnt END
    (46) write_stmnt -> . WRITE linear1 LPAREN logic linear2 RPAREN linear3 SEMICLN
    (45) read_stmnt -> . READ linear1 LPAREN logic linear2 RPAREN linear3 SEMICLN
    (44) ret_stmnt -> . RETURN LPAREN logic RPAREN SEMICLN
    (39) func_stmnt -> . ID LPAREN arg RPAREN SEMICLN
    (36) ass_stmnt -> . ID arr ASS func_stmnt SEMICLN
    (37) ass_stmnt -> . ID ass1 arr ASS logic SEMICLN
    END             reduce using rule 93 (empty -> .)
    WHILE           shift and go to state 45
    IF              shift and go to state 46
    WRITE           shift and go to state 47
    READ            shift and go to state 48
    RETURN          shift and go to state 49
    ID              shift and go to state 50

    stmnt                          shift and go to state 130
    empty                          shift and go to state 37
    while_stmnt                    shift and go to state 38
    if_stmnt                       shift and go to state 39
    write_stmnt                    shift and go to state 40
    read_stmnt                     shift and go to state 41
    ret_stmnt                      shift and go to state 42
    func_stmnt                     shift and go to state 43
    ass_stmnt                      shift and go to state 44

state 103

    (50) logic -> rel log2 . OR log1 logic
    (51) logic -> rel log2 . AND log1 logic
    (52) logic -> rel log2 .
    OR              shift and go to state 131
    AND             shift and go to state 132
    RPAREN          reduce using rule 52 (logic -> rel log2 .)
    COMMA           reduce using rule 52 (logic -> rel log2 .)
    SEMICLN         reduce using rule 52 (logic -> rel log2 .)


state 104

    (61) rel -> exp rel2 . relop rel1 rel
    (62) rel -> exp rel2 .
    (55) relop -> . EQUAL_TO
    (56) relop -> . DIFFERENT_TO
    (57) relop -> . LESS_OR_EQ_THAN
    (58) relop -> . MORE_OR_EQ_THAN
    (59) relop -> . LESS_THAN
    (60) relop -> . MORE_THAN
    OR              reduce using rule 62 (rel -> exp rel2 .)
    AND             reduce using rule 62 (rel -> exp rel2 .)
    RPAREN          reduce using rule 62 (rel -> exp rel2 .)
    COMMA           reduce using rule 62 (rel -> exp rel2 .)
    SEMICLN         reduce using rule 62 (rel -> exp rel2 .)
    EQUAL_TO        shift and go to state 134
    DIFFERENT_TO    shift and go to state 135
    LESS_OR_EQ_THAN shift and go to state 136
    MORE_OR_EQ_THAN shift and go to state 137
    LESS_THAN       shift and go to state 138
    MORE_THAN       shift and go to state 139

    relop                          shift and go to state 133

state 105

    (65) exp -> term exp2 . SUB exp1 exp
    (66) exp -> term exp2 . SUM exp1 exp
    (67) exp -> term exp2 .
    SUB             shift and go to state 140
    SUM             shift and go to state 141
    EQUAL_TO        reduce using rule 67 (exp -> term exp2 .)
    DIFFERENT_TO    reduce using rule 67 (exp -> term exp2 .)
    LESS_OR_EQ_THAN reduce using rule 67 (exp -> term exp2 .)
    MORE_OR_EQ_THAN reduce using rule 67 (exp -> term exp2 .)
    LESS_THAN       reduce using rule 67 (exp -> term exp2 .)
    MORE_THAN       reduce using rule 67 (exp -> term exp2 .)
    OR              reduce using rule 67 (exp -> term exp2 .)
    AND             reduce using rule 67 (exp -> term exp2 .)
    RPAREN          reduce using rule 67 (exp -> term exp2 .)
    COMMA           reduce using rule 67 (exp -> term exp2 .)
    RSQUARE         reduce using rule 67 (exp -> term exp2 .)
    SEMICLN         reduce using rule 67 (exp -> term exp2 .)


state 106

    (70) term -> factor term2 . DIV term1 term
    (71) term -> factor term2 . MULT term1 term
    (72) term -> factor term2 .
    DIV             shift and go to state 142
    MULT            shift and go to state 143
    SUB             reduce using rule 72 (term -> factor term2 .)
    SUM             reduce using rule 72 (term -> factor term2 .)
    EQUAL_TO        reduce using rule 72 (term -> factor term2 .)
    DIFFERENT_TO    reduce using rule 72 (term -> factor term2 .)
    LESS_OR_EQ_THAN reduce using rule 72 (term -> factor term2 .)
    MORE_OR_EQ_THAN reduce using rule 72 (term -> factor term2 .)
    LESS_THAN       reduce using rule 72 (term -> factor term2 .)
    MORE_THAN       reduce using rule 72 (term -> factor term2 .)
    OR              reduce using rule 72 (term -> factor term2 .)
    AND             reduce using rule 72 (term -> factor term2 .)
    RPAREN          reduce using rule 72 (term -> factor term2 .)
    COMMA           reduce using rule 72 (term -> factor term2 .)
    RSQUARE         reduce using rule 72 (term -> factor term2 .)
    SEMICLN         reduce using rule 72 (term -> factor term2 .)


state 107

    (75) factor -> FALSE ctes4 .
    DIV             reduce using rule 75 (factor -> FALSE ctes4 .)
    MULT            reduce using rule 75 (factor -> FALSE ctes4 .)
    SUB             reduce using rule 75 (factor -> FALSE ctes4 .)
    SUM             reduce using rule 75 (factor -> FALSE ctes4 .)
    EQUAL_TO        reduce using rule 75 (factor -> FALSE ctes4 .)
    DIFFERENT_TO    reduce using rule 75 (factor -> FALSE ctes4 .)
    LESS_OR_EQ_THAN reduce using rule 75 (factor -> FALSE ctes4 .)
    MORE_OR_EQ_THAN reduce using rule 75 (factor -> FALSE ctes4 .)
    LESS_THAN       reduce using rule 75 (factor -> FALSE ctes4 .)
    MORE_THAN       reduce using rule 75 (factor -> FALSE ctes4 .)
    OR              reduce using rule 75 (factor -> FALSE ctes4 .)
    AND             reduce using rule 75 (factor -> FALSE ctes4 .)
    RPAREN          reduce using rule 75 (factor -> FALSE ctes4 .)
    COMMA           reduce using rule 75 (factor -> FALSE ctes4 .)
    RSQUARE         reduce using rule 75 (factor -> FALSE ctes4 .)
    SEMICLN         reduce using rule 75 (factor -> FALSE ctes4 .)


state 108

    (76) factor -> TRUE ctes4 .
    DIV             reduce using rule 76 (factor -> TRUE ctes4 .)
    MULT            reduce using rule 76 (factor -> TRUE ctes4 .)
    SUB             reduce using rule 76 (factor -> TRUE ctes4 .)
    SUM             reduce using rule 76 (factor -> TRUE ctes4 .)
    EQUAL_TO        reduce using rule 76 (factor -> TRUE ctes4 .)
    DIFFERENT_TO    reduce using rule 76 (factor -> TRUE ctes4 .)
    LESS_OR_EQ_THAN reduce using rule 76 (factor -> TRUE ctes4 .)
    MORE_OR_EQ_THAN reduce using rule 76 (factor -> TRUE ctes4 .)
    LESS_THAN       reduce using rule 76 (factor -> TRUE ctes4 .)
    MORE_THAN       reduce using rule 76 (factor -> TRUE ctes4 .)
    OR              reduce using rule 76 (factor -> TRUE ctes4 .)
    AND             reduce using rule 76 (factor -> TRUE ctes4 .)
    RPAREN          reduce using rule 76 (factor -> TRUE ctes4 .)
    COMMA           reduce using rule 76 (factor -> TRUE ctes4 .)
    RSQUARE         reduce using rule 76 (factor -> TRUE ctes4 .)
    SEMICLN         reduce using rule 76 (factor -> TRUE ctes4 .)


state 109

    (77) factor -> CTE_STR ctes3 .
    DIV             reduce using rule 77 (factor -> CTE_STR ctes3 .)
    MULT            reduce using rule 77 (factor -> CTE_STR ctes3 .)
    SUB             reduce using rule 77 (factor -> CTE_STR ctes3 .)
    SUM             reduce using rule 77 (factor -> CTE_STR ctes3 .)
    EQUAL_TO        reduce using rule 77 (factor -> CTE_STR ctes3 .)
    DIFFERENT_TO    reduce using rule 77 (factor -> CTE_STR ctes3 .)
    LESS_OR_EQ_THAN reduce using rule 77 (factor -> CTE_STR ctes3 .)
    MORE_OR_EQ_THAN reduce using rule 77 (factor -> CTE_STR ctes3 .)
    LESS_THAN       reduce using rule 77 (factor -> CTE_STR ctes3 .)
    MORE_THAN       reduce using rule 77 (factor -> CTE_STR ctes3 .)
    OR              reduce using rule 77 (factor -> CTE_STR ctes3 .)
    AND             reduce using rule 77 (factor -> CTE_STR ctes3 .)
    RPAREN          reduce using rule 77 (factor -> CTE_STR ctes3 .)
    COMMA           reduce using rule 77 (factor -> CTE_STR ctes3 .)
    RSQUARE         reduce using rule 77 (factor -> CTE_STR ctes3 .)
    SEMICLN         reduce using rule 77 (factor -> CTE_STR ctes3 .)


state 110

    (78) factor -> CTE_FLT ctes2 .
    DIV             reduce using rule 78 (factor -> CTE_FLT ctes2 .)
    MULT            reduce using rule 78 (factor -> CTE_FLT ctes2 .)
    SUB             reduce using rule 78 (factor -> CTE_FLT ctes2 .)
    SUM             reduce using rule 78 (factor -> CTE_FLT ctes2 .)
    EQUAL_TO        reduce using rule 78 (factor -> CTE_FLT ctes2 .)
    DIFFERENT_TO    reduce using rule 78 (factor -> CTE_FLT ctes2 .)
    LESS_OR_EQ_THAN reduce using rule 78 (factor -> CTE_FLT ctes2 .)
    MORE_OR_EQ_THAN reduce using rule 78 (factor -> CTE_FLT ctes2 .)
    LESS_THAN       reduce using rule 78 (factor -> CTE_FLT ctes2 .)
    MORE_THAN       reduce using rule 78 (factor -> CTE_FLT ctes2 .)
    OR              reduce using rule 78 (factor -> CTE_FLT ctes2 .)
    AND             reduce using rule 78 (factor -> CTE_FLT ctes2 .)
    RPAREN          reduce using rule 78 (factor -> CTE_FLT ctes2 .)
    COMMA           reduce using rule 78 (factor -> CTE_FLT ctes2 .)
    RSQUARE         reduce using rule 78 (factor -> CTE_FLT ctes2 .)
    SEMICLN         reduce using rule 78 (factor -> CTE_FLT ctes2 .)


state 111

    (79) factor -> CTE_NUM ctes1 .
    DIV             reduce using rule 79 (factor -> CTE_NUM ctes1 .)
    MULT            reduce using rule 79 (factor -> CTE_NUM ctes1 .)
    SUB             reduce using rule 79 (factor -> CTE_NUM ctes1 .)
    SUM             reduce using rule 79 (factor -> CTE_NUM ctes1 .)
    EQUAL_TO        reduce using rule 79 (factor -> CTE_NUM ctes1 .)
    DIFFERENT_TO    reduce using rule 79 (factor -> CTE_NUM ctes1 .)
    LESS_OR_EQ_THAN reduce using rule 79 (factor -> CTE_NUM ctes1 .)
    MORE_OR_EQ_THAN reduce using rule 79 (factor -> CTE_NUM ctes1 .)
    LESS_THAN       reduce using rule 79 (factor -> CTE_NUM ctes1 .)
    MORE_THAN       reduce using rule 79 (factor -> CTE_NUM ctes1 .)
    OR              reduce using rule 79 (factor -> CTE_NUM ctes1 .)
    AND             reduce using rule 79 (factor -> CTE_NUM ctes1 .)
    RPAREN          reduce using rule 79 (factor -> CTE_NUM ctes1 .)
    COMMA           reduce using rule 79 (factor -> CTE_NUM ctes1 .)
    RSQUARE         reduce using rule 79 (factor -> CTE_NUM ctes1 .)
    SEMICLN         reduce using rule 79 (factor -> CTE_NUM ctes1 .)


state 112

    (80) factor -> ID fact1 . LPAREN logic multiexp RPAREN
    (81) factor -> ID fact1 . arr
    (17) arr -> . empty
    (18) arr -> . LSQUARE exp RSQUARE
    (93) empty -> .
    LPAREN          shift and go to state 144
    LSQUARE         shift and go to state 72
    DIV             reduce using rule 93 (empty -> .)
    MULT            reduce using rule 93 (empty -> .)
    SUB             reduce using rule 93 (empty -> .)
    SUM             reduce using rule 93 (empty -> .)
    EQUAL_TO        reduce using rule 93 (empty -> .)
    DIFFERENT_TO    reduce using rule 93 (empty -> .)
    LESS_OR_EQ_THAN reduce using rule 93 (empty -> .)
    MORE_OR_EQ_THAN reduce using rule 93 (empty -> .)
    LESS_THAN       reduce using rule 93 (empty -> .)
    MORE_THAN       reduce using rule 93 (empty -> .)
    OR              reduce using rule 93 (empty -> .)
    AND             reduce using rule 93 (empty -> .)
    RPAREN          reduce using rule 93 (empty -> .)
    COMMA           reduce using rule 93 (empty -> .)
    RSQUARE         reduce using rule 93 (empty -> .)
    SEMICLN         reduce using rule 93 (empty -> .)

    arr                            shift and go to state 145
    empty                          shift and go to state 71

state 113

    (89) if_stmnt -> IF LPAREN logic RPAREN . else_stmnt END
    (90) else_stmnt -> . empty
    (91) else_stmnt -> . ELSE stmnt
    (93) empty -> .
    ELSE            shift and go to state 148
    END             reduce using rule 93 (empty -> .)

    else_stmnt                     shift and go to state 146
    empty                          shift and go to state 147

state 114

    (46) write_stmnt -> WRITE linear1 LPAREN logic . linear2 RPAREN linear3 SEMICLN
    (48) linear2 -> .
    RPAREN          reduce using rule 48 (linear2 -> .)

    linear2                        shift and go to state 149

state 115

    (45) read_stmnt -> READ linear1 LPAREN logic . linear2 RPAREN linear3 SEMICLN
    (48) linear2 -> .
    RPAREN          reduce using rule 48 (linear2 -> .)

    linear2                        shift and go to state 150

state 116

    (44) ret_stmnt -> RETURN LPAREN logic RPAREN . SEMICLN
    SEMICLN         shift and go to state 151


state 117

    (39) func_stmnt -> ID LPAREN arg RPAREN . SEMICLN
    SEMICLN         shift and go to state 152


state 118

    (41) arg -> logic multiarg .
    RPAREN          reduce using rule 41 (arg -> logic multiarg .)
    COMMA           reduce using rule 41 (arg -> logic multiarg .)


state 119

    (42) multiarg -> empty .
    COMMA           reduce using rule 42 (multiarg -> empty .)
    RPAREN          reduce using rule 42 (multiarg -> empty .)


state 120

    (43) multiarg -> COMMA . arg multiarg
    (40) arg -> . empty
    (41) arg -> . logic multiarg
    (93) empty -> .
    (50) logic -> . rel log2 OR log1 logic
    (51) logic -> . rel log2 AND log1 logic
    (52) logic -> . rel log2
    (61) rel -> . exp rel2 relop rel1 rel
    (62) rel -> . exp rel2
    (65) exp -> . term exp2 SUB exp1 exp
    (66) exp -> . term exp2 SUM exp1 exp
    (67) exp -> . term exp2
    (70) term -> . factor term2 DIV term1 term
    (71) term -> . factor term2 MULT term1 term
    (72) term -> . factor term2
    (75) factor -> . FALSE ctes4
    (76) factor -> . TRUE ctes4
    (77) factor -> . CTE_STR ctes3
    (78) factor -> . CTE_FLT ctes2
    (79) factor -> . CTE_NUM ctes1
    (80) factor -> . ID fact1 LPAREN logic multiexp RPAREN
    (81) factor -> . ID fact1 arr
    COMMA           reduce using rule 93 (empty -> .)
    RPAREN          reduce using rule 93 (empty -> .)
    FALSE           shift and go to state 82
    TRUE            shift and go to state 83
    CTE_STR         shift and go to state 84
    CTE_FLT         shift and go to state 85
    CTE_NUM         shift and go to state 86
    ID              shift and go to state 87

    arg                            shift and go to state 153
    empty                          shift and go to state 93
    logic                          shift and go to state 94
    rel                            shift and go to state 78
    exp                            shift and go to state 79
    term                           shift and go to state 80
    factor                         shift and go to state 81

state 121

    (39) func_stmnt -> ID . LPAREN arg RPAREN SEMICLN
    LPAREN          shift and go to state 68


state 122

    (36) ass_stmnt -> ID arr ASS func_stmnt . SEMICLN
    SEMICLN         shift and go to state 154


state 123

    (37) ass_stmnt -> ID ass1 arr ASS . logic SEMICLN
    (50) logic -> . rel log2 OR log1 logic
    (51) logic -> . rel log2 AND log1 logic
    (52) logic -> . rel log2
    (61) rel -> . exp rel2 relop rel1 rel
    (62) rel -> . exp rel2
    (65) exp -> . term exp2 SUB exp1 exp
    (66) exp -> . term exp2 SUM exp1 exp
    (67) exp -> . term exp2
    (70) term -> . factor term2 DIV term1 term
    (71) term -> . factor term2 MULT term1 term
    (72) term -> . factor term2
    (75) factor -> . FALSE ctes4
    (76) factor -> . TRUE ctes4
    (77) factor -> . CTE_STR ctes3
    (78) factor -> . CTE_FLT ctes2
    (79) factor -> . CTE_NUM ctes1
    (80) factor -> . ID fact1 LPAREN logic multiexp RPAREN
    (81) factor -> . ID fact1 arr
    FALSE           shift and go to state 82
    TRUE            shift and go to state 83
    CTE_STR         shift and go to state 84
    CTE_FLT         shift and go to state 85
    CTE_NUM         shift and go to state 86
    ID              shift and go to state 87

    logic                          shift and go to state 155
    rel                            shift and go to state 78
    exp                            shift and go to state 79
    term                           shift and go to state 80
    factor                         shift and go to state 81

state 124

    (18) arr -> LSQUARE exp RSQUARE .
    ASS             reduce using rule 18 (arr -> LSQUARE exp RSQUARE .)
    COMMA           reduce using rule 18 (arr -> LSQUARE exp RSQUARE .)
    FUNC            reduce using rule 18 (arr -> LSQUARE exp RSQUARE .)
    MAIN            reduce using rule 18 (arr -> LSQUARE exp RSQUARE .)
    LCURLY          reduce using rule 18 (arr -> LSQUARE exp RSQUARE .)
    SEMICLN         reduce using rule 18 (arr -> LSQUARE exp RSQUARE .)
    DIV             reduce using rule 18 (arr -> LSQUARE exp RSQUARE .)
    MULT            reduce using rule 18 (arr -> LSQUARE exp RSQUARE .)
    SUB             reduce using rule 18 (arr -> LSQUARE exp RSQUARE .)
    SUM             reduce using rule 18 (arr -> LSQUARE exp RSQUARE .)
    EQUAL_TO        reduce using rule 18 (arr -> LSQUARE exp RSQUARE .)
    DIFFERENT_TO    reduce using rule 18 (arr -> LSQUARE exp RSQUARE .)
    LESS_OR_EQ_THAN reduce using rule 18 (arr -> LSQUARE exp RSQUARE .)
    MORE_OR_EQ_THAN reduce using rule 18 (arr -> LSQUARE exp RSQUARE .)
    LESS_THAN       reduce using rule 18 (arr -> LSQUARE exp RSQUARE .)
    MORE_THAN       reduce using rule 18 (arr -> LSQUARE exp RSQUARE .)
    OR              reduce using rule 18 (arr -> LSQUARE exp RSQUARE .)
    AND             reduce using rule 18 (arr -> LSQUARE exp RSQUARE .)
    RPAREN          reduce using rule 18 (arr -> LSQUARE exp RSQUARE .)
    RSQUARE         reduce using rule 18 (arr -> LSQUARE exp RSQUARE .)


state 125

    (20) funcdecl -> FUNC tipofunc ID LPAREN param RPAREN varsdecl LCURLY . stmnt RCURLY
    (28) stmnt -> . empty
    (29) stmnt -> . while_stmnt stmnt
    (30) stmnt -> . if_stmnt stmnt
    (31) stmnt -> . write_stmnt stmnt
    (32) stmnt -> . read_stmnt stmnt
    (33) stmnt -> . ret_stmnt stmnt
    (34) stmnt -> . func_stmnt stmnt
    (35) stmnt -> . ass_stmnt stmnt
    (93) empty -> .
    (92) while_stmnt -> . WHILE LPAREN logic RPAREN stmnt END
    (89) if_stmnt -> . IF LPAREN logic RPAREN else_stmnt END
    (46) write_stmnt -> . WRITE linear1 LPAREN logic linear2 RPAREN linear3 SEMICLN
    (45) read_stmnt -> . READ linear1 LPAREN logic linear2 RPAREN linear3 SEMICLN
    (44) ret_stmnt -> . RETURN LPAREN logic RPAREN SEMICLN
    (39) func_stmnt -> . ID LPAREN arg RPAREN SEMICLN
    (36) ass_stmnt -> . ID arr ASS func_stmnt SEMICLN
    (37) ass_stmnt -> . ID ass1 arr ASS logic SEMICLN
    RCURLY          reduce using rule 93 (empty -> .)
    WHILE           shift and go to state 45
    IF              shift and go to state 46
    WRITE           shift and go to state 47
    READ            shift and go to state 48
    RETURN          shift and go to state 49
    ID              shift and go to state 50

    stmnt                          shift and go to state 156
    empty                          shift and go to state 37
    while_stmnt                    shift and go to state 38
    if_stmnt                       shift and go to state 39
    write_stmnt                    shift and go to state 40
    read_stmnt                     shift and go to state 41
    ret_stmnt                      shift and go to state 42
    func_stmnt                     shift and go to state 43
    ass_stmnt                      shift and go to state 44

state 126

    (24) param -> tipo COLON ID multiparam .
    RPAREN          reduce using rule 24 (param -> tipo COLON ID multiparam .)


state 127

    (25) multiparam -> empty .
    RPAREN          reduce using rule 25 (multiparam -> empty .)


state 128

    (26) multiparam -> COMMA . param
    (23) param -> . empty
    (24) param -> . tipo COLON ID multiparam
    (93) empty -> .
    (13) tipo -> . BOOL
    (14) tipo -> . CHAR
    (15) tipo -> . FLOAT
    (16) tipo -> . INT
    RPAREN          reduce using rule 93 (empty -> .)
    BOOL            shift and go to state 19
    CHAR            shift and go to state 20
    FLOAT           shift and go to state 21
    INT             shift and go to state 22

    param                          shift and go to state 157
    empty                          shift and go to state 52
    tipo                           shift and go to state 53

state 129

    (8) multivd -> tipo prog4 COLON ID prog5 arr multid . SEMICLN multivd
    SEMICLN         shift and go to state 158


state 130

    (92) while_stmnt -> WHILE LPAREN logic RPAREN stmnt . END
    END             shift and go to state 159


state 131

    (50) logic -> rel log2 OR . log1 logic
    (53) log1 -> .
    FALSE           reduce using rule 53 (log1 -> .)
    TRUE            reduce using rule 53 (log1 -> .)
    CTE_STR         reduce using rule 53 (log1 -> .)
    CTE_FLT         reduce using rule 53 (log1 -> .)
    CTE_NUM         reduce using rule 53 (log1 -> .)
    ID              reduce using rule 53 (log1 -> .)

    log1                           shift and go to state 160

state 132

    (51) logic -> rel log2 AND . log1 logic
    (53) log1 -> .
    FALSE           reduce using rule 53 (log1 -> .)
    TRUE            reduce using rule 53 (log1 -> .)
    CTE_STR         reduce using rule 53 (log1 -> .)
    CTE_FLT         reduce using rule 53 (log1 -> .)
    CTE_NUM         reduce using rule 53 (log1 -> .)
    ID              reduce using rule 53 (log1 -> .)

    log1                           shift and go to state 161

state 133

    (61) rel -> exp rel2 relop . rel1 rel
    (63) rel1 -> .
    FALSE           reduce using rule 63 (rel1 -> .)
    TRUE            reduce using rule 63 (rel1 -> .)
    CTE_STR         reduce using rule 63 (rel1 -> .)
    CTE_FLT         reduce using rule 63 (rel1 -> .)
    CTE_NUM         reduce using rule 63 (rel1 -> .)
    ID              reduce using rule 63 (rel1 -> .)

    rel1                           shift and go to state 162

state 134

    (55) relop -> EQUAL_TO .
    FALSE           reduce using rule 55 (relop -> EQUAL_TO .)
    TRUE            reduce using rule 55 (relop -> EQUAL_TO .)
    CTE_STR         reduce using rule 55 (relop -> EQUAL_TO .)
    CTE_FLT         reduce using rule 55 (relop -> EQUAL_TO .)
    CTE_NUM         reduce using rule 55 (relop -> EQUAL_TO .)
    ID              reduce using rule 55 (relop -> EQUAL_TO .)


state 135

    (56) relop -> DIFFERENT_TO .
    FALSE           reduce using rule 56 (relop -> DIFFERENT_TO .)
    TRUE            reduce using rule 56 (relop -> DIFFERENT_TO .)
    CTE_STR         reduce using rule 56 (relop -> DIFFERENT_TO .)
    CTE_FLT         reduce using rule 56 (relop -> DIFFERENT_TO .)
    CTE_NUM         reduce using rule 56 (relop -> DIFFERENT_TO .)
    ID              reduce using rule 56 (relop -> DIFFERENT_TO .)


state 136

    (57) relop -> LESS_OR_EQ_THAN .
    FALSE           reduce using rule 57 (relop -> LESS_OR_EQ_THAN .)
    TRUE            reduce using rule 57 (relop -> LESS_OR_EQ_THAN .)
    CTE_STR         reduce using rule 57 (relop -> LESS_OR_EQ_THAN .)
    CTE_FLT         reduce using rule 57 (relop -> LESS_OR_EQ_THAN .)
    CTE_NUM         reduce using rule 57 (relop -> LESS_OR_EQ_THAN .)
    ID              reduce using rule 57 (relop -> LESS_OR_EQ_THAN .)


state 137

    (58) relop -> MORE_OR_EQ_THAN .
    FALSE           reduce using rule 58 (relop -> MORE_OR_EQ_THAN .)
    TRUE            reduce using rule 58 (relop -> MORE_OR_EQ_THAN .)
    CTE_STR         reduce using rule 58 (relop -> MORE_OR_EQ_THAN .)
    CTE_FLT         reduce using rule 58 (relop -> MORE_OR_EQ_THAN .)
    CTE_NUM         reduce using rule 58 (relop -> MORE_OR_EQ_THAN .)
    ID              reduce using rule 58 (relop -> MORE_OR_EQ_THAN .)


state 138

    (59) relop -> LESS_THAN .
    FALSE           reduce using rule 59 (relop -> LESS_THAN .)
    TRUE            reduce using rule 59 (relop -> LESS_THAN .)
    CTE_STR         reduce using rule 59 (relop -> LESS_THAN .)
    CTE_FLT         reduce using rule 59 (relop -> LESS_THAN .)
    CTE_NUM         reduce using rule 59 (relop -> LESS_THAN .)
    ID              reduce using rule 59 (relop -> LESS_THAN .)


state 139

    (60) relop -> MORE_THAN .
    FALSE           reduce using rule 60 (relop -> MORE_THAN .)
    TRUE            reduce using rule 60 (relop -> MORE_THAN .)
    CTE_STR         reduce using rule 60 (relop -> MORE_THAN .)
    CTE_FLT         reduce using rule 60 (relop -> MORE_THAN .)
    CTE_NUM         reduce using rule 60 (relop -> MORE_THAN .)
    ID              reduce using rule 60 (relop -> MORE_THAN .)


state 140

    (65) exp -> term exp2 SUB . exp1 exp
    (69) exp1 -> .
    FALSE           reduce using rule 69 (exp1 -> .)
    TRUE            reduce using rule 69 (exp1 -> .)
    CTE_STR         reduce using rule 69 (exp1 -> .)
    CTE_FLT         reduce using rule 69 (exp1 -> .)
    CTE_NUM         reduce using rule 69 (exp1 -> .)
    ID              reduce using rule 69 (exp1 -> .)

    exp1                           shift and go to state 163

state 141

    (66) exp -> term exp2 SUM . exp1 exp
    (69) exp1 -> .
    FALSE           reduce using rule 69 (exp1 -> .)
    TRUE            reduce using rule 69 (exp1 -> .)
    CTE_STR         reduce using rule 69 (exp1 -> .)
    CTE_FLT         reduce using rule 69 (exp1 -> .)
    CTE_NUM         reduce using rule 69 (exp1 -> .)
    ID              reduce using rule 69 (exp1 -> .)

    exp1                           shift and go to state 164

state 142

    (70) term -> factor term2 DIV . term1 term
    (73) term1 -> .
    FALSE           reduce using rule 73 (term1 -> .)
    TRUE            reduce using rule 73 (term1 -> .)
    CTE_STR         reduce using rule 73 (term1 -> .)
    CTE_FLT         reduce using rule 73 (term1 -> .)
    CTE_NUM         reduce using rule 73 (term1 -> .)
    ID              reduce using rule 73 (term1 -> .)

    term1                          shift and go to state 165

state 143

    (71) term -> factor term2 MULT . term1 term
    (73) term1 -> .
    FALSE           reduce using rule 73 (term1 -> .)
    TRUE            reduce using rule 73 (term1 -> .)
    CTE_STR         reduce using rule 73 (term1 -> .)
    CTE_FLT         reduce using rule 73 (term1 -> .)
    CTE_NUM         reduce using rule 73 (term1 -> .)
    ID              reduce using rule 73 (term1 -> .)

    term1                          shift and go to state 166

state 144

    (80) factor -> ID fact1 LPAREN . logic multiexp RPAREN
    (50) logic -> . rel log2 OR log1 logic
    (51) logic -> . rel log2 AND log1 logic
    (52) logic -> . rel log2
    (61) rel -> . exp rel2 relop rel1 rel
    (62) rel -> . exp rel2
    (65) exp -> . term exp2 SUB exp1 exp
    (66) exp -> . term exp2 SUM exp1 exp
    (67) exp -> . term exp2
    (70) term -> . factor term2 DIV term1 term
    (71) term -> . factor term2 MULT term1 term
    (72) term -> . factor term2
    (75) factor -> . FALSE ctes4
    (76) factor -> . TRUE ctes4
    (77) factor -> . CTE_STR ctes3
    (78) factor -> . CTE_FLT ctes2
    (79) factor -> . CTE_NUM ctes1
    (80) factor -> . ID fact1 LPAREN logic multiexp RPAREN
    (81) factor -> . ID fact1 arr
    FALSE           shift and go to state 82
    TRUE            shift and go to state 83
    CTE_STR         shift and go to state 84
    CTE_FLT         shift and go to state 85
    CTE_NUM         shift and go to state 86
    ID              shift and go to state 87

    logic                          shift and go to state 167
    rel                            shift and go to state 78
    exp                            shift and go to state 79
    term                           shift and go to state 80
    factor                         shift and go to state 81

state 145

    (81) factor -> ID fact1 arr .
    DIV             reduce using rule 81 (factor -> ID fact1 arr .)
    MULT            reduce using rule 81 (factor -> ID fact1 arr .)
    SUB             reduce using rule 81 (factor -> ID fact1 arr .)
    SUM             reduce using rule 81 (factor -> ID fact1 arr .)
    EQUAL_TO        reduce using rule 81 (factor -> ID fact1 arr .)
    DIFFERENT_TO    reduce using rule 81 (factor -> ID fact1 arr .)
    LESS_OR_EQ_THAN reduce using rule 81 (factor -> ID fact1 arr .)
    MORE_OR_EQ_THAN reduce using rule 81 (factor -> ID fact1 arr .)
    LESS_THAN       reduce using rule 81 (factor -> ID fact1 arr .)
    MORE_THAN       reduce using rule 81 (factor -> ID fact1 arr .)
    OR              reduce using rule 81 (factor -> ID fact1 arr .)
    AND             reduce using rule 81 (factor -> ID fact1 arr .)
    RPAREN          reduce using rule 81 (factor -> ID fact1 arr .)
    COMMA           reduce using rule 81 (factor -> ID fact1 arr .)
    RSQUARE         reduce using rule 81 (factor -> ID fact1 arr .)
    SEMICLN         reduce using rule 81 (factor -> ID fact1 arr .)


state 146

    (89) if_stmnt -> IF LPAREN logic RPAREN else_stmnt . END
    END             shift and go to state 168


state 147

    (90) else_stmnt -> empty .
    END             reduce using rule 90 (else_stmnt -> empty .)


state 148

    (91) else_stmnt -> ELSE . stmnt
    (28) stmnt -> . empty
    (29) stmnt -> . while_stmnt stmnt
    (30) stmnt -> . if_stmnt stmnt
    (31) stmnt -> . write_stmnt stmnt
    (32) stmnt -> . read_stmnt stmnt
    (33) stmnt -> . ret_stmnt stmnt
    (34) stmnt -> . func_stmnt stmnt
    (35) stmnt -> . ass_stmnt stmnt
    (93) empty -> .
    (92) while_stmnt -> . WHILE LPAREN logic RPAREN stmnt END
    (89) if_stmnt -> . IF LPAREN logic RPAREN else_stmnt END
    (46) write_stmnt -> . WRITE linear1 LPAREN logic linear2 RPAREN linear3 SEMICLN
    (45) read_stmnt -> . READ linear1 LPAREN logic linear2 RPAREN linear3 SEMICLN
    (44) ret_stmnt -> . RETURN LPAREN logic RPAREN SEMICLN
    (39) func_stmnt -> . ID LPAREN arg RPAREN SEMICLN
    (36) ass_stmnt -> . ID arr ASS func_stmnt SEMICLN
    (37) ass_stmnt -> . ID ass1 arr ASS logic SEMICLN
    END             reduce using rule 93 (empty -> .)
    WHILE           shift and go to state 45
    IF              shift and go to state 46
    WRITE           shift and go to state 47
    READ            shift and go to state 48
    RETURN          shift and go to state 49
    ID              shift and go to state 50

    stmnt                          shift and go to state 169
    empty                          shift and go to state 37
    while_stmnt                    shift and go to state 38
    if_stmnt                       shift and go to state 39
    write_stmnt                    shift and go to state 40
    read_stmnt                     shift and go to state 41
    ret_stmnt                      shift and go to state 42
    func_stmnt                     shift and go to state 43
    ass_stmnt                      shift and go to state 44

state 149

    (46) write_stmnt -> WRITE linear1 LPAREN logic linear2 . RPAREN linear3 SEMICLN
    RPAREN          shift and go to state 170


state 150

    (45) read_stmnt -> READ linear1 LPAREN logic linear2 . RPAREN linear3 SEMICLN
    RPAREN          shift and go to state 171


state 151

    (44) ret_stmnt -> RETURN LPAREN logic RPAREN SEMICLN .
    WHILE           reduce using rule 44 (ret_stmnt -> RETURN LPAREN logic RPAREN SEMICLN .)
    IF              reduce using rule 44 (ret_stmnt -> RETURN LPAREN logic RPAREN SEMICLN .)
    WRITE           reduce using rule 44 (ret_stmnt -> RETURN LPAREN logic RPAREN SEMICLN .)
    READ            reduce using rule 44 (ret_stmnt -> RETURN LPAREN logic RPAREN SEMICLN .)
    RETURN          reduce using rule 44 (ret_stmnt -> RETURN LPAREN logic RPAREN SEMICLN .)
    ID              reduce using rule 44 (ret_stmnt -> RETURN LPAREN logic RPAREN SEMICLN .)
    $end            reduce using rule 44 (ret_stmnt -> RETURN LPAREN logic RPAREN SEMICLN .)
    END             reduce using rule 44 (ret_stmnt -> RETURN LPAREN logic RPAREN SEMICLN .)
    RCURLY          reduce using rule 44 (ret_stmnt -> RETURN LPAREN logic RPAREN SEMICLN .)


state 152

    (39) func_stmnt -> ID LPAREN arg RPAREN SEMICLN .
    WHILE           reduce using rule 39 (func_stmnt -> ID LPAREN arg RPAREN SEMICLN .)
    IF              reduce using rule 39 (func_stmnt -> ID LPAREN arg RPAREN SEMICLN .)
    WRITE           reduce using rule 39 (func_stmnt -> ID LPAREN arg RPAREN SEMICLN .)
    READ            reduce using rule 39 (func_stmnt -> ID LPAREN arg RPAREN SEMICLN .)
    RETURN          reduce using rule 39 (func_stmnt -> ID LPAREN arg RPAREN SEMICLN .)
    ID              reduce using rule 39 (func_stmnt -> ID LPAREN arg RPAREN SEMICLN .)
    $end            reduce using rule 39 (func_stmnt -> ID LPAREN arg RPAREN SEMICLN .)
    END             reduce using rule 39 (func_stmnt -> ID LPAREN arg RPAREN SEMICLN .)
    RCURLY          reduce using rule 39 (func_stmnt -> ID LPAREN arg RPAREN SEMICLN .)
    SEMICLN         reduce using rule 39 (func_stmnt -> ID LPAREN arg RPAREN SEMICLN .)


state 153

    (43) multiarg -> COMMA arg . multiarg
    (42) multiarg -> . empty
    (43) multiarg -> . COMMA arg multiarg
    (93) empty -> .
  ! shift/reduce conflict for COMMA resolved as shift
    COMMA           shift and go to state 120
    RPAREN          reduce using rule 93 (empty -> .)

    multiarg                       shift and go to state 172
    empty                          shift and go to state 119

state 154

    (36) ass_stmnt -> ID arr ASS func_stmnt SEMICLN .
    WHILE           reduce using rule 36 (ass_stmnt -> ID arr ASS func_stmnt SEMICLN .)
    IF              reduce using rule 36 (ass_stmnt -> ID arr ASS func_stmnt SEMICLN .)
    WRITE           reduce using rule 36 (ass_stmnt -> ID arr ASS func_stmnt SEMICLN .)
    READ            reduce using rule 36 (ass_stmnt -> ID arr ASS func_stmnt SEMICLN .)
    RETURN          reduce using rule 36 (ass_stmnt -> ID arr ASS func_stmnt SEMICLN .)
    ID              reduce using rule 36 (ass_stmnt -> ID arr ASS func_stmnt SEMICLN .)
    $end            reduce using rule 36 (ass_stmnt -> ID arr ASS func_stmnt SEMICLN .)
    END             reduce using rule 36 (ass_stmnt -> ID arr ASS func_stmnt SEMICLN .)
    RCURLY          reduce using rule 36 (ass_stmnt -> ID arr ASS func_stmnt SEMICLN .)


state 155

    (37) ass_stmnt -> ID ass1 arr ASS logic . SEMICLN
    SEMICLN         shift and go to state 173


state 156

    (20) funcdecl -> FUNC tipofunc ID LPAREN param RPAREN varsdecl LCURLY stmnt . RCURLY
    RCURLY          shift and go to state 174


state 157

    (26) multiparam -> COMMA param .
    RPAREN          reduce using rule 26 (multiparam -> COMMA param .)


state 158

    (8) multivd -> tipo prog4 COLON ID prog5 arr multid SEMICLN . multivd
    (7) multivd -> . empty
    (8) multivd -> . tipo prog4 COLON ID prog5 arr multid SEMICLN multivd
    (93) empty -> .
    (13) tipo -> . BOOL
    (14) tipo -> . CHAR
    (15) tipo -> . FLOAT
    (16) tipo -> . INT
    COMMA           reduce using rule 93 (empty -> .)
    FUNC            reduce using rule 93 (empty -> .)
    MAIN            reduce using rule 93 (empty -> .)
    LCURLY          reduce using rule 93 (empty -> .)
    BOOL            shift and go to state 19
    CHAR            shift and go to state 20
    FLOAT           shift and go to state 21
    INT             shift and go to state 22

    tipo                           shift and go to state 25
    multivd                        shift and go to state 175
    empty                          shift and go to state 24

state 159

    (92) while_stmnt -> WHILE LPAREN logic RPAREN stmnt END .
    WHILE           reduce using rule 92 (while_stmnt -> WHILE LPAREN logic RPAREN stmnt END .)
    IF              reduce using rule 92 (while_stmnt -> WHILE LPAREN logic RPAREN stmnt END .)
    WRITE           reduce using rule 92 (while_stmnt -> WHILE LPAREN logic RPAREN stmnt END .)
    READ            reduce using rule 92 (while_stmnt -> WHILE LPAREN logic RPAREN stmnt END .)
    RETURN          reduce using rule 92 (while_stmnt -> WHILE LPAREN logic RPAREN stmnt END .)
    ID              reduce using rule 92 (while_stmnt -> WHILE LPAREN logic RPAREN stmnt END .)
    $end            reduce using rule 92 (while_stmnt -> WHILE LPAREN logic RPAREN stmnt END .)
    END             reduce using rule 92 (while_stmnt -> WHILE LPAREN logic RPAREN stmnt END .)
    RCURLY          reduce using rule 92 (while_stmnt -> WHILE LPAREN logic RPAREN stmnt END .)


state 160

    (50) logic -> rel log2 OR log1 . logic
    (50) logic -> . rel log2 OR log1 logic
    (51) logic -> . rel log2 AND log1 logic
    (52) logic -> . rel log2
    (61) rel -> . exp rel2 relop rel1 rel
    (62) rel -> . exp rel2
    (65) exp -> . term exp2 SUB exp1 exp
    (66) exp -> . term exp2 SUM exp1 exp
    (67) exp -> . term exp2
    (70) term -> . factor term2 DIV term1 term
    (71) term -> . factor term2 MULT term1 term
    (72) term -> . factor term2
    (75) factor -> . FALSE ctes4
    (76) factor -> . TRUE ctes4
    (77) factor -> . CTE_STR ctes3
    (78) factor -> . CTE_FLT ctes2
    (79) factor -> . CTE_NUM ctes1
    (80) factor -> . ID fact1 LPAREN logic multiexp RPAREN
    (81) factor -> . ID fact1 arr
    FALSE           shift and go to state 82
    TRUE            shift and go to state 83
    CTE_STR         shift and go to state 84
    CTE_FLT         shift and go to state 85
    CTE_NUM         shift and go to state 86
    ID              shift and go to state 87

    rel                            shift and go to state 78
    logic                          shift and go to state 176
    exp                            shift and go to state 79
    term                           shift and go to state 80
    factor                         shift and go to state 81

state 161

    (51) logic -> rel log2 AND log1 . logic
    (50) logic -> . rel log2 OR log1 logic
    (51) logic -> . rel log2 AND log1 logic
    (52) logic -> . rel log2
    (61) rel -> . exp rel2 relop rel1 rel
    (62) rel -> . exp rel2
    (65) exp -> . term exp2 SUB exp1 exp
    (66) exp -> . term exp2 SUM exp1 exp
    (67) exp -> . term exp2
    (70) term -> . factor term2 DIV term1 term
    (71) term -> . factor term2 MULT term1 term
    (72) term -> . factor term2
    (75) factor -> . FALSE ctes4
    (76) factor -> . TRUE ctes4
    (77) factor -> . CTE_STR ctes3
    (78) factor -> . CTE_FLT ctes2
    (79) factor -> . CTE_NUM ctes1
    (80) factor -> . ID fact1 LPAREN logic multiexp RPAREN
    (81) factor -> . ID fact1 arr
    FALSE           shift and go to state 82
    TRUE            shift and go to state 83
    CTE_STR         shift and go to state 84
    CTE_FLT         shift and go to state 85
    CTE_NUM         shift and go to state 86
    ID              shift and go to state 87

    rel                            shift and go to state 78
    logic                          shift and go to state 177
    exp                            shift and go to state 79
    term                           shift and go to state 80
    factor                         shift and go to state 81

state 162

    (61) rel -> exp rel2 relop rel1 . rel
    (61) rel -> . exp rel2 relop rel1 rel
    (62) rel -> . exp rel2
    (65) exp -> . term exp2 SUB exp1 exp
    (66) exp -> . term exp2 SUM exp1 exp
    (67) exp -> . term exp2
    (70) term -> . factor term2 DIV term1 term
    (71) term -> . factor term2 MULT term1 term
    (72) term -> . factor term2
    (75) factor -> . FALSE ctes4
    (76) factor -> . TRUE ctes4
    (77) factor -> . CTE_STR ctes3
    (78) factor -> . CTE_FLT ctes2
    (79) factor -> . CTE_NUM ctes1
    (80) factor -> . ID fact1 LPAREN logic multiexp RPAREN
    (81) factor -> . ID fact1 arr
    FALSE           shift and go to state 82
    TRUE            shift and go to state 83
    CTE_STR         shift and go to state 84
    CTE_FLT         shift and go to state 85
    CTE_NUM         shift and go to state 86
    ID              shift and go to state 87

    exp                            shift and go to state 79
    rel                            shift and go to state 178
    term                           shift and go to state 80
    factor                         shift and go to state 81

state 163

    (65) exp -> term exp2 SUB exp1 . exp
    (65) exp -> . term exp2 SUB exp1 exp
    (66) exp -> . term exp2 SUM exp1 exp
    (67) exp -> . term exp2
    (70) term -> . factor term2 DIV term1 term
    (71) term -> . factor term2 MULT term1 term
    (72) term -> . factor term2
    (75) factor -> . FALSE ctes4
    (76) factor -> . TRUE ctes4
    (77) factor -> . CTE_STR ctes3
    (78) factor -> . CTE_FLT ctes2
    (79) factor -> . CTE_NUM ctes1
    (80) factor -> . ID fact1 LPAREN logic multiexp RPAREN
    (81) factor -> . ID fact1 arr
    FALSE           shift and go to state 82
    TRUE            shift and go to state 83
    CTE_STR         shift and go to state 84
    CTE_FLT         shift and go to state 85
    CTE_NUM         shift and go to state 86
    ID              shift and go to state 87

    term                           shift and go to state 80
    exp                            shift and go to state 179
    factor                         shift and go to state 81

state 164

    (66) exp -> term exp2 SUM exp1 . exp
    (65) exp -> . term exp2 SUB exp1 exp
    (66) exp -> . term exp2 SUM exp1 exp
    (67) exp -> . term exp2
    (70) term -> . factor term2 DIV term1 term
    (71) term -> . factor term2 MULT term1 term
    (72) term -> . factor term2
    (75) factor -> . FALSE ctes4
    (76) factor -> . TRUE ctes4
    (77) factor -> . CTE_STR ctes3
    (78) factor -> . CTE_FLT ctes2
    (79) factor -> . CTE_NUM ctes1
    (80) factor -> . ID fact1 LPAREN logic multiexp RPAREN
    (81) factor -> . ID fact1 arr
    FALSE           shift and go to state 82
    TRUE            shift and go to state 83
    CTE_STR         shift and go to state 84
    CTE_FLT         shift and go to state 85
    CTE_NUM         shift and go to state 86
    ID              shift and go to state 87

    term                           shift and go to state 80
    exp                            shift and go to state 180
    factor                         shift and go to state 81

state 165

    (70) term -> factor term2 DIV term1 . term
    (70) term -> . factor term2 DIV term1 term
    (71) term -> . factor term2 MULT term1 term
    (72) term -> . factor term2
    (75) factor -> . FALSE ctes4
    (76) factor -> . TRUE ctes4
    (77) factor -> . CTE_STR ctes3
    (78) factor -> . CTE_FLT ctes2
    (79) factor -> . CTE_NUM ctes1
    (80) factor -> . ID fact1 LPAREN logic multiexp RPAREN
    (81) factor -> . ID fact1 arr
    FALSE           shift and go to state 82
    TRUE            shift and go to state 83
    CTE_STR         shift and go to state 84
    CTE_FLT         shift and go to state 85
    CTE_NUM         shift and go to state 86
    ID              shift and go to state 87

    factor                         shift and go to state 81
    term                           shift and go to state 181

state 166

    (71) term -> factor term2 MULT term1 . term
    (70) term -> . factor term2 DIV term1 term
    (71) term -> . factor term2 MULT term1 term
    (72) term -> . factor term2
    (75) factor -> . FALSE ctes4
    (76) factor -> . TRUE ctes4
    (77) factor -> . CTE_STR ctes3
    (78) factor -> . CTE_FLT ctes2
    (79) factor -> . CTE_NUM ctes1
    (80) factor -> . ID fact1 LPAREN logic multiexp RPAREN
    (81) factor -> . ID fact1 arr
    FALSE           shift and go to state 82
    TRUE            shift and go to state 83
    CTE_STR         shift and go to state 84
    CTE_FLT         shift and go to state 85
    CTE_NUM         shift and go to state 86
    ID              shift and go to state 87

    factor                         shift and go to state 81
    term                           shift and go to state 182

state 167

    (80) factor -> ID fact1 LPAREN logic . multiexp RPAREN
    (87) multiexp -> . empty
    (88) multiexp -> . COMMA logic multiexp
    (93) empty -> .
    COMMA           shift and go to state 185
    RPAREN          reduce using rule 93 (empty -> .)

    multiexp                       shift and go to state 183
    empty                          shift and go to state 184

state 168

    (89) if_stmnt -> IF LPAREN logic RPAREN else_stmnt END .
    WHILE           reduce using rule 89 (if_stmnt -> IF LPAREN logic RPAREN else_stmnt END .)
    IF              reduce using rule 89 (if_stmnt -> IF LPAREN logic RPAREN else_stmnt END .)
    WRITE           reduce using rule 89 (if_stmnt -> IF LPAREN logic RPAREN else_stmnt END .)
    READ            reduce using rule 89 (if_stmnt -> IF LPAREN logic RPAREN else_stmnt END .)
    RETURN          reduce using rule 89 (if_stmnt -> IF LPAREN logic RPAREN else_stmnt END .)
    ID              reduce using rule 89 (if_stmnt -> IF LPAREN logic RPAREN else_stmnt END .)
    $end            reduce using rule 89 (if_stmnt -> IF LPAREN logic RPAREN else_stmnt END .)
    END             reduce using rule 89 (if_stmnt -> IF LPAREN logic RPAREN else_stmnt END .)
    RCURLY          reduce using rule 89 (if_stmnt -> IF LPAREN logic RPAREN else_stmnt END .)


state 169

    (91) else_stmnt -> ELSE stmnt .
    END             reduce using rule 91 (else_stmnt -> ELSE stmnt .)


state 170

    (46) write_stmnt -> WRITE linear1 LPAREN logic linear2 RPAREN . linear3 SEMICLN
    (49) linear3 -> .
    SEMICLN         reduce using rule 49 (linear3 -> .)

    linear3                        shift and go to state 186

state 171

    (45) read_stmnt -> READ linear1 LPAREN logic linear2 RPAREN . linear3 SEMICLN
    (49) linear3 -> .
    SEMICLN         reduce using rule 49 (linear3 -> .)

    linear3                        shift and go to state 187

state 172

    (43) multiarg -> COMMA arg multiarg .
    COMMA           reduce using rule 43 (multiarg -> COMMA arg multiarg .)
    RPAREN          reduce using rule 43 (multiarg -> COMMA arg multiarg .)


state 173

    (37) ass_stmnt -> ID ass1 arr ASS logic SEMICLN .
    WHILE           reduce using rule 37 (ass_stmnt -> ID ass1 arr ASS logic SEMICLN .)
    IF              reduce using rule 37 (ass_stmnt -> ID ass1 arr ASS logic SEMICLN .)
    WRITE           reduce using rule 37 (ass_stmnt -> ID ass1 arr ASS logic SEMICLN .)
    READ            reduce using rule 37 (ass_stmnt -> ID ass1 arr ASS logic SEMICLN .)
    RETURN          reduce using rule 37 (ass_stmnt -> ID ass1 arr ASS logic SEMICLN .)
    ID              reduce using rule 37 (ass_stmnt -> ID ass1 arr ASS logic SEMICLN .)
    $end            reduce using rule 37 (ass_stmnt -> ID ass1 arr ASS logic SEMICLN .)
    END             reduce using rule 37 (ass_stmnt -> ID ass1 arr ASS logic SEMICLN .)
    RCURLY          reduce using rule 37 (ass_stmnt -> ID ass1 arr ASS logic SEMICLN .)


state 174

    (20) funcdecl -> FUNC tipofunc ID LPAREN param RPAREN varsdecl LCURLY stmnt RCURLY .
    MAIN            reduce using rule 20 (funcdecl -> FUNC tipofunc ID LPAREN param RPAREN varsdecl LCURLY stmnt RCURLY .)


state 175

    (8) multivd -> tipo prog4 COLON ID prog5 arr multid SEMICLN multivd .
    COMMA           reduce using rule 8 (multivd -> tipo prog4 COLON ID prog5 arr multid SEMICLN multivd .)
    FUNC            reduce using rule 8 (multivd -> tipo prog4 COLON ID prog5 arr multid SEMICLN multivd .)
    MAIN            reduce using rule 8 (multivd -> tipo prog4 COLON ID prog5 arr multid SEMICLN multivd .)
    LCURLY          reduce using rule 8 (multivd -> tipo prog4 COLON ID prog5 arr multid SEMICLN multivd .)


state 176

    (50) logic -> rel log2 OR log1 logic .
    RPAREN          reduce using rule 50 (logic -> rel log2 OR log1 logic .)
    COMMA           reduce using rule 50 (logic -> rel log2 OR log1 logic .)
    SEMICLN         reduce using rule 50 (logic -> rel log2 OR log1 logic .)


state 177

    (51) logic -> rel log2 AND log1 logic .
    RPAREN          reduce using rule 51 (logic -> rel log2 AND log1 logic .)
    COMMA           reduce using rule 51 (logic -> rel log2 AND log1 logic .)
    SEMICLN         reduce using rule 51 (logic -> rel log2 AND log1 logic .)


state 178

    (61) rel -> exp rel2 relop rel1 rel .
    OR              reduce using rule 61 (rel -> exp rel2 relop rel1 rel .)
    AND             reduce using rule 61 (rel -> exp rel2 relop rel1 rel .)
    RPAREN          reduce using rule 61 (rel -> exp rel2 relop rel1 rel .)
    COMMA           reduce using rule 61 (rel -> exp rel2 relop rel1 rel .)
    SEMICLN         reduce using rule 61 (rel -> exp rel2 relop rel1 rel .)


state 179

    (65) exp -> term exp2 SUB exp1 exp .
    EQUAL_TO        reduce using rule 65 (exp -> term exp2 SUB exp1 exp .)
    DIFFERENT_TO    reduce using rule 65 (exp -> term exp2 SUB exp1 exp .)
    LESS_OR_EQ_THAN reduce using rule 65 (exp -> term exp2 SUB exp1 exp .)
    MORE_OR_EQ_THAN reduce using rule 65 (exp -> term exp2 SUB exp1 exp .)
    LESS_THAN       reduce using rule 65 (exp -> term exp2 SUB exp1 exp .)
    MORE_THAN       reduce using rule 65 (exp -> term exp2 SUB exp1 exp .)
    OR              reduce using rule 65 (exp -> term exp2 SUB exp1 exp .)
    AND             reduce using rule 65 (exp -> term exp2 SUB exp1 exp .)
    RPAREN          reduce using rule 65 (exp -> term exp2 SUB exp1 exp .)
    COMMA           reduce using rule 65 (exp -> term exp2 SUB exp1 exp .)
    RSQUARE         reduce using rule 65 (exp -> term exp2 SUB exp1 exp .)
    SEMICLN         reduce using rule 65 (exp -> term exp2 SUB exp1 exp .)


state 180

    (66) exp -> term exp2 SUM exp1 exp .
    EQUAL_TO        reduce using rule 66 (exp -> term exp2 SUM exp1 exp .)
    DIFFERENT_TO    reduce using rule 66 (exp -> term exp2 SUM exp1 exp .)
    LESS_OR_EQ_THAN reduce using rule 66 (exp -> term exp2 SUM exp1 exp .)
    MORE_OR_EQ_THAN reduce using rule 66 (exp -> term exp2 SUM exp1 exp .)
    LESS_THAN       reduce using rule 66 (exp -> term exp2 SUM exp1 exp .)
    MORE_THAN       reduce using rule 66 (exp -> term exp2 SUM exp1 exp .)
    OR              reduce using rule 66 (exp -> term exp2 SUM exp1 exp .)
    AND             reduce using rule 66 (exp -> term exp2 SUM exp1 exp .)
    RPAREN          reduce using rule 66 (exp -> term exp2 SUM exp1 exp .)
    COMMA           reduce using rule 66 (exp -> term exp2 SUM exp1 exp .)
    RSQUARE         reduce using rule 66 (exp -> term exp2 SUM exp1 exp .)
    SEMICLN         reduce using rule 66 (exp -> term exp2 SUM exp1 exp .)


state 181

    (70) term -> factor term2 DIV term1 term .
    SUB             reduce using rule 70 (term -> factor term2 DIV term1 term .)
    SUM             reduce using rule 70 (term -> factor term2 DIV term1 term .)
    EQUAL_TO        reduce using rule 70 (term -> factor term2 DIV term1 term .)
    DIFFERENT_TO    reduce using rule 70 (term -> factor term2 DIV term1 term .)
    LESS_OR_EQ_THAN reduce using rule 70 (term -> factor term2 DIV term1 term .)
    MORE_OR_EQ_THAN reduce using rule 70 (term -> factor term2 DIV term1 term .)
    LESS_THAN       reduce using rule 70 (term -> factor term2 DIV term1 term .)
    MORE_THAN       reduce using rule 70 (term -> factor term2 DIV term1 term .)
    OR              reduce using rule 70 (term -> factor term2 DIV term1 term .)
    AND             reduce using rule 70 (term -> factor term2 DIV term1 term .)
    RPAREN          reduce using rule 70 (term -> factor term2 DIV term1 term .)
    COMMA           reduce using rule 70 (term -> factor term2 DIV term1 term .)
    RSQUARE         reduce using rule 70 (term -> factor term2 DIV term1 term .)
    SEMICLN         reduce using rule 70 (term -> factor term2 DIV term1 term .)


state 182

    (71) term -> factor term2 MULT term1 term .
    SUB             reduce using rule 71 (term -> factor term2 MULT term1 term .)
    SUM             reduce using rule 71 (term -> factor term2 MULT term1 term .)
    EQUAL_TO        reduce using rule 71 (term -> factor term2 MULT term1 term .)
    DIFFERENT_TO    reduce using rule 71 (term -> factor term2 MULT term1 term .)
    LESS_OR_EQ_THAN reduce using rule 71 (term -> factor term2 MULT term1 term .)
    MORE_OR_EQ_THAN reduce using rule 71 (term -> factor term2 MULT term1 term .)
    LESS_THAN       reduce using rule 71 (term -> factor term2 MULT term1 term .)
    MORE_THAN       reduce using rule 71 (term -> factor term2 MULT term1 term .)
    OR              reduce using rule 71 (term -> factor term2 MULT term1 term .)
    AND             reduce using rule 71 (term -> factor term2 MULT term1 term .)
    RPAREN          reduce using rule 71 (term -> factor term2 MULT term1 term .)
    COMMA           reduce using rule 71 (term -> factor term2 MULT term1 term .)
    RSQUARE         reduce using rule 71 (term -> factor term2 MULT term1 term .)
    SEMICLN         reduce using rule 71 (term -> factor term2 MULT term1 term .)


state 183

    (80) factor -> ID fact1 LPAREN logic multiexp . RPAREN
    RPAREN          shift and go to state 188


state 184

    (87) multiexp -> empty .
    RPAREN          reduce using rule 87 (multiexp -> empty .)


state 185

    (88) multiexp -> COMMA . logic multiexp
    (50) logic -> . rel log2 OR log1 logic
    (51) logic -> . rel log2 AND log1 logic
    (52) logic -> . rel log2
    (61) rel -> . exp rel2 relop rel1 rel
    (62) rel -> . exp rel2
    (65) exp -> . term exp2 SUB exp1 exp
    (66) exp -> . term exp2 SUM exp1 exp
    (67) exp -> . term exp2
    (70) term -> . factor term2 DIV term1 term
    (71) term -> . factor term2 MULT term1 term
    (72) term -> . factor term2
    (75) factor -> . FALSE ctes4
    (76) factor -> . TRUE ctes4
    (77) factor -> . CTE_STR ctes3
    (78) factor -> . CTE_FLT ctes2
    (79) factor -> . CTE_NUM ctes1
    (80) factor -> . ID fact1 LPAREN logic multiexp RPAREN
    (81) factor -> . ID fact1 arr
    FALSE           shift and go to state 82
    TRUE            shift and go to state 83
    CTE_STR         shift and go to state 84
    CTE_FLT         shift and go to state 85
    CTE_NUM         shift and go to state 86
    ID              shift and go to state 87

    logic                          shift and go to state 189
    rel                            shift and go to state 78
    exp                            shift and go to state 79
    term                           shift and go to state 80
    factor                         shift and go to state 81

state 186

    (46) write_stmnt -> WRITE linear1 LPAREN logic linear2 RPAREN linear3 . SEMICLN
    SEMICLN         shift and go to state 190


state 187

    (45) read_stmnt -> READ linear1 LPAREN logic linear2 RPAREN linear3 . SEMICLN
    SEMICLN         shift and go to state 191


state 188

    (80) factor -> ID fact1 LPAREN logic multiexp RPAREN .
    DIV             reduce using rule 80 (factor -> ID fact1 LPAREN logic multiexp RPAREN .)
    MULT            reduce using rule 80 (factor -> ID fact1 LPAREN logic multiexp RPAREN .)
    SUB             reduce using rule 80 (factor -> ID fact1 LPAREN logic multiexp RPAREN .)
    SUM             reduce using rule 80 (factor -> ID fact1 LPAREN logic multiexp RPAREN .)
    EQUAL_TO        reduce using rule 80 (factor -> ID fact1 LPAREN logic multiexp RPAREN .)
    DIFFERENT_TO    reduce using rule 80 (factor -> ID fact1 LPAREN logic multiexp RPAREN .)
    LESS_OR_EQ_THAN reduce using rule 80 (factor -> ID fact1 LPAREN logic multiexp RPAREN .)
    MORE_OR_EQ_THAN reduce using rule 80 (factor -> ID fact1 LPAREN logic multiexp RPAREN .)
    LESS_THAN       reduce using rule 80 (factor -> ID fact1 LPAREN logic multiexp RPAREN .)
    MORE_THAN       reduce using rule 80 (factor -> ID fact1 LPAREN logic multiexp RPAREN .)
    OR              reduce using rule 80 (factor -> ID fact1 LPAREN logic multiexp RPAREN .)
    AND             reduce using rule 80 (factor -> ID fact1 LPAREN logic multiexp RPAREN .)
    RPAREN          reduce using rule 80 (factor -> ID fact1 LPAREN logic multiexp RPAREN .)
    COMMA           reduce using rule 80 (factor -> ID fact1 LPAREN logic multiexp RPAREN .)
    RSQUARE         reduce using rule 80 (factor -> ID fact1 LPAREN logic multiexp RPAREN .)
    SEMICLN         reduce using rule 80 (factor -> ID fact1 LPAREN logic multiexp RPAREN .)


state 189

    (88) multiexp -> COMMA logic . multiexp
    (87) multiexp -> . empty
    (88) multiexp -> . COMMA logic multiexp
    (93) empty -> .
    COMMA           shift and go to state 185
    RPAREN          reduce using rule 93 (empty -> .)

    multiexp                       shift and go to state 192
    empty                          shift and go to state 184

state 190

    (46) write_stmnt -> WRITE linear1 LPAREN logic linear2 RPAREN linear3 SEMICLN .
    WHILE           reduce using rule 46 (write_stmnt -> WRITE linear1 LPAREN logic linear2 RPAREN linear3 SEMICLN .)
    IF              reduce using rule 46 (write_stmnt -> WRITE linear1 LPAREN logic linear2 RPAREN linear3 SEMICLN .)
    WRITE           reduce using rule 46 (write_stmnt -> WRITE linear1 LPAREN logic linear2 RPAREN linear3 SEMICLN .)
    READ            reduce using rule 46 (write_stmnt -> WRITE linear1 LPAREN logic linear2 RPAREN linear3 SEMICLN .)
    RETURN          reduce using rule 46 (write_stmnt -> WRITE linear1 LPAREN logic linear2 RPAREN linear3 SEMICLN .)
    ID              reduce using rule 46 (write_stmnt -> WRITE linear1 LPAREN logic linear2 RPAREN linear3 SEMICLN .)
    $end            reduce using rule 46 (write_stmnt -> WRITE linear1 LPAREN logic linear2 RPAREN linear3 SEMICLN .)
    END             reduce using rule 46 (write_stmnt -> WRITE linear1 LPAREN logic linear2 RPAREN linear3 SEMICLN .)
    RCURLY          reduce using rule 46 (write_stmnt -> WRITE linear1 LPAREN logic linear2 RPAREN linear3 SEMICLN .)


state 191

    (45) read_stmnt -> READ linear1 LPAREN logic linear2 RPAREN linear3 SEMICLN .
    WHILE           reduce using rule 45 (read_stmnt -> READ linear1 LPAREN logic linear2 RPAREN linear3 SEMICLN .)
    IF              reduce using rule 45 (read_stmnt -> READ linear1 LPAREN logic linear2 RPAREN linear3 SEMICLN .)
    WRITE           reduce using rule 45 (read_stmnt -> READ linear1 LPAREN logic linear2 RPAREN linear3 SEMICLN .)
    READ            reduce using rule 45 (read_stmnt -> READ linear1 LPAREN logic linear2 RPAREN linear3 SEMICLN .)
    RETURN          reduce using rule 45 (read_stmnt -> READ linear1 LPAREN logic linear2 RPAREN linear3 SEMICLN .)
    ID              reduce using rule 45 (read_stmnt -> READ linear1 LPAREN logic linear2 RPAREN linear3 SEMICLN .)
    $end            reduce using rule 45 (read_stmnt -> READ linear1 LPAREN logic linear2 RPAREN linear3 SEMICLN .)
    END             reduce using rule 45 (read_stmnt -> READ linear1 LPAREN logic linear2 RPAREN linear3 SEMICLN .)
    RCURLY          reduce using rule 45 (read_stmnt -> READ linear1 LPAREN logic linear2 RPAREN linear3 SEMICLN .)


state 192

    (88) multiexp -> COMMA logic multiexp .
    RPAREN          reduce using rule 88 (multiexp -> COMMA logic multiexp .)


Conflicts:

shift/reduce conflict for LSQUARE in state 50 resolved as shift
shift/reduce conflict for COMMA in state 94 resolved as shift
shift/reduce conflict for COMMA in state 153 resolved as shift
reduce/reduce conflict in state 50 resolved using rule ass1 -> <empty>
rejected rule (empty -> <empty>) in state 50